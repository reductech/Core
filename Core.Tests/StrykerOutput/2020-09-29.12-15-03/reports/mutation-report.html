<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script>/*! For license information please see mutation-test-elements.js.LICENSE.txt */
!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=28)}([function(e,t,n){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=function(e,t){var n=e[1]||"",r=e[3];if(!r)return n;if(t&&"function"==typeof btoa){var o=(s=r,a=btoa(unescape(encodeURIComponent(JSON.stringify(s)))),l="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(a),"/*# ".concat(l," */")),i=r.sources.map((function(e){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(e," */")}));return[n].concat(i).concat([o]).join("\n")}var s,a,l;return[n].join("\n")}(t,e);return t[2]?"@media ".concat(t[2]," {").concat(n,"}"):n})).join("")},t.i=function(e,n,r){"string"==typeof e&&(e=[[null,e,""]]);var o={};if(r)for(var i=0;i<this.length;i++){var s=this[i][0];null!=s&&(o[s]=!0)}for(var a=0;a<e.length;a++){var l=[].concat(e[a]);r&&o[l[0]]||(n&&(l[2]?l[2]="".concat(n," and ").concat(l[2]):l[2]=n),t.push(l))}},t}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.flatMap=function(e,t){const n=[];return e.map(t).forEach(e=>n.push(...e)),n},t.groupBy=function(e,t){return e.reduce((e,n)=>{const r=t(n);return Object.prototype.hasOwnProperty.call(e,r)||(e[r]=[]),e[r].push(n),e},{})},t.pathJoin=function(...e){return e.reduce((e,t)=>e.length?t?`${e}/${t}`:e:t,"")},t.normalizeFileNames=function(e){const t=Object.keys(e),n=function(e){const t=e.map(e=>e.split(/\/|\\/).slice(0,-1));return e.length?t.reduce((function(e,t){for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e.splice(0,n);return e})).join("/"):""}(t),r={};return t.forEach(t=>{r[function(e){return e.split(/\/|\\/).filter(e=>e).join("/")}(t.substr(n.length))]=e[t]}),r},t.compareNames=function(e,t){const n=e=>e.file?`1${e.name}`:`0${e.name}`;return n(e).localeCompare(n(t))}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(4);t.calculateMetrics=r.calculateMetrics;const o=n(1);t.normalizeFileNames=o.normalizeFileNames},function(e,t,n){(function(t){var n=function(e){var t=/\blang(?:uage)?-([\w-]+)\b/i,n=0,r={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof o?new o(e.type,r.util.encode(e.content),e.alias):Array.isArray(e)?e.map(r.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function e(t,n){var o,i,s=r.util.type(t);switch(n=n||{},s){case"Object":if(i=r.util.objId(t),n[i])return n[i];for(var a in o={},n[i]=o,t)t.hasOwnProperty(a)&&(o[a]=e(t[a],n));return o;case"Array":return i=r.util.objId(t),n[i]?n[i]:(o=[],n[i]=o,t.forEach((function(t,r){o[r]=e(t,n)})),o);default:return t}},getLanguage:function(e){for(;e&&!t.test(e.className);)e=e.parentElement;return e?(e.className.match(t)||[,"none"])[1].toLowerCase():"none"},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(r){var e=(/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(r.stack)||[])[1];if(e){var t=document.getElementsByTagName("script");for(var n in t)if(t[n].src==e)return t[n]}return null}}},languages:{extend:function(e,t){var n=r.util.clone(r.languages[e]);for(var o in t)n[o]=t[o];return n},insertBefore:function(e,t,n,o){var i=(o=o||r.languages)[e],s={};for(var a in i)if(i.hasOwnProperty(a)){if(a==t)for(var l in n)n.hasOwnProperty(l)&&(s[l]=n[l]);n.hasOwnProperty(a)||(s[a]=i[a])}var c=o[e];return o[e]=s,r.languages.DFS(r.languages,(function(t,n){n===c&&t!=e&&(this[t]=s)})),s},DFS:function e(t,n,o,i){i=i||{};var s=r.util.objId;for(var a in t)if(t.hasOwnProperty(a)){n.call(t,a,t[a],o||a);var l=t[a],c=r.util.type(l);"Object"!==c||i[s(l)]?"Array"!==c||i[s(l)]||(i[s(l)]=!0,e(l,n,a,i)):(i[s(l)]=!0,e(l,n,null,i))}}},plugins:{},highlightAll:function(e,t){r.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,n){var o={callback:n,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};r.hooks.run("before-highlightall",o),o.elements=Array.prototype.slice.apply(o.container.querySelectorAll(o.selector)),r.hooks.run("before-all-elements-highlight",o);for(var i,s=0;i=o.elements[s++];)r.highlightElement(i,!0===t,o.callback)},highlightElement:function(n,o,i){var s=r.util.getLanguage(n),a=r.languages[s];n.className=n.className.replace(t,"").replace(/\s+/g," ")+" language-"+s;var l=n.parentNode;l&&"pre"===l.nodeName.toLowerCase()&&(l.className=l.className.replace(t,"").replace(/\s+/g," ")+" language-"+s);var c={element:n,language:s,grammar:a,code:n.textContent};function d(e){c.highlightedCode=e,r.hooks.run("before-insert",c),c.element.innerHTML=c.highlightedCode,r.hooks.run("after-highlight",c),r.hooks.run("complete",c),i&&i.call(c.element)}if(r.hooks.run("before-sanity-check",c),!c.code)return r.hooks.run("complete",c),void(i&&i.call(c.element));if(r.hooks.run("before-highlight",c),c.grammar)if(o&&e.Worker){var u=new Worker(r.filename);u.onmessage=function(e){d(e.data)},u.postMessage(JSON.stringify({language:c.language,code:c.code,immediateClose:!0}))}else d(r.highlight(c.code,c.grammar,c.language));else d(r.util.encode(c.code))},highlight:function(e,t,n){var i={code:e,grammar:t,language:n};return r.hooks.run("before-tokenize",i),i.tokens=r.tokenize(i.code,i.grammar),r.hooks.run("after-tokenize",i),o.stringify(r.util.encode(i.tokens),i.language)},matchGrammar:function(e,t,n,i,s,a,l){for(var c in n)if(n.hasOwnProperty(c)&&n[c]){var d=n[c];d=Array.isArray(d)?d:[d];for(var u=0;u<d.length;++u){if(l&&l==c+","+u)return;var p=d[u],h=p.inside,f=!!p.lookbehind,m=!!p.greedy,g=0,b=p.alias;if(m&&!p.pattern.global){var v=p.pattern.toString().match(/[imsuy]*$/)[0];p.pattern=RegExp(p.pattern.source,v+"g")}p=p.pattern||p;for(var y=i,w=s;y<t.length;w+=t[y].length,++y){var x=t[y];if(t.length>e.length)return;if(!(x instanceof o)){if(m&&y!=t.length-1){if(p.lastIndex=w,!(C=p.exec(e)))break;for(var k=C.index+(f&&C[1]?C[1].length:0),_=C.index+C[0].length,S=y,P=w,E=t.length;S<E&&(P<_||!t[S].type&&!t[S-1].greedy);++S)k>=(P+=t[S].length)&&(++y,w=P);if(t[y]instanceof o)continue;$=S-y,x=e.slice(w,P),C.index-=w}else{p.lastIndex=0;var C=p.exec(x),$=1}if(C){f&&(g=C[1]?C[1].length:0);_=(k=C.index+g)+(C=C[0].slice(g)).length;var N=x.slice(0,k),A=x.slice(_),T=[y,$];N&&(++y,w+=N.length,T.push(N));var M=new o(c,h?r.tokenize(C,h):C,b,C,m);if(T.push(M),A&&T.push(A),Array.prototype.splice.apply(t,T),1!=$&&r.matchGrammar(e,t,n,y,w,!0,c+","+u),a)break}else if(a)break}}}}},tokenize:function(e,t){var n=[e],o=t.rest;if(o){for(var i in o)t[i]=o[i];delete t.rest}return r.matchGrammar(e,n,t,0,0,!1),n},hooks:{all:{},add:function(e,t){var n=r.hooks.all;n[e]=n[e]||[],n[e].push(t)},run:function(e,t){var n=r.hooks.all[e];if(n&&n.length)for(var o,i=0;o=n[i++];)o(t)}},Token:o};function o(e,t,n,r,o){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!o}if(e.Prism=r,o.stringify=function(e,t){if("string"==typeof e)return e;if(Array.isArray(e))return e.map((function(e){return o.stringify(e,t)})).join("");var n={type:e.type,content:o.stringify(e.content,t),tag:"span",classes:["token",e.type],attributes:{},language:t};if(e.alias){var i=Array.isArray(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(n.classes,i)}r.hooks.run("wrap",n);var s=Object.keys(n.attributes).map((function(e){return e+'="'+(n.attributes[e]||"").replace(/"/g,"&quot;")+'"'})).join(" ");return"<"+n.tag+' class="'+n.classes.join(" ")+'"'+(s?" "+s:"")+">"+n.content+"</"+n.tag+">"},!e.document)return e.addEventListener?(r.disableWorkerMessageHandler||e.addEventListener("message",(function(t){var n=JSON.parse(t.data),o=n.language,i=n.code,s=n.immediateClose;e.postMessage(r.highlight(i,r.languages[o],o)),s&&e.close()}),!1),r):r;var i=r.util.currentScript();if(i&&(r.filename=i.src,i.hasAttribute("data-manual")&&(r.manual=!0)),!r.manual){function s(){r.manual||r.highlightAll()}var a=document.readyState;"loading"===a||"interactive"===a&&i&&i.defer?document.addEventListener("DOMContentLoaded",s):window.requestAnimationFrame?window.requestAnimationFrame(s):window.setTimeout(s,16)}return r}("undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{});e.exports&&(e.exports=n),void 0!==t&&(t.Prism=n)}).call(this,n(12))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=n(1),o=n(1);function i(e,t){const n=s(r.flatMap(Object.values(e),e=>e.mutants));return{name:t,childResults:function(e){const t=o.groupBy(Object.entries(e),e=>e[0].split("/")[0]);return Object.keys(t).map(e=>{if(t[e].length>1||t[e][0][0]!==e){const n={};return t[e].forEach(t=>n[t[0].substr(e.length+1)]=t[1]),i(n,e)}return function(e,t){return{file:t,name:e,childResults:[],metrics:s(t.mutants)}}(t[e][0][0],t[e][0][1])}).sort(r.compareNames)}(e),metrics:n}}function s(e){const t=t=>e.filter(e=>e.status===t).length,n=t("Killed"),r=t("Timeout"),o=t("Survived"),i=t("NoCoverage"),s=t("RuntimeError"),a=t("CompileError"),l=t("Ignored"),c=r+n,d=o+i,u=c+o,p=d+c,h=s+a;return{killed:n,timeout:r,survived:o,noCoverage:i,runtimeErrors:s,compileErrors:a,ignored:l,totalDetected:c,totalUndetected:d,totalCovered:u,totalValid:p,totalInvalid:h,mutationScore:p>0?c/p*100:NaN,totalMutants:p+h+l,mutationScoreBasedOnCoveredCode:p>0?c/u*100||0:NaN}}t.calculateMetrics=function(e){return i(r.normalizeFileNames(e),"All files")}},function(e,t,n){(t=n(0)(!1)).push([e.i,'/*!\n * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n * Copyright 2011-2019 The Bootstrap Authors\n * Copyright 2011-2019 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n *//*!\n * Bootstrap v4.4.1 (https://getbootstrap.com/)\n * Copyright 2011-2019 The Bootstrap Authors\n * Copyright 2011-2019 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n */:root{--blue:#007bff;--indigo:#6610f2;--purple:#6f42c1;--pink:#e83e8c;--red:#dc3545;--orange:#fd7e14;--yellow:#ffc107;--green:#28a745;--teal:#20c997;--cyan:#17a2b8;--white:#fff;--gray:#6c757d;--gray-dark:#343a40;--primary:#007bff;--secondary:#6c757d;--success:#28a745;--info:#17a2b8;--warning:#ffc107;--danger:#dc3545;--light:#f8f9fa;--dark:#343a40;--caution:#fd7e14;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-family-monospace:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}*{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0)}header{display:block}[tabindex="-1"]:focus:not(.focus-visible),[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}h1,h3,h5{margin-top:0;margin-bottom:.5rem}p{margin-top:0;margin-bottom:1rem}ol{margin-bottom:1rem}ol{margin-top:0}ol ol{margin-bottom:0}b{font-weight:bolder}small{font-size:80%}a{color:#007bff;text-decoration:none;background-color:transparent}a:hover{color:#0056b3;text-decoration:underline}a:not([href]),a:not([href]):hover{color:inherit;text-decoration:none}code,pre{font-family:SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}pre{margin-top:0;margin-bottom:1rem;overflow:auto}img{border-style:none}img,svg{vertical-align:middle}svg{overflow:hidden}table{border-collapse:collapse}th{text-align:inherit}label{display:inline-block;margin-bottom:.5rem}button{border-radius:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}button,input{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,input{overflow:visible}button{text-transform:none}[type=button],button{-webkit-appearance:button}[type=button]:not(:disabled),button:not(:disabled){cursor:pointer}[type=button]::-moz-focus-inner,button::-moz-focus-inner{padding:0;border-style:none}input[type=checkbox]{box-sizing:border-box;padding:0}legend{display:block;width:100%;max-width:100%;padding:0;margin-bottom:.5rem;font-size:1.5rem;line-height:inherit;color:inherit;white-space:normal}progress{vertical-align:baseline}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[hidden]{display:none!important}.h1,.h3,.h5,h1,h3,h5{margin-bottom:.5rem;font-weight:500;line-height:1.2}.h1,h1{font-size:2.5rem}.h3,h3{font-size:1.75rem}.h5,h5{font-size:1.25rem}.display-4{font-weight:300;line-height:1.2}.display-4{font-size:3.5rem}.small,small{font-size:80%;font-weight:400}code{font-size:87.5%;color:#e83e8c;word-wrap:break-word}a>code{color:inherit}pre{display:block;font-size:87.5%;color:#212529}pre code{font-size:inherit;color:inherit;word-break:normal}.container-fluid{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{display:flex;flex-wrap:wrap;margin-right:-15px;margin-left:-15px}.col-md-12,.col-sm-11{position:relative;width:100%;padding-right:15px;padding-left:15px}@media(min-width:576px){.col-sm-11{flex:0 0 91.6666666667%;max-width:91.6666666667%}}@media(min-width:768px){.col-md-12{flex:0 0 100%;max-width:100%}}.table{width:100%;margin-bottom:1rem;color:#212529}.table td,.table th{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}.table thead th{vertical-align:bottom;border-bottom:2px solid #dee2e6}.table tbody+tbody{border-top:2px solid #dee2e6}.table-sm td,.table-sm th{padding:.3rem}.table-bordered,.table-bordered td,.table-bordered th{border:1px solid #dee2e6}.table-bordered thead td,.table-bordered thead th{border-bottom-width:2px}.table-hover tbody tr:hover{color:#212529;background-color:rgba(0,0,0,.075)}.form-check{position:relative;display:block;padding-left:1.25rem}.form-check-input{position:absolute;margin-top:.3rem;margin-left:-1.25rem}.form-check-input:disabled~.form-check-label{color:#6c757d}.form-check-label{margin-bottom:0}.form-check-inline{display:inline-flex;align-items:center;padding-left:0;margin-right:.75rem}.form-check-inline .form-check-input{position:static;margin-top:0;margin-right:.3125rem;margin-left:0}.btn{display:inline-block;font-weight:400;color:#212529;text-align:center;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:transparent;border:1px solid transparent;padding:.375rem .75rem;font-size:1rem;line-height:1.5;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media(prefers-reduced-motion:reduce){.btn{transition:none}}.btn:hover{color:#212529;text-decoration:none}.btn:focus{outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.btn:disabled{opacity:.65}.btn-secondary{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:focus,.btn-secondary:hover{color:#fff;background-color:#5a6268;border-color:#545b62}.btn-secondary:focus{box-shadow:0 0 0 .2rem rgba(130,138,145,.5)}.btn-secondary:disabled{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:not(:disabled):not(.disabled).active,.btn-secondary:not(:disabled):not(.disabled):active{color:#fff;background-color:#545b62;border-color:#4e555b}.btn-secondary:not(:disabled):not(.disabled).active:focus,.btn-secondary:not(:disabled):not(.disabled):active:focus{box-shadow:0 0 0 .2rem rgba(130,138,145,.5)}.btn-link{font-weight:400;color:#007bff;text-decoration:none}.btn-link:hover{color:#0056b3;text-decoration:underline}.btn-link:focus{text-decoration:underline;box-shadow:none}.btn-link:disabled{color:#6c757d;pointer-events:none}.btn-sm{padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.breadcrumb{display:flex;flex-wrap:wrap;padding:.75rem 1rem;margin-bottom:1rem;list-style:none;background-color:#e9ecef;border-radius:.25rem}.breadcrumb-item+.breadcrumb-item{padding-left:.5rem}.breadcrumb-item+.breadcrumb-item:before{display:inline-block;padding-right:.5rem;color:#6c757d;content:"/"}.breadcrumb-item+.breadcrumb-item:hover:before{text-decoration:underline;text-decoration:none}.breadcrumb-item.active{color:#6c757d}.badge{display:inline-block;padding:.25em .4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media(prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:focus,a.badge:hover{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:focus,a.badge-secondary:hover{color:#fff;background-color:#545b62}a.badge-secondary:focus{outline:0;box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:focus,a.badge-success:hover{color:#fff;background-color:#1e7e34}a.badge-success:focus{outline:0;box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:focus,a.badge-info:hover{color:#fff;background-color:#117a8b}a.badge-info:focus{outline:0;box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:focus,a.badge-warning:hover{color:#212529;background-color:#d39e00}a.badge-warning:focus{outline:0;box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:focus,a.badge-danger:hover{color:#fff;background-color:#bd2130}a.badge-danger:focus{outline:0;box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.badge-caution{color:#212529;background-color:#fd7e14}a.badge-caution:focus,a.badge-caution:hover{color:#212529;background-color:#dc6502}a.badge-caution:focus{outline:0;box-shadow:0 0 0 .2rem rgba(253,126,20,.5)}.alert{position:relative;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid transparent;border-radius:.25rem}.alert-danger{color:#721c24;background-color:#f8d7da;border-color:#f5c6cb}@-webkit-keyframes progress-bar-stripes{to{background-position:0 0}}@keyframes progress-bar-stripes{0%{background-position:1rem 0}to{background-position:0 0}}.progress{height:1rem;font-size:.75rem;background-color:#e9ecef;border-radius:.25rem}.progress,.progress-bar{display:flex;overflow:hidden}.progress-bar{flex-direction:column;justify-content:center;color:#fff;text-align:center;white-space:nowrap;background-color:#007bff;transition:width .6s ease}@media(prefers-reduced-motion:reduce){.progress-bar{transition:none}}.modal{position:fixed;top:0;left:0;z-index:1050;display:none;width:100%;height:100%;overflow:hidden;outline:0}.modal-dialog{position:relative;width:auto;margin:.5rem;pointer-events:none}.modal.show .modal-dialog{transform:none}.modal-content{position:relative;display:flex;flex-direction:column;width:100%;pointer-events:auto;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem;outline:0}.modal-backdrop{position:fixed;top:0;left:0;z-index:1040;width:100vw;height:100vh;background-color:#000}.modal-backdrop.show{opacity:.5}.modal-header{display:flex;align-items:flex-start;justify-content:space-between;padding:1rem;border-bottom:1px solid #dee2e6;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.modal-title{margin-bottom:0;line-height:1.5}.modal-body{position:relative;flex:1 1 auto;padding:1rem}.modal-footer{display:flex;flex-wrap:wrap;align-items:center;justify-content:flex-end;padding:.75rem;border-top:1px solid #dee2e6;border-bottom-right-radius:calc(.3rem - 1px);border-bottom-left-radius:calc(.3rem - 1px)}.modal-footer>*{margin:.25rem}@media(min-width:576px){.modal-dialog{max-width:500px;margin:1.75rem auto}}.popover{top:0;left:0;z-index:1060;max-width:276px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem}.popover{position:absolute;display:block}.popover-header{padding:.5rem .75rem;margin-bottom:0;font-size:1rem;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.popover-header:empty{display:none}.popover-body{padding:.5rem .75rem;color:#212529}@-webkit-keyframes spinner-border{to{transform:rotate(1turn)}}@keyframes spinner-border{to{transform:rotate(1turn)}}@keyframes spinner-grow{0%{transform:scale(0)}50%{opacity:1}}.bg-secondary{background-color:#6c757d!important}a.bg-secondary:focus,a.bg-secondary:hover,button.bg-secondary:focus,button.bg-secondary:hover{background-color:#545b62!important}.bg-success{background-color:#28a745!important}a.bg-success:focus,a.bg-success:hover,button.bg-success:focus,button.bg-success:hover{background-color:#1e7e34!important}.bg-warning{background-color:#ffc107!important}a.bg-warning:focus,a.bg-warning:hover,button.bg-warning:focus,button.bg-warning:hover{background-color:#d39e00!important}.bg-danger{background-color:#dc3545!important}a.bg-danger:focus,a.bg-danger:hover,button.bg-danger:focus,button.bg-danger:hover{background-color:#bd2130!important}.bg-caution{background-color:#fd7e14!important}a.bg-caution:focus,a.bg-caution:hover,button.bg-caution:focus,button.bg-caution:hover{background-color:#dc6502!important}.text-center{text-align:center!important}.font-weight-bold{font-weight:700!important}.text-white{color:#fff!important}.text-secondary{color:#6c757d!important}a.text-secondary:focus,a.text-secondary:hover{color:#494f54!important}.text-success{color:#28a745!important}a.text-success:focus,a.text-success:hover{color:#19692c!important}.text-warning{color:#ffc107!important}a.text-warning:focus,a.text-warning:hover{color:#ba8b00!important}.text-danger{color:#dc3545!important}a.text-danger:focus,a.text-danger:hover{color:#a71d2a!important}.text-caution{color:#fd7e14!important}a.text-caution:focus,a.text-caution:hover{color:#c35a02!important}.text-muted{color:#6c757d!important}@media print{*{text-shadow:none!important;box-shadow:none!important}a:not(.btn){text-decoration:underline}pre{white-space:pre-wrap!important}pre{border:1px solid #adb5bd;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}h3,p{orphans:3;widows:3}h3{page-break-after:avoid}@page{size:a3}.badge{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #dee2e6!important}}',""]),e.exports=t},function(e,t,n){var r=n(0),o=n(7),i=n(8);(t=r(!1)).i(o),t.i(i),t.push([e.i,"",""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,'/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*="language-"],\npre[class*="language-"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, \'Andale Mono\', \'Ubuntu Mono\', monospace;\n\tfont-size: 1em;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,\ncode[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*="language-"]::selection, pre[class*="language-"] ::selection,\ncode[class*="language-"]::selection, code[class*="language-"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*="language-"],\n\tpre[class*="language-"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*="language-"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*="language-"],\npre[class*="language-"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*="language-"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.token.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #9a6e3a;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function,\n.token.class-name {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n',""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,'pre[class*="language-"].line-numbers {\n\tposition: relative;\n\tpadding-left: 3.8em;\n\tcounter-reset: linenumber;\n}\n\npre[class*="language-"].line-numbers > code {\n\tposition: relative;\n\twhite-space: inherit;\n}\n\n.line-numbers .line-numbers-rows {\n\tposition: absolute;\n\tpointer-events: none;\n\ttop: 0;\n\tfont-size: 100%;\n\tleft: -3.8em;\n\twidth: 3em; /* works for line-numbers below 1000 lines */\n\tletter-spacing: -1px;\n\tborder-right: 1px solid #999;\n\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\n}\n\n\t.line-numbers-rows > span {\n\t\tpointer-events: none;\n\t\tdisplay: block;\n\t\tcounter-increment: linenumber;\n\t}\n\n\t\t.line-numbers-rows > span:before {\n\t\t\tcontent: counter(linenumber);\n\t\t\tcolor: #999;\n\t\t\tdisplay: block;\n\t\t\tpadding-right: 0.8em;\n\t\t\ttext-align: right;\n\t\t}\n',""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,":host{line-height:1.15;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-size:1rem;font-weight:400;line-height:1.5;color:#212529;text-align:left;background-color:#fff}.display-4 small{font-weight:300}",""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,'/*!\n * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n * Copyright 2011-2019 The Bootstrap Authors\n * Copyright 2011-2019 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n */*{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0)}header{display:block}[tabindex="-1"]:focus:not(.focus-visible),[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}h1,h3,h5{margin-top:0;margin-bottom:.5rem}p{margin-top:0;margin-bottom:1rem}ol{margin-bottom:1rem}ol{margin-top:0}ol ol{margin-bottom:0}b{font-weight:bolder}small{font-size:80%}a{color:#007bff;text-decoration:none;background-color:transparent}a:hover{color:#0056b3;text-decoration:underline}a:not([href]),a:not([href]):hover{color:inherit;text-decoration:none}code,pre{font-family:SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}pre{margin-top:0;margin-bottom:1rem;overflow:auto}img{border-style:none}img,svg{vertical-align:middle}svg{overflow:hidden}table{border-collapse:collapse}th{text-align:inherit}label{display:inline-block;margin-bottom:.5rem}button{border-radius:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}button,input{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,input{overflow:visible}button{text-transform:none}[type=button],button{-webkit-appearance:button}[type=button]:not(:disabled),button:not(:disabled){cursor:pointer}[type=button]::-moz-focus-inner,button::-moz-focus-inner{padding:0;border-style:none}input[type=checkbox]{box-sizing:border-box;padding:0}legend{display:block;width:100%;max-width:100%;padding:0;margin-bottom:.5rem;font-size:1.5rem;line-height:inherit;color:inherit;white-space:normal}progress{vertical-align:baseline}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[hidden]{display:none!important}:host{position:relative;display:inline-block;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.popover{width:200px;z-index:1;top:125%;margin-left:-100px;visibility:hidden;opacity:0;transition:.1s ease-in}.popover,.popover:before{position:absolute;left:50%}.popover:before{content:"";top:-10px;margin-left:-6px;border:6px solid transparent;border-bottom-color:#555}.popover-caution:before{border-bottom-color:#fd7e14}.popover-secondary:before{border-bottom-color:#6c757d}.popover-success:before{border-bottom-color:#28a745}.popover-warning:before{border-bottom-color:#ffc107}.popover-danger:before{border-bottom-color:#dc3545}.popover.show{visibility:visible;opacity:1}',""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,".badge{cursor:pointer}.disabled-code{text-decoration:line-through}span.badge{text-shadow:none}",""]),e.exports=t},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t){!function(){if("undefined"!=typeof self&&self.Prism&&self.document){var e=/\n(?!$)/g,t=function(t){var r=n(t)["white-space"];if("pre-wrap"===r||"pre-line"===r){var o=t.querySelector("code"),i=t.querySelector(".line-numbers-rows"),s=t.querySelector(".line-numbers-sizer"),a=o.textContent.split(e);s||((s=document.createElement("span")).className="line-numbers-sizer",o.appendChild(s)),s.style.display="block",a.forEach((function(e,t){s.textContent=e||"\n";var n=s.getBoundingClientRect().height;i.children[t].style.height=n+"px"})),s.textContent="",s.style.display="none"}},n=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener("resize",(function(){Array.prototype.forEach.call(document.querySelectorAll("pre.line-numbers"),t)})),Prism.hooks.add("complete",(function(n){if(n.code){var r=n.element,o=r.parentNode;if(o&&/pre/i.test(o.nodeName)&&!r.querySelector(".line-numbers-rows")){for(var i=!1,s=/(?:^|\s)line-numbers(?:\s|$)/,a=r;a;a=a.parentNode)if(s.test(a.className)){i=!0;break}if(i){r.className=r.className.replace(s," "),s.test(o.className)||(o.className+=" line-numbers");var l,c=n.code.match(e),d=c?c.length+1:1,u=new Array(d+1).join("<span></span>");(l=document.createElement("span")).setAttribute("aria-hidden","true"),l.className="line-numbers-rows",l.innerHTML=u,o.hasAttribute("data-start")&&(o.style.counterReset="linenumber "+(parseInt(o.getAttribute("data-start"),10)-1)),n.element.appendChild(l),t(o),Prism.hooks.run("line-numbers",n)}}}})),Prism.hooks.add("line-numbers",(function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0})),Prism.plugins.lineNumbers={getLine:function(e,t){if("PRE"===e.tagName&&e.classList.contains("line-numbers")){var n=e.querySelector(".line-numbers-rows"),r=parseInt(e.getAttribute("data-start"),10)||1,o=r+(n.children.length-1);t<r&&(t=r),t>o&&(t=o);var i=t-r;return n.children[i]}}}}}()},function(e,t){Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/}},function(e,t){Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/--|\+\+|\*\*=?|=>|&&|\|\||[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?[.?]?|[~:]/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*[\s\S]*?\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{"template-string":{pattern:/`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\${|}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}}}),Prism.languages.markup&&Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.js=Prism.languages.javascript},function(e,t){Prism.languages.typescript=Prism.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|undefined|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/}),Prism.languages.ts=Prism.languages.typescript},function(e,t){Prism.languages.csharp=Prism.languages.extend("clike",{keyword:/\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/,string:[{pattern:/@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0},{pattern:/("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,greedy:!0}],"class-name":[{pattern:/\b[A-Z]\w*(?:\.\w+)*\b(?=\s+\w+)/,inside:{punctuation:/\./}},{pattern:/(\[)[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}},{pattern:/(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}},{pattern:/((?:\b(?:class|interface|new)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}}],number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)f?/i,operator:/>>=?|<<=?|[-=]>|([-+&|?])\1|~|[-+*/%&|^!=<>]=?/,punctuation:/\?\.?|::|[{}[\];(),.:]/}),Prism.languages.insertBefore("csharp","class-name",{"generic-method":{pattern:/\w+\s*<[^>\r\n]+?>\s*(?=\()/,inside:{function:/^\w+/,"class-name":{pattern:/\b[A-Z]\w*(?:\.\w+)*\b/,inside:{punctuation:/\./}},keyword:Prism.languages.csharp.keyword,punctuation:/[<>(),.:]/}},preprocessor:{pattern:/(^\s*)#.*/m,lookbehind:!0,alias:"property",inside:{directive:{pattern:/(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,lookbehind:!0,alias:"keyword"}}}}),Prism.languages.dotnet=Prism.languages.cs=Prism.languages.csharp},function(e,t){!function(e){var t=/\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|null|open|opens|package|private|protected|provides|public|requires|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,n=/\b[A-Z](?:\w*[a-z]\w*)?\b/;e.languages.java=e.languages.extend("clike",{"class-name":[n,/\b[A-Z]\w*(?=\s+\w+\s*[;,=())])/],keyword:t,function:[e.languages.clike.function,{pattern:/(\:\:)[a-z_]\w*/,lookbehind:!0}],number:/\b0b[01][01_]*L?\b|\b0x[\da-f_]*\.?[\da-f_p+-]+\b|(?:\b\d[\d_]*\.?[\d_]*|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,operator:{pattern:/(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,lookbehind:!0}}),e.languages.insertBefore("java","string",{"triple-quoted-string":{pattern:/"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,greedy:!0,alias:"string"}}),e.languages.insertBefore("java","class-name",{annotation:{alias:"punctuation",pattern:/(^|[^.])@\w+/,lookbehind:!0},namespace:{pattern:/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)[a-z]\w*(?:\.[a-z]\w*)+/,lookbehind:!0,inside:{punctuation:/\./}},generics:{pattern:/<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,inside:{"class-name":n,keyword:t,punctuation:/[<>(),.:]/,operator:/[?&|]/}}})}(Prism)},function(e,t){Prism.languages.scala=Prism.languages.extend("java",{keyword:/<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,"triple-quoted-string":{pattern:/"""[\s\S]*?"""/,greedy:!0,alias:"string"},string:{pattern:/("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,greedy:!0},builtin:/\b(?:String|Int|Long|Short|Byte|Boolean|Double|Float|Char|Any|AnyRef|AnyVal|Unit|Nothing)\b/,number:/\b0x[\da-f]*\.?[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e\d+)?[dfl]?/i,symbol:/'[^\d\s\\]\w*/}),delete Prism.languages.scala["class-name"],delete Prism.languages.scala.function},function(e,t){Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:(?!<!--)[^"'\]]|"[^"]*"|'[^']*'|<!--[\s\S]*?-->)*\]\s*)?>/i,greedy:!0},cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",(function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"))})),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(e,t){var n={};n["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:Prism.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i;var r={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}};r["language-"+t]={pattern:/[\s\S]+/,inside:Prism.languages[t]};var o={};o[e]={pattern:RegExp(/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(/__/g,e),"i"),lookbehind:!0,greedy:!0,inside:r},Prism.languages.insertBefore("markup","cdata",o)}}),Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup},function(e,t){!function(e){function t(e,t){return"___"+e.toUpperCase()+t+"___"}Object.defineProperties(e.languages["markup-templating"]={},{buildPlaceholders:{value:function(n,r,o,i){if(n.language===r){var s=n.tokenStack=[];n.code=n.code.replace(o,(function(e){if("function"==typeof i&&!i(e))return e;for(var o,a=s.length;-1!==n.code.indexOf(o=t(r,a));)++a;return s[a]=e,o})),n.grammar=e.languages.markup}}},tokenizePlaceholders:{value:function(n,r){if(n.language===r&&n.tokenStack){n.grammar=e.languages[r];var o=0,i=Object.keys(n.tokenStack);!function s(a){for(var l=0;l<a.length&&!(o>=i.length);l++){var c=a[l];if("string"==typeof c||c.content&&"string"==typeof c.content){var d=i[o],u=n.tokenStack[d],p="string"==typeof c?c:c.content,h=t(r,d),f=p.indexOf(h);if(f>-1){++o;var m=p.substring(0,f),g=new e.Token(r,e.tokenize(u,n.grammar),"language-"+r,u),b=p.substring(f+h.length),v=[];m&&v.push.apply(v,s([m])),v.push(g),b&&v.push.apply(v,s([b])),"string"==typeof c?a.splice.apply(a,[l,1].concat(v)):c.content=v}}else c.content&&s(c.content)}return a}(n.tokens)}}}})}(Prism)},function(e,t){!function(e){e.languages.php=e.languages.extend("clike",{keyword:/\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|finally|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|new|or|parent|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i,boolean:{pattern:/\b(?:false|true)\b/i,alias:"constant"},constant:[/\b[A-Z_][A-Z0-9_]*\b/,/\b(?:null)\b/i],comment:{pattern:/(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,lookbehind:!0}}),e.languages.insertBefore("php","string",{"shell-comment":{pattern:/(^|[^\\])#.*/,lookbehind:!0,alias:"comment"}}),e.languages.insertBefore("php","comment",{delimiter:{pattern:/\?>$|^<\?(?:php(?=\s)|=)?/i,alias:"important"}}),e.languages.insertBefore("php","keyword",{variable:/\$+(?:\w+\b|(?={))/i,package:{pattern:/(\\|namespace\s+|use\s+)[\w\\]+/,lookbehind:!0,inside:{punctuation:/\\/}}}),e.languages.insertBefore("php","operator",{property:{pattern:/(->)[\w]+/,lookbehind:!0}});var t={pattern:/{\$(?:{(?:{[^{}]+}|[^{}]+)}|[^{}])+}|(^|[^\\{])\$+(?:\w+(?:\[.+?]|->\w+)*)/,lookbehind:!0,inside:e.languages.php};e.languages.insertBefore("php","string",{"nowdoc-string":{pattern:/<<<'([^']+)'(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;/,greedy:!0,alias:"string",inside:{delimiter:{pattern:/^<<<'[^']+'|[a-z_]\w*;$/i,alias:"symbol",inside:{punctuation:/^<<<'?|[';]$/}}}},"heredoc-string":{pattern:/<<<(?:"([^"]+)"(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;|([a-z_]\w*)(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\2;)/i,greedy:!0,alias:"string",inside:{delimiter:{pattern:/^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,alias:"symbol",inside:{punctuation:/^<<<"?|[";]$/}},interpolation:t}},"single-quoted-string":{pattern:/'(?:\\[\s\S]|[^\\'])*'/,greedy:!0,alias:"string"},"double-quoted-string":{pattern:/"(?:\\[\s\S]|[^\\"])*"/,greedy:!0,alias:"string",inside:{interpolation:t}}}),delete e.languages.php.string,e.hooks.add("before-tokenize",(function(t){if(/<\?/.test(t.code)){e.languages["markup-templating"].buildPlaceholders(t,"php",/<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#)(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|\/\*[\s\S]*?(?:\*\/|$))*?(?:\?>|$)/gi)}})),e.hooks.add("after-tokenize",(function(t){e.languages["markup-templating"].tokenizePlaceholders(t,"php")}))}(Prism)},function(e,t){!function(e,t){void 0!==e&&e.Prism&&e.document&&t.createRange&&(Prism.plugins.KeepMarkup=!0,Prism.hooks.add("before-highlight",(function(e){if(e.element.children.length){var t=0,n=[],r=function(e,o){var i={};o||(i.clone=e.cloneNode(!1),i.posOpen=t,n.push(i));for(var s=0,a=e.childNodes.length;s<a;s++){var l=e.childNodes[s];1===l.nodeType?r(l):3===l.nodeType&&(t+=l.data.length)}o||(i.posClose=t)};r(e.element,!0),n&&n.length&&(e.keepMarkup=n)}})),Prism.hooks.add("after-highlight",(function(e){if(e.keepMarkup&&e.keepMarkup.length){var n=function(e,r){for(var o=0,i=e.childNodes.length;o<i;o++){var s=e.childNodes[o];if(1===s.nodeType){if(!n(s,r))return!1}else 3===s.nodeType&&(!r.nodeStart&&r.pos+s.data.length>r.node.posOpen&&(r.nodeStart=s,r.nodeStartPos=r.node.posOpen-r.pos),r.nodeStart&&r.pos+s.data.length>=r.node.posClose&&(r.nodeEnd=s,r.nodeEndPos=r.node.posClose-r.pos),r.pos+=s.data.length);if(r.nodeStart&&r.nodeEnd){var a=t.createRange();return a.setStart(r.nodeStart,r.nodeStartPos),a.setEnd(r.nodeEnd,r.nodeEndPos),r.node.clone.appendChild(a.extractContents()),a.insertNode(r.node.clone),a.detach(),!1}}return!0};e.keepMarkup.forEach((function(t){n(e.element,{node:t,pos:0})})),e.highlightedCode=e.element.innerHTML}})))}(self,document)},function(e,t,n){(t=n(0)(!1)).push([e.i,'/*!\n * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n * Copyright 2011-2019 The Bootstrap Authors\n * Copyright 2011-2019 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n */*{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0)}header{display:block}[tabindex="-1"]:focus:not(.focus-visible),[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}h1,h3,h5{margin-top:0;margin-bottom:.5rem}p{margin-top:0;margin-bottom:1rem}ol{margin-bottom:1rem}ol{margin-top:0}ol ol{margin-bottom:0}b{font-weight:bolder}small{font-size:80%}a{color:#007bff;text-decoration:none;background-color:transparent}a:hover{color:#0056b3;text-decoration:underline}a:not([href]),a:not([href]):hover{color:inherit;text-decoration:none}code,pre{font-family:SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}pre{margin-top:0;margin-bottom:1rem;overflow:auto}img{border-style:none}img,svg{vertical-align:middle}svg{overflow:hidden}table{border-collapse:collapse}th{text-align:inherit}label{display:inline-block;margin-bottom:.5rem}button{border-radius:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}button,input{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,input{overflow:visible}button{text-transform:none}[type=button],button{-webkit-appearance:button}[type=button]:not(:disabled),button:not(:disabled){cursor:pointer}[type=button]::-moz-focus-inner,button::-moz-focus-inner{padding:0;border-style:none}input[type=checkbox]{box-sizing:border-box;padding:0}legend{display:block;width:100%;max-width:100%;padding:0;margin-bottom:.5rem;font-size:1.5rem;line-height:inherit;color:inherit;white-space:normal}progress{vertical-align:baseline}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[hidden]{display:none!important}.bg-danger-light{background-color:#f2dede}.bg-success-light{background-color:#dff0d8}.bg-warning-light{background-color:#fcf8e3}.bg-caution-light{background-color:#ffedde}#report-code-block{overflow:visible}',""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,".table a{display:block}th.rotate{height:80px;white-space:nowrap;padding-bottom:10px}th.rotate>div{transform:translate(27px) rotate(325deg);width:30px}.table-no-top,.table-no-top>thead>tr>th{border-width:0}.table-no-top{margin-bottom:0}.table .no-border-right{border-right:none}.table .no-border-left{border-left:none}table td.icon{color:rgba(3,47,98,.55);padding-left:10px;padding-right:2px}.octicon{fill:currentColor}table td.vertical-middle,table th.vertical-middle{vertical-align:middle}.text-default{color:#777}",""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,".modal-dialog{margin-top:5.15rem}",""]),e.exports=t},function(e,t,n){(t=n(0)(!1)).push([e.i,".legend{position:-webkit-sticky;position:sticky;top:0;top:var(--top-offset,0);background:#fff;margin-top:.5rem;margin-bottom:.5rem;padding-top:.5rem;padding-bottom:.5rem;z-index:10}.badge{font-size:1em;cursor:pointer}",""]),e.exports=t},function(e,t,n){"use strict";n.r(t);const r=new WeakMap,o=e=>"function"==typeof e&&r.has(e),i=void 0!==window.customElements&&void 0!==window.customElements.polyfillWrapFlushCallback,s=(e,t,n=null)=>{for(;t!==n;){const n=t.nextSibling;e.removeChild(t),t=n}},a={},l={},c=`{{lit-${String(Math.random()).slice(2)}}}`,d=`\x3c!--${c}--\x3e`,u=new RegExp(`${c}|${d}`);class p{constructor(e,t){this.parts=[],this.element=t;const n=[],r=[],o=document.createTreeWalker(t.content,133,null,!1);let i=0,s=-1,a=0;const{strings:l,values:{length:d}}=e;for(;a<d;){const e=o.nextNode();if(null!==e){if(s++,1===e.nodeType){if(e.hasAttributes()){const t=e.attributes,{length:n}=t;let r=0;for(let e=0;e<n;e++)h(t[e].name,"$lit$")&&r++;for(;r-- >0;){const t=l[a],n=g.exec(t)[2],r=n.toLowerCase()+"$lit$",o=e.getAttribute(r);e.removeAttribute(r);const i=o.split(u);this.parts.push({type:"attribute",index:s,name:n,strings:i}),a+=i.length-1}}"TEMPLATE"===e.tagName&&(r.push(e),o.currentNode=e.content)}else if(3===e.nodeType){const t=e.data;if(t.indexOf(c)>=0){const r=e.parentNode,o=t.split(u),i=o.length-1;for(let t=0;t<i;t++){let n,i=o[t];if(""===i)n=m();else{const e=g.exec(i);null!==e&&h(e[2],"$lit$")&&(i=i.slice(0,e.index)+e[1]+e[2].slice(0,-"$lit$".length)+e[3]),n=document.createTextNode(i)}r.insertBefore(n,e),this.parts.push({type:"node",index:++s})}""===o[i]?(r.insertBefore(m(),e),n.push(e)):e.data=o[i],a+=i}}else if(8===e.nodeType)if(e.data===c){const t=e.parentNode;null!==e.previousSibling&&s!==i||(s++,t.insertBefore(m(),e)),i=s,this.parts.push({type:"node",index:s}),null===e.nextSibling?e.data="":(n.push(e),s--),a++}else{let t=-1;for(;-1!==(t=e.data.indexOf(c,t+1));)this.parts.push({type:"node",index:-1}),a++}}else o.currentNode=r.pop()}for(const e of n)e.parentNode.removeChild(e)}}const h=(e,t)=>{const n=e.length-t.length;return n>=0&&e.slice(n)===t},f=e=>-1!==e.index,m=()=>document.createComment(""),g=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;class b{constructor(e,t,n){this.__parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this.__parts)void 0!==n&&n.setValue(e[t]),t++;for(const e of this.__parts)void 0!==e&&e.commit()}_clone(){const e=i?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=[],n=this.template.parts,r=document.createTreeWalker(e,133,null,!1);let o,s=0,a=0,l=r.nextNode();for(;s<n.length;)if(o=n[s],f(o)){for(;a<o.index;)a++,"TEMPLATE"===l.nodeName&&(t.push(l),r.currentNode=l.content),null===(l=r.nextNode())&&(r.currentNode=t.pop(),l=r.nextNode());if("node"===o.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(l.previousSibling),this.__parts.push(e)}else this.__parts.push(...this.processor.handleAttributeExpressions(l,o.name,o.strings,this.options));s++}else this.__parts.push(void 0),s++;return i&&(document.adoptNode(e),customElements.upgrade(e)),e}}const v=` ${c} `;class y{constructor(e,t,n,r){this.strings=e,this.values=t,this.type=n,this.processor=r}getHTML(){const e=this.strings.length-1;let t="",n=!1;for(let r=0;r<e;r++){const e=this.strings[r],o=e.lastIndexOf("\x3c!--");n=(o>-1||n)&&-1===e.indexOf("--\x3e",o+1);const i=g.exec(e);t+=null===i?e+(n?v:d):e.substr(0,i.index)+i[1]+i[2]+"$lit$"+i[3]+c}return t+=this.strings[e],t}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}class w extends y{getHTML(){return`<svg>${super.getHTML()}</svg>`}getTemplateElement(){const e=super.getTemplateElement(),t=e.content,n=t.firstChild;return t.removeChild(n),((e,t,n=null,r=null)=>{for(;t!==n;){const n=t.nextSibling;e.insertBefore(t,r),t=n}})(t,n.firstChild),e}}const x=e=>null===e||!("object"==typeof e||"function"==typeof e),k=e=>Array.isArray(e)||!(!e||!e[Symbol.iterator]);class _{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let e=0;e<n.length-1;e++)this.parts[e]=this._createPart()}_createPart(){return new S(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let r=0;r<t;r++){n+=e[r];const t=this.parts[r];if(void 0!==t){const e=t.value;if(x(e)||!k(e))n+="string"==typeof e?e:String(e);else for(const t of e)n+="string"==typeof t?t:String(t)}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class S{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===a||x(e)&&e===this.value||(this.value=e,o(e)||(this.committer.dirty=!0))}commit(){for(;o(this.value);){const e=this.value;this.value=a,e(this)}this.value!==a&&this.committer.commit()}}class P{constructor(e){this.value=void 0,this.__pendingValue=void 0,this.options=e}appendInto(e){this.startNode=e.appendChild(m()),this.endNode=e.appendChild(m())}insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}appendIntoPart(e){e.__insert(this.startNode=m()),e.__insert(this.endNode=m())}insertAfterPart(e){e.__insert(this.startNode=m()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this.__pendingValue=e}commit(){for(;o(this.__pendingValue);){const e=this.__pendingValue;this.__pendingValue=a,e(this)}const e=this.__pendingValue;e!==a&&(x(e)?e!==this.value&&this.__commitText(e):e instanceof y?this.__commitTemplateResult(e):e instanceof Node?this.__commitNode(e):k(e)?this.__commitIterable(e):e===l?(this.value=l,this.clear()):this.__commitText(e))}__insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}__commitNode(e){this.value!==e&&(this.clear(),this.__insert(e),this.value=e)}__commitText(e){const t=this.startNode.nextSibling,n="string"==typeof(e=null==e?"":e)?e:String(e);t===this.endNode.previousSibling&&3===t.nodeType?t.data=n:this.__commitNode(document.createTextNode(n)),this.value=e}__commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof b&&this.value.template===t)this.value.update(e.values);else{const n=new b(t,e.processor,this.options),r=n._clone();n.update(e.values),this.__commitNode(r),this.value=n}}__commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());const t=this.value;let n,r=0;for(const o of e)n=t[r],void 0===n&&(n=new P(this.options),t.push(n),0===r?n.appendIntoPart(this):n.insertAfterPart(t[r-1])),n.setValue(o),n.commit(),r++;r<t.length&&(t.length=r,this.clear(n&&n.endNode))}clear(e=this.startNode){s(this.startNode.parentNode,e.nextSibling,this.endNode)}}class E{constructor(e,t,n){if(this.value=void 0,this.__pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this.__pendingValue=e}commit(){for(;o(this.__pendingValue);){const e=this.__pendingValue;this.__pendingValue=a,e(this)}if(this.__pendingValue===a)return;const e=!!this.__pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name),this.value=e),this.__pendingValue=a}}class C extends _{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new $(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class $ extends S{}let N=!1;try{const e={get capture(){return N=!0,!1}};window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class A{constructor(e,t,n){this.value=void 0,this.__pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n,this.__boundHandleEvent=e=>this.handleEvent(e)}setValue(e){this.__pendingValue=e}commit(){for(;o(this.__pendingValue);){const e=this.__pendingValue;this.__pendingValue=a,e(this)}if(this.__pendingValue===a)return;const e=this.__pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive),r=null!=e&&(null==t||n);n&&this.element.removeEventListener(this.eventName,this.__boundHandleEvent,this.__options),r&&(this.__options=T(e),this.element.addEventListener(this.eventName,this.__boundHandleEvent,this.__options)),this.value=e,this.__pendingValue=a}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}const T=e=>e&&(N?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);const M=new class{handleAttributeExpressions(e,t,n,r){const o=t[0];if("."===o){return new C(e,t.slice(1),n).parts}return"@"===o?[new A(e,t.slice(1),r.eventContext)]:"?"===o?[new E(e,t.slice(1),n)]:new _(e,t,n).parts}handleTextExpression(e){return new P(e)}};function j(e){let t=z.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},z.set(e.type,t));let n=t.stringsArray.get(e.strings);if(void 0!==n)return n;const r=e.strings.join(c);return n=t.keyString.get(r),void 0===n&&(n=new p(e,e.getTemplateElement()),t.keyString.set(r,n)),t.stringsArray.set(e.strings,n),n}const z=new Map,O=new WeakMap;(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.1.2");const F=(e,...t)=>new y(e,t,"html",M),I=(e,...t)=>new w(e,t,"svg",M);function R(e,t){const{element:{content:n},parts:r}=e,o=document.createTreeWalker(n,133,null,!1);let i=B(r),s=r[i],a=-1,l=0;const c=[];let d=null;for(;o.nextNode();){a++;const e=o.currentNode;for(e.previousSibling===d&&(d=null),t.has(e)&&(c.push(e),null===d&&(d=e)),null!==d&&l++;void 0!==s&&s.index===a;)s.index=null!==d?-1:s.index-l,i=B(r,i),s=r[i]}c.forEach(e=>e.parentNode.removeChild(e))}const V=e=>{let t=11===e.nodeType?0:1;const n=document.createTreeWalker(e,133,null,!1);for(;n.nextNode();)t++;return t},B=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(f(t))return n}return-1};const L=(e,t)=>`${e}--${t}`;let D=!0;void 0===window.ShadyCSS?D=!1:void 0===window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."),D=!1);const U=e=>t=>{const n=L(t.type,e);let r=z.get(n);void 0===r&&(r={stringsArray:new WeakMap,keyString:new Map},z.set(n,r));let o=r.stringsArray.get(t.strings);if(void 0!==o)return o;const i=t.strings.join(c);if(o=r.keyString.get(i),void 0===o){const n=t.getTemplateElement();D&&window.ShadyCSS.prepareTemplateDom(n,e),o=new p(t,n),r.keyString.set(i,o)}return r.stringsArray.set(t.strings,o),o},H=["html","svg"],q=new Set,W=(e,t,n)=>{q.add(e);const r=n?n.element:document.createElement("template"),o=t.querySelectorAll("style"),{length:i}=o;if(0===i)return void window.ShadyCSS.prepareTemplateStyles(r,e);const s=document.createElement("style");for(let e=0;e<i;e++){const t=o[e];t.parentNode.removeChild(t),s.textContent+=t.textContent}(e=>{H.forEach(t=>{const n=z.get(L(t,e));void 0!==n&&n.keyString.forEach(e=>{const{element:{content:t}}=e,n=new Set;Array.from(t.querySelectorAll("style")).forEach(e=>{n.add(e)}),R(e,n)})})})(e);const a=r.content;n?function(e,t,n=null){const{element:{content:r},parts:o}=e;if(null==n)return void r.appendChild(t);const i=document.createTreeWalker(r,133,null,!1);let s=B(o),a=0,l=-1;for(;i.nextNode();){for(l++,i.currentNode===n&&(a=V(t),n.parentNode.insertBefore(t,n));-1!==s&&o[s].index===l;){if(a>0){for(;-1!==s;)o[s].index+=a,s=B(o,s);return}s=B(o,s)}}}(n,s,a.firstChild):a.insertBefore(s,a.firstChild),window.ShadyCSS.prepareTemplateStyles(r,e);const l=a.querySelector("style");if(window.ShadyCSS.nativeShadow&&null!==l)t.insertBefore(l.cloneNode(!0),t.firstChild);else if(n){a.insertBefore(s,a.firstChild);const e=new Set;e.add(s),R(n,e)}};window.JSCompiler_renameProperty=(e,t)=>e;const Z={toAttribute(e,t){switch(t){case Boolean:return e?"":null;case Object:case Array:return null==e?e:JSON.stringify(e)}return e},fromAttribute(e,t){switch(t){case Boolean:return null!==e;case Number:return null===e?null:Number(e);case Object:case Array:return JSON.parse(e)}return e}},J=(e,t)=>t!==e&&(t==t||e==e),Y={attribute:!0,type:String,converter:Z,reflect:!1,hasChanged:J},K=Promise.resolve(!0);class G extends HTMLElement{constructor(){super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=K,this._hasConnectedResolver=void 0,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}static get observedAttributes(){this.finalize();const e=[];return this._classProperties.forEach((t,n)=>{const r=this._attributeNameForProperty(n,t);void 0!==r&&(this._attributeToPropertyMap.set(r,n),e.push(r))}),e}static _ensureClassProperties(){if(!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties",this))){this._classProperties=new Map;const e=Object.getPrototypeOf(this)._classProperties;void 0!==e&&e.forEach((e,t)=>this._classProperties.set(t,e))}}static createProperty(e,t=Y){if(this._ensureClassProperties(),this._classProperties.set(e,t),t.noAccessor||this.prototype.hasOwnProperty(e))return;const n="symbol"==typeof e?Symbol():`__${e}`;Object.defineProperty(this.prototype,e,{get(){return this[n]},set(t){const r=this[e];this[n]=t,this._requestUpdate(e,r)},configurable:!0,enumerable:!0})}static finalize(){const e=Object.getPrototypeOf(this);if(e.hasOwnProperty("finalized")||e.finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(JSCompiler_renameProperty("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),..."function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[]];for(const n of t)this.createProperty(n,e[n])}}static _attributeNameForProperty(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}static _valueHasChanged(e,t,n=J){return n(e,t)}static _propertyValueFromAttribute(e,t){const n=t.type,r=t.converter||Z,o="function"==typeof r?r:r.fromAttribute;return o?o(e,n):e}static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const n=t.type,r=t.converter;return(r&&r.toAttribute||Z.toAttribute)(e,n)}initialize(){this._saveInstanceProperties(),this._requestUpdate()}_saveInstanceProperties(){this.constructor._classProperties.forEach((e,t)=>{if(this.hasOwnProperty(t)){const e=this[t];delete this[t],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(t,e)}})}_applyInstanceProperties(){this._instanceProperties.forEach((e,t)=>this[t]=e),this._instanceProperties=void 0}connectedCallback(){this._updateState=32|this._updateState,this._hasConnectedResolver&&(this._hasConnectedResolver(),this._hasConnectedResolver=void 0)}disconnectedCallback(){}attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=Y){const r=this.constructor,o=r._attributeNameForProperty(e,n);if(void 0!==o){const e=r._propertyValueToAttribute(t,n);if(void 0===e)return;this._updateState=8|this._updateState,null==e?this.removeAttribute(o):this.setAttribute(o,e),this._updateState=-9&this._updateState}}_attributeToProperty(e,t){if(8&this._updateState)return;const n=this.constructor,r=n._attributeToPropertyMap.get(e);if(void 0!==r){const e=n._classProperties.get(r)||Y;this._updateState=16|this._updateState,this[r]=n._propertyValueFromAttribute(t,e),this._updateState=-17&this._updateState}}_requestUpdate(e,t){let n=!0;if(void 0!==e){const r=this.constructor,o=r._classProperties.get(e)||Y;r._valueHasChanged(this[e],t,o.hasChanged)?(this._changedProperties.has(e)||this._changedProperties.set(e,t),!0!==o.reflect||16&this._updateState||(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,o))):n=!1}!this._hasRequestedUpdate&&n&&this._enqueueUpdate()}requestUpdate(e,t){return this._requestUpdate(e,t),this.updateComplete}async _enqueueUpdate(){let e,t;this._updateState=4|this._updateState;const n=this._updatePromise;this._updatePromise=new Promise((n,r)=>{e=n,t=r});try{await n}catch(e){}this._hasConnected||await new Promise(e=>this._hasConnectedResolver=e);try{const e=this.performUpdate();null!=e&&await e}catch(e){t(e)}e(!this._hasRequestedUpdate)}get _hasConnected(){return 32&this._updateState}get _hasRequestedUpdate(){return 4&this._updateState}get hasUpdated(){return 1&this._updateState}performUpdate(){this._instanceProperties&&this._applyInstanceProperties();let e=!1;const t=this._changedProperties;try{e=this.shouldUpdate(t),e&&this.update(t)}catch(t){throw e=!1,t}finally{this._markUpdated()}e&&(1&this._updateState||(this._updateState=1|this._updateState,this.firstUpdated(t)),this.updated(t))}_markUpdated(){this._changedProperties=new Map,this._updateState=-5&this._updateState}get updateComplete(){return this._getUpdateComplete()}_getUpdateComplete(){return this._updatePromise}shouldUpdate(e){return!0}update(e){void 0!==this._reflectingProperties&&this._reflectingProperties.size>0&&(this._reflectingProperties.forEach((e,t)=>this._propertyToAttribute(t,this[t],e)),this._reflectingProperties=void 0)}updated(e){}firstUpdated(e){}}G.finalized=!0;const X=e=>t=>"function"==typeof t?((e,t)=>(window.customElements.define(e,t),t))(e,t):((e,t)=>{const{kind:n,elements:r}=t;return{kind:n,elements:r,finisher(t){window.customElements.define(e,t)}}})(e,t),Q=(e,t)=>"method"!==t.kind||!t.descriptor||"value"in t.descriptor?{kind:"field",key:Symbol(),placement:"own",descriptor:{},initializer(){"function"==typeof t.initializer&&(this[t.key]=t.initializer.call(this))},finisher(n){n.createProperty(t.key,e)}}:Object.assign({},t,{finisher(n){n.createProperty(t.key,e)}});function ee(e){return(t,n)=>void 0!==n?((e,t,n)=>{t.constructor.createProperty(n,e)})(e,t,n):Q(e,t)}const te="adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,ne=Symbol();class re{constructor(e,t){if(t!==ne)throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=e}get styleSheet(){return void 0===this._styleSheet&&(te?(this._styleSheet=new CSSStyleSheet,this._styleSheet.replaceSync(this.cssText)):this._styleSheet=null),this._styleSheet}toString(){return this.cssText}}const oe=e=>new re(String(e),ne);(window.litElementVersions||(window.litElementVersions=[])).push("2.2.1");const ie=e=>e.flat?e.flat(1/0):function e(t,n=[]){for(let r=0,o=t.length;r<o;r++){const o=t[r];Array.isArray(o)?e(o,n):n.push(o)}return n}(e);class se extends G{static finalize(){super.finalize.call(this),this._styles=this.hasOwnProperty(JSCompiler_renameProperty("styles",this))?this._getUniqueStyles():this._styles||[]}static _getUniqueStyles(){const e=this.styles,t=[];if(Array.isArray(e)){ie(e).reduceRight((e,t)=>(e.add(t),e),new Set).forEach(e=>t.unshift(e))}else e&&t.push(e);return t}initialize(){super.initialize(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}createRenderRoot(){return this.attachShadow({mode:"open"})}adoptStyles(){const e=this.constructor._styles;0!==e.length&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow?te?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName))}connectedCallback(){super.connectedCallback(),this.hasUpdated&&void 0!==window.ShadyCSS&&window.ShadyCSS.styleElement(this)}update(e){super.update(e);const t=this.render();t instanceof y&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._styles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}render(){}}se.finalized=!0,se.render=(e,t,n)=>{if(!n||"object"!=typeof n||!n.scopeName)throw new Error("The `scopeName` option is required.");const r=n.scopeName,o=O.has(t),i=D&&11===t.nodeType&&!!t.host,a=i&&!q.has(r),l=a?document.createDocumentFragment():t;if(((e,t,n)=>{let r=O.get(t);void 0===r&&(s(t,t.firstChild),O.set(t,r=new P(Object.assign({templateFactory:j},n))),r.appendInto(t)),r.setValue(e),r.commit()})(e,l,Object.assign({templateFactory:U(r)},n)),a){const e=O.get(l);O.delete(l);const n=e.value instanceof b?e.value.template:void 0;W(r,l,n),s(t,t.firstChild),t.appendChild(l),O.set(t,e)}!o&&i&&window.ShadyCSS.styleElement(t.host)};var ae=n(2);const le=n(5),ce=n(6),de=oe(le.toString()),ue=oe(ce.toString());var pe=function(e,t){return(pe=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function he(e,t){function n(){this.constructor=e}pe(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}function fe(e){return"function"==typeof e}var me=!1,ge={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){e&&(new Error).stack;me=e},get useDeprecatedSynchronousErrorHandling(){return me}};function be(e){setTimeout((function(){throw e}),0)}var ve={closed:!0,next:function(e){},error:function(e){if(ge.useDeprecatedSynchronousErrorHandling)throw e;be(e)},complete:function(){}},ye=function(){return Array.isArray||function(e){return e&&"number"==typeof e.length}}();function we(e){return null!==e&&"object"==typeof e}var xe=function(){function e(e){return Error.call(this),this.message=e?e.length+" errors occurred during unsubscription:\n"+e.map((function(e,t){return t+1+") "+e.toString()})).join("\n  "):"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e}(),ke=function(){function e(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._unsubscribe=e)}return e.prototype.unsubscribe=function(){var t;if(!this.closed){var n=this._parentOrParents,r=this._unsubscribe,o=this._subscriptions;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof e)n.remove(this);else if(null!==n)for(var i=0;i<n.length;++i){n[i].remove(this)}if(fe(r))try{r.call(this)}catch(e){t=e instanceof xe?_e(e.errors):[e]}if(ye(o)){i=-1;for(var s=o.length;++i<s;){var a=o[i];if(we(a))try{a.unsubscribe()}catch(e){t=t||[],e instanceof xe?t=t.concat(_e(e.errors)):t.push(e)}}}if(t)throw new xe(t)}},e.prototype.add=function(t){var n=t;if(!t)return e.EMPTY;switch(typeof t){case"function":n=new e(t);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof e)){var r=n;(n=new e)._subscriptions=[r]}break;default:throw new Error("unrecognized teardown "+t+" added to Subscription.")}var o=n._parentOrParents;if(null===o)n._parentOrParents=this;else if(o instanceof e){if(o===this)return n;n._parentOrParents=[o,this]}else{if(-1!==o.indexOf(this))return n;o.push(this)}var i=this._subscriptions;return null===i?this._subscriptions=[n]:i.push(n),n},e.prototype.remove=function(e){var t=this._subscriptions;if(t){var n=t.indexOf(e);-1!==n&&t.splice(n,1)}},e.EMPTY=function(e){return e.closed=!0,e}(new e),e}();function _e(e){return e.reduce((function(e,t){return e.concat(t instanceof xe?t.errors:t)}),[])}var Se=function(){return"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random()}(),Pe=function(e){function t(n,r,o){var i=e.call(this)||this;switch(i.syncErrorValue=null,i.syncErrorThrown=!1,i.syncErrorThrowable=!1,i.isStopped=!1,arguments.length){case 0:i.destination=ve;break;case 1:if(!n){i.destination=ve;break}if("object"==typeof n){n instanceof t?(i.syncErrorThrowable=n.syncErrorThrowable,i.destination=n,n.add(i)):(i.syncErrorThrowable=!0,i.destination=new Ee(i,n));break}default:i.syncErrorThrowable=!0,i.destination=new Ee(i,n,r,o)}return i}return he(t,e),t.prototype[Se]=function(){return this},t.create=function(e,n,r){var o=new t(e,n,r);return o.syncErrorThrowable=!1,o},t.prototype.next=function(e){this.isStopped||this._next(e)},t.prototype.error=function(e){this.isStopped||(this.isStopped=!0,this._error(e))},t.prototype.complete=function(){this.isStopped||(this.isStopped=!0,this._complete())},t.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,e.prototype.unsubscribe.call(this))},t.prototype._next=function(e){this.destination.next(e)},t.prototype._error=function(e){this.destination.error(e),this.unsubscribe()},t.prototype._complete=function(){this.destination.complete(),this.unsubscribe()},t.prototype._unsubscribeAndRecycle=function(){var e=this._parentOrParents;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this},t}(ke),Ee=function(e){function t(t,n,r,o){var i,s=e.call(this)||this;s._parentSubscriber=t;var a=s;return fe(n)?i=n:n&&(i=n.next,r=n.error,o=n.complete,n!==ve&&(fe((a=Object.create(n)).unsubscribe)&&s.add(a.unsubscribe.bind(a)),a.unsubscribe=s.unsubscribe.bind(s))),s._context=a,s._next=i,s._error=r,s._complete=o,s}return he(t,e),t.prototype.next=function(e){if(!this.isStopped&&this._next){var t=this._parentSubscriber;ge.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}},t.prototype.error=function(e){if(!this.isStopped){var t=this._parentSubscriber,n=ge.useDeprecatedSynchronousErrorHandling;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):be(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;be(e)}}},t.prototype.complete=function(){var e=this;if(!this.isStopped){var t=this._parentSubscriber;if(this._complete){var n=function(){return e._complete.call(e._context)};ge.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,n),this.unsubscribe()):(this.__tryOrUnsub(n),this.unsubscribe())}else this.unsubscribe()}},t.prototype.__tryOrUnsub=function(e,t){try{e.call(this._context,t)}catch(e){if(this.unsubscribe(),ge.useDeprecatedSynchronousErrorHandling)throw e;be(e)}},t.prototype.__tryOrSetError=function(e,t,n){if(!ge.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(t){return ge.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=t,e.syncErrorThrown=!0,!0):(be(t),!0)}return!1},t.prototype._unsubscribe=function(){var e=this._parentSubscriber;this._context=null,this._parentSubscriber=null,e.unsubscribe()},t}(Pe);var Ce=function(){return"function"==typeof Symbol&&Symbol.observable||"@@observable"}();function $e(){}function Ne(e){return e?1===e.length?e[0]:function(t){return e.reduce((function(e,t){return t(e)}),t)}:$e}var Ae=function(){function e(e){this._isScalar=!1,e&&(this._subscribe=e)}return e.prototype.lift=function(t){var n=new e;return n.source=this,n.operator=t,n},e.prototype.subscribe=function(e,t,n){var r=this.operator,o=function(e,t,n){if(e){if(e instanceof Pe)return e;if(e[Se])return e[Se]()}return e||t||n?new Pe(e,t,n):new Pe(ve)}(e,t,n);if(r?o.add(r.call(o,this.source)):o.add(this.source||ge.useDeprecatedSynchronousErrorHandling&&!o.syncErrorThrowable?this._subscribe(o):this._trySubscribe(o)),ge.useDeprecatedSynchronousErrorHandling&&o.syncErrorThrowable&&(o.syncErrorThrowable=!1,o.syncErrorThrown))throw o.syncErrorValue;return o},e.prototype._trySubscribe=function(e){try{return this._subscribe(e)}catch(t){ge.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),!function(e){for(;e;){var t=e,n=t.closed,r=t.destination,o=t.isStopped;if(n||o)return!1;e=r&&r instanceof Pe?r:null}return!0}(e)?console.warn(t):e.error(t)}},e.prototype.forEach=function(e,t){var n=this;return new(t=Te(t))((function(t,r){var o;o=n.subscribe((function(t){try{e(t)}catch(e){r(e),o&&o.unsubscribe()}}),r,t)}))},e.prototype._subscribe=function(e){var t=this.source;return t&&t.subscribe(e)},e.prototype[Ce]=function(){return this},e.prototype.pipe=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return 0===e.length?this:Ne(e)(this)},e.prototype.toPromise=function(e){var t=this;return new(e=Te(e))((function(e,n){var r;t.subscribe((function(e){return r=e}),(function(e){return n(e)}),(function(){return e(r)}))}))},e.create=function(t){return new e(t)},e}();function Te(e){if(e||(e=ge.Promise||Promise),!e)throw new Error("no Promise impl found");return e}function Me(e){return e&&"function"==typeof e.schedule}var je=function(e){function t(t,n,r){var o=e.call(this)||this;return o.parent=t,o.outerValue=n,o.outerIndex=r,o.index=0,o}return he(t,e),t.prototype._next=function(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)},t.prototype._error=function(e){this.parent.notifyError(e,this),this.unsubscribe()},t.prototype._complete=function(){this.parent.notifyComplete(this),this.unsubscribe()},t}(Pe),ze=function(e){return function(t){for(var n=0,r=e.length;n<r&&!t.closed;n++)t.next(e[n]);t.complete()}};function Oe(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}var Fe=Oe(),Ie=function(e){return e&&"number"==typeof e.length&&"function"!=typeof e};function Re(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}var Ve=function(e){if(e&&"function"==typeof e[Ce])return r=e,function(e){var t=r[Ce]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(Ie(e))return ze(e);if(Re(e))return n=e,function(e){return n.then((function(t){e.closed||(e.next(t),e.complete())}),(function(t){return e.error(t)})).then(null,be),e};if(e&&"function"==typeof e[Fe])return t=e,function(e){for(var n=t[Fe]();;){var r=n.next();if(r.done){e.complete();break}if(e.next(r.value),e.closed)break}return"function"==typeof n.return&&e.add((function(){n.return&&n.return()})),e};var t,n,r,o=we(e)?"an invalid object":"'"+e+"'";throw new TypeError("You provided "+o+" where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.")};var Be=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return he(t,e),t.prototype.notifyNext=function(e,t,n,r,o){this.destination.next(t)},t.prototype.notifyError=function(e,t){this.destination.error(e)},t.prototype.notifyComplete=function(e){this.destination.complete()},t}(Pe);function Le(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new De(e,t))}}var De=function(){function e(e,t){this.project=e,this.thisArg=t}return e.prototype.call=function(e,t){return t.subscribe(new Ue(e,this.project,this.thisArg))},e}(),Ue=function(e){function t(t,n,r){var o=e.call(this,t)||this;return o.project=n,o.count=0,o.thisArg=r||o,o}return he(t,e),t.prototype._next=function(e){var t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(e){return void this.destination.error(e)}this.destination.next(t)},t}(Pe);function He(e,t){return new Ae((function(n){var r=new ke,o=0;return r.add(t.schedule((function(){o!==e.length?(n.next(e[o++]),n.closed||r.add(this.schedule())):n.complete()}))),r}))}function qe(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[Ce]}(e))return function(e,t){return new Ae((function(n){var r=new ke;return r.add(t.schedule((function(){var o=e[Ce]();r.add(o.subscribe({next:function(e){r.add(t.schedule((function(){return n.next(e)})))},error:function(e){r.add(t.schedule((function(){return n.error(e)})))},complete:function(){r.add(t.schedule((function(){return n.complete()})))}}))}))),r}))}(e,t);if(Re(e))return function(e,t){return new Ae((function(n){var r=new ke;return r.add(t.schedule((function(){return e.then((function(e){r.add(t.schedule((function(){n.next(e),r.add(t.schedule((function(){return n.complete()})))})))}),(function(e){r.add(t.schedule((function(){return n.error(e)})))}))}))),r}))}(e,t);if(Ie(e))return He(e,t);if(function(e){return e&&"function"==typeof e[Fe]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new Ae((function(n){var r,o=new ke;return o.add((function(){r&&"function"==typeof r.return&&r.return()})),o.add(t.schedule((function(){r=e[Fe](),o.add(t.schedule((function(){if(!n.closed){var e,t;try{var o=r.next();e=o.value,t=o.done}catch(e){return void n.error(e)}t?n.complete():(n.next(e),this.schedule())}})))}))),o}))}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}function We(e,t,n){return void 0===n&&(n=Number.POSITIVE_INFINITY),"function"==typeof t?function(r){return r.pipe(We((function(n,r){return(o=e(n,r),i?qe(o,i):o instanceof Ae?o:new Ae(Ve(o))).pipe(Le((function(e,o){return t(n,e,r,o)})));var o,i}),n))}:("number"==typeof t&&(n=t),function(t){return t.lift(new Ze(e,n))})}var Ze=function(){function e(e,t){void 0===t&&(t=Number.POSITIVE_INFINITY),this.project=e,this.concurrent=t}return e.prototype.call=function(e,t){return t.subscribe(new Je(e,this.project,this.concurrent))},e}(),Je=function(e){function t(t,n,r){void 0===r&&(r=Number.POSITIVE_INFINITY);var o=e.call(this,t)||this;return o.project=n,o.concurrent=r,o.hasCompleted=!1,o.buffer=[],o.active=0,o.index=0,o}return he(t,e),t.prototype._next=function(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)},t.prototype._tryNext=function(e){var t,n=this.index++;try{t=this.project(e,n)}catch(e){return void this.destination.error(e)}this.active++,this._innerSub(t,e,n)},t.prototype._innerSub=function(e,t,n){var r=new je(this,t,n),o=this.destination;o.add(r);var i=function(e,t,n,r,o){if(void 0===o&&(o=new je(e,n,r)),!o.closed)return t instanceof Ae?t.subscribe(o):Ve(t)(o)}(this,e,void 0,void 0,r);i!==r&&o.add(i)},t.prototype._complete=function(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()},t.prototype.notifyNext=function(e,t,n,r,o){this.destination.next(t)},t.prototype.notifyComplete=function(e){var t=this.buffer;this.remove(e),this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()},t}(Be);function Ye(e){return e}function Ke(e){return void 0===e&&(e=Number.POSITIVE_INFINITY),We(Ye,e)}function Ge(e,t){return t?He(e,t):new Ae(ze(e))}var Xe=function(){function e(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}return e.prototype.call=function(e,t){return t.subscribe(new Qe(e,this.nextOrObserver,this.error,this.complete))},e}(),Qe=function(e){function t(t,n,r,o){var i=e.call(this,t)||this;return i._tapNext=$e,i._tapError=$e,i._tapComplete=$e,i._tapError=r||$e,i._tapComplete=o||$e,fe(n)?(i._context=i,i._tapNext=n):n&&(i._context=n,i._tapNext=n.next||$e,i._tapError=n.error||$e,i._tapComplete=n.complete||$e),i}return he(t,e),t.prototype._next=function(e){try{this._tapNext.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.next(e)},t.prototype._error=function(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)},t.prototype._complete=function(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()},t}(Pe);const et=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var n=Number.POSITIVE_INFINITY,r=null,o=e[e.length-1];return Me(o)?(r=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(n=e.pop())):"number"==typeof o&&(n=e.pop()),null===r&&1===e.length&&e[0]instanceof Ae?e[0]:Ke(n)(Ge(e,r))}(function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var n=e[e.length-1];return Me(n)?(e.pop(),He(e,n)):Ge(e)}(1),function e(t,n,r,o){return fe(r)&&(o=r,r=void 0),o?e(t,n,r).pipe(Le((function(e){return ye(e)?o.apply(void 0,e):o(e)}))):new Ae((function(e){!function e(t,n,r,o,i){var s;if(function(e){return e&&"function"==typeof e.addEventListener&&"function"==typeof e.removeEventListener}(t)){var a=t;t.addEventListener(n,r,i),s=function(){return a.removeEventListener(n,r,i)}}else if(function(e){return e&&"function"==typeof e.on&&"function"==typeof e.off}(t)){var l=t;t.on(n,r),s=function(){return l.off(n,r)}}else if(function(e){return e&&"function"==typeof e.addListener&&"function"==typeof e.removeListener}(t)){var c=t;t.addListener(n,r),s=function(){return c.removeListener(n,r)}}else{if(!t||!t.length)throw new TypeError("Invalid event target");for(var d=0,u=t.length;d<u;d++)e(t[d],n,r,o,i)}o.add(s)}(t,n,(function(t){arguments.length>1?e.next(Array.prototype.slice.call(arguments)):e.next(t)}),e,r)}))}(window,"hashchange").pipe((tt=e=>e.preventDefault(),function(e){return e.lift(new Xe(tt,nt,rt))}))).pipe(Le(()=>window.location.hash.substr(1).split("/").filter(Boolean).map(decodeURIComponent)));var tt,nt,rt,ot=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s},it=function(e,t,n,r){return new(n||(n=Promise))((function(o,i){function s(e){try{l(r.next(e))}catch(e){i(e)}}function a(e){try{l(r.throw(e))}catch(e){i(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((r=r.apply(e,t||[])).next())}))};let st=class extends se{constructor(){super(...arguments),this.path=[],this.subscriptions=[]}get title(){return this.context?this.titlePostfix?`${this.context.name} - ${this.titlePostfix}`:this.context.name:""}loadData(){return it(this,void 0,void 0,(function*(){if(this.src)try{const e=yield fetch(this.src);this.report=yield e.json()}catch(e){const t=e.toString();this.errorMessage=t}}))}updated(e){(e.has("path")||e.has("report"))&&this.report&&(this.updateModel(this.report),this.updateContext(),this.updateTitle()),e.has("src")&&this.loadData()}updateModel(e){this.rootModel=Object(ae.calculateMetrics)(e.files)}updateContext(){this.rootModel&&(this.context=this.path.reduce((e,t)=>e&&e.childResults.find(e=>e.name===t),this.rootModel))}updateTitle(){document.title=this.title}connectedCallback(){super.connectedCallback(),this.subscriptions.push(et.subscribe(e=>this.path=e))}disconnectedCallback(){super.disconnectedCallback(),this.subscriptions.forEach(e=>e.unsubscribe())}renderTitle(){const e=()=>this.titlePostfix?F` <small class="text-muted"> - ${this.titlePostfix}</small> `:void 0;if(this.context&&this.titlePostfix)return F` <h1 class="display-4">${this.context.name}${e()}</h1> `}render(){return this.context||this.errorMessage?F`
        <div class="container-fluid">
          <div class="row">
            <div class="col-md-12">
              ${this.renderReport()} ${this.renderErrorMessage()}
            </div>
          </div>
        </div>
      `:F``}renderErrorMessage(){return this.errorMessage?F`
        <div class="alert alert-danger" role="alert">
          ${this.errorMessage}
        </div>
      `:F``}renderReport(){return this.context?F`
        ${this.renderTitle()}
        <mutation-test-report-breadcrumb .path="${this.path}"></mutation-test-report-breadcrumb>
        ${this.renderTotals()} ${this.renderFileReport()}
      `:void 0}renderFileReport(){return this.context&&this.report&&this.context.file?F` <mutation-test-report-file .model="${this.context.file}"></mutation-test-report-file> `:void 0}renderTotals(){return this.report&&this.context?F`
        <div class="row">
          <div class="totals col-sm-11">
            <mutation-test-report-totals .currentPath="${this.path}" .thresholds="${this.report.thresholds}" .model="${this.context}">
            </mutation-test-report-totals>
          </div>
        </div>
      `:void 0}};st.styles=[de,oe(n(9))],ot([ee({attribute:!1})],st.prototype,"report",void 0),ot([ee({attribute:!1})],st.prototype,"rootModel",void 0),ot([ee()],st.prototype,"src",void 0),ot([ee({attribute:!1})],st.prototype,"errorMessage",void 0),ot([ee({attribute:!1})],st.prototype,"context",void 0),ot([ee()],st.prototype,"path",void 0),ot([ee({attribute:"title-postfix"})],st.prototype,"titlePostfix",void 0),ot([ee()],st.prototype,"title",null),st=ot([X("mutation-test-report-app")],st);var at=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};let lt=class extends se{constructor(){super(...arguments),this.show=!1}firstUpdated(){if(this.getBoundingClientRect().left<100){this.shadowRoot.querySelector(".popover").style.marginLeft="0px"}}getBackgroundClasses(){return this.context?`bg-${this.context} text-white`:""}render(){return F`<div class="popover popover-${this.context} ${this.show?"show":"hide"}">
        <h3 class="popover-header ${this.getBackgroundClasses()}">${this.header}</h3>
        <div class="popover-body">
          <slot name="popover-body"></slot>
        </div> </div
      >${F`<slot></slot>`}`}};lt.styles=[de,oe(n(10))],at([ee()],lt.prototype,"header",void 0),at([ee({converter:e=>"string"==typeof e})],lt.prototype,"show",void 0),at([ee()],lt.prototype,"context",void 0),lt=at([X("mutation-test-report-popup")],lt);const ct=new WeakMap,dt=(ut=e=>t=>{if(!(t instanceof P))throw new Error("unsafeHTML can only be used in text bindings");const n=ct.get(t);if(void 0!==n&&x(e)&&e===n.value&&t.value===n.fragment)return;const r=document.createElement("template");r.innerHTML=e;const o=document.importNode(r.content,!0);t.setValue(o),ct.set(t,{value:e,fragment:o})},(...e)=>{const t=ut(...e);return r.set(t,!0),t});var ut;function pt(e){switch(e){case"Killed":return"success";case"NoCoverage":return"caution";case"Survived":return"danger";case"Timeout":return"warning";case"Ignored":case"RuntimeError":case"CompileError":return"secondary"}}function ht(e){switch(e){case"Killed":return"✅";case"NoCoverage":return"🙈";case"Ignored":return"🤥";case"Survived":return"👽";case"Timeout":return"⌛";case"RuntimeError":case"CompileError":return"💥"}}function ft(e){const t=new URL(window.location.href);return new URL(`#${e}`,t).href}var mt=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};let gt=class extends se{constructor(){super(...arguments),this.show=!0,this.expand=!1,this.showPopup=!1,this.mutantClicked=e=>{this.expand=!this.expand,this.showPopup=this.expand,e.stopImmediatePropagation(),this.dispatchEvent(new CustomEvent("mutant-selected",{bubbles:!0,detail:this,composed:!0}))},this.showMoreInfo=e=>{this.dispatchEvent(new CustomEvent(bt,{bubbles:!0,detail:e,composed:!0}))}}render(){return F`${this.renderButton()}${this.renderCode()}`}renderButton(){if(this.show&&this.mutant)return F`<mutation-test-report-popup
        ?show="${this.showPopup}"
        context="${pt(this.mutant.status)}"
        header="${this.mutant.mutatorName}"
        >${this.renderPopupBody(this.mutant)}<span
          class="mutant-toggle badge badge-${this.expand?"info":pt(this.mutant.status)}"
          @click="${this.mutantClicked}"
          title="${this.mutant.mutatorName}"
          >${this.mutant.id}</span
        ></mutation-test-report-popup
      >`}renderPopupBody(e){return F`<div slot="popover-body">
      <span class="btn">${ht(e.status)} ${e.status}</span>${this.renderDescription(e)}
    </div>`}renderDescription(e){if(e.description)return F` <button class="show-more btn btn-link" @click="${()=>this.showMoreInfo(e)}">📖 Show more</button> `}renderCode(){return F`${this.renderReplacement()}${this.renderActual()}`}renderActual(){const e=F`<slot></slot>`;return F`<span class="original-code ${this.expand&&this.show?"disabled-code":""}">${e}</span>`}renderReplacement(){if(this.mutant)return F`<span class="replacement badge badge-info" @click="${this.mutantClicked}" ?hidden="${!this.expand||!this.show}"
        >${this.mutant.replacement||this.mutant.mutatorName}</span
      >`}};gt.styles=[de,oe(n(11))],mt([ee()],gt.prototype,"mutant",void 0),mt([ee()],gt.prototype,"show",void 0),mt([ee()],gt.prototype,"expand",void 0),mt([ee()],gt.prototype,"showPopup",void 0),gt=mt([X("mutation-test-report-mutant")],gt);const bt="show-more-click";class vt{constructor(){this.killed=0,this.noCoverage=0,this.survived=0,this.timeout=0,this.ignored=0,this.markMutantStart=e=>{this.countMutant(1,e.status)},this.markMutantEnd=e=>{this.countMutant(-1,e.status)},this.determineBackground=()=>this.survived>0?pt("Survived")+"-light":this.noCoverage>0?pt("NoCoverage")+"-light":this.timeout>0?pt("Timeout")+"-light":this.killed>0?pt("Killed")+"-light":this.ignored>0?pt("Ignored")+"-light":null}countMutant(e,t){switch(t){case"Killed":this.killed+=e;break;case"Survived":this.survived+=e;break;case"Timeout":this.timeout+=e;break;case"NoCoverage":this.noCoverage+=e;break;case"Ignored":this.ignored+=e}}}function yt(...e){return e.reduce((e,t)=>e.length?t?`${e}/${t}`:e:t,"")}function wt(e){const t=new vt,n=[];return`<span>${function(e,t){let n=1,r=1;const o=[];for(const i of e)1===n&&"\r"===i||("\n"!==i?o.push(t(i,{line:r,column:n++})):(r++,n=1,o.push("\n")));return o.join("")}(e.source,(r,o)=>{const i=e.mutants.filter(e=>{return t=e.location.start,n=o,t.line===n.line&&t.column===n.column;var t,n}),s=n.filter(e=>{return t=o,n=e.location.end,t.line>n.line||t.line===n.line&&t.column>=n.column;var t,n});s.forEach(e=>n.splice(n.indexOf(e),1)),n.push(...i);const a=[];return(i.length||s.length)&&(i.forEach(t.markMutantStart),s.forEach(t.markMutantEnd),a.push("</span>"),s.forEach(()=>a.push("</mutation-test-report-mutant>")),i.forEach(e=>a.push(`<mutation-test-report-mutant mutant-id="${e.id}">`)),a.push(`<span class="bg-${t.determineBackground()}">`)),a.push(r.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;")),a.join("")})}</span>`}var xt=n(3),kt=(n(13),n(14),n(15),n(16),n(17),n(18),n(19),n(20),n(21),n(22),n(23),function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s});let _t=class extends se{constructor(){super(...arguments),this.expandAll=()=>{this.forEachMutantComponent(e=>e.expand=!0)},this.collapseAll=()=>{this.forEachMutantComponent(e=>e.expand=!1)},this.filtersChanged=e=>{const t=e.detail.filter(e=>e.enabled).map(e=>e.status);this.forEachMutantComponent(e=>{e.show=t.some(t=>void 0!==e.mutant&&e.mutant.status===t)})}}forEachMutantComponent(e,t=this.root){for(const n of t.querySelectorAll("mutation-test-report-mutant"))n instanceof gt&&e(n)}connectedCallback(){super.connectedCallback(),this.addEventListener("click",()=>{this.forEachMutantComponent(e=>e.showPopup=!1)}),this.addEventListener("mutant-selected",e=>{const t=e.detail;this.forEachMutantComponent(e=>e!==t&&(e.showPopup=!1))}),this.addEventListener(bt,e=>{const t=e.detail;this.mutantInDialog=t,e.stopPropagation()}),this.addEventListener("close-dialog",()=>{this.mutantInDialog=void 0})}render(){if(this.model)return F`
        <div class="row">
          <div class="col-md-12">
            ${this.renderModalDialog()}
            <mutation-test-report-file-legend
              @filters-changed="${this.filtersChanged}"
              @expand-all="${this.expandAll}"
              @collapse-all="${this.collapseAll}"
              .mutants="${this.model.mutants}"
            ></mutation-test-report-file-legend>
            <pre id="report-code-block" class="line-numbers"><code class="language-${this.model.language}">${dt(wt(this.model))}</code></pre>
          </div>
        </div>
      `}renderModalDialog(){return this.mutantInDialog?F`
        <div .hidden="${!this.mutantInDialog}" class="modal-backdrop show"></div>
        <mutation-test-report-modal-dialog
          ?show="${this.mutantInDialog}"
          header="${this.mutantInDialog.id}: ${this.mutantInDialog.mutatorName} - ${ht(this.mutantInDialog.status)} ${this.mutantInDialog.status}"
        >
          <p>${this.mutantInDialog.description}</p>
        </mutation-test-report-modal-dialog>
      `:void 0}firstUpdated(){const e=this.root.querySelector("code");e&&(Object(xt.highlightElement)(e),this.forEachMutantComponent(e=>{e.mutant=this.model.mutants.find(t=>t.id.toString()===e.getAttribute("mutant-id"))},e))}get root(){return this.shadowRoot||this}};_t.styles=[ue,de,oe(n(24))],kt([ee()],_t.prototype,"model",void 0),kt([ee({attribute:!1})],_t.prototype,"mutantInDialog",void 0),_t=kt([X("mutation-test-report-file")],_t);class St{constructor(){this.file=I`<svg aria-label="file" class="octicon octicon-file" viewBox="0 0 12 16" version="1.1" width="12" height="16" role="img"><path fill-rule="evenodd" d="M6 5H2V4h4v1zM2 8h7V7H2v1zm0 2h7V9H2v1zm0 2h7v-1H2v1zm10-7.5V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h7.5L12 4.5zM11 5L8 2H1v12h10V5z"></path></svg>`,this.directory=I`<svg aria-label="directory" class="octicon octicon-file-directory" viewBox="0 0 14 16" version="1.1" width="14" height="16" role="img"><path fill-rule="evenodd" d="M13 4H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM6 4H1V3h5v1z"></path></svg>`,this.csharp=I`<svg aria-label="cs" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><g fill="#498ba7"><path d="M7.1 15.9c0-1.3.2-2.4.6-3.4.4-1 .9-1.8 1.6-2.5.7-.7 1.5-1.2 2.4-1.6s1.9-.5 2.9-.5 1.9.2 2.7.6c.8.4 1.5.9 2 1.4l-2.2 2.5c-.4-.3-.7-.6-1.1-.7-.4-.1-.8-.3-1.4-.3-.5 0-.9.1-1.3.3-.4.2-.8.5-1.1.9s-.5.8-.7 1.4c-.2.6-.3 1.2-.3 1.9 0 1.5.3 2.6 1 3.3.7.8 1.5 1.2 2.6 1.2.5 0 1-.1 1.4-.3.4-.2.8-.5 1.1-.9l2.2 2.5c-.7.8-1.4 1.3-2.2 1.7-.8.4-1.7.6-2.7.6s-2-.2-2.9-.5-1.7-.8-2.4-1.5-1.1-1.7-1.5-2.7c-.5-.9-.7-2.1-.7-3.4z"/><path d="M21.8 17.1h-1l-.4 2.4h-1.2l.4-2.4h-1.2V16h1.5l.2-1.6h-1.3v-1.1h1.5l.4-2.4h1.2l-.4 2.4h1l.4-2.4h1.2l-.4 2.4H25v1.1h-1.6l-.2 1.6h1.3v1.1h-1.6l-.4 2.4h-1.2c0 .1.5-2.4.5-2.4zm-.8-1h1l.2-1.6h-1l-.2 1.6z"/></g></svg>`,this.html=I`<svg aria-label="html" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path fill="#cc6d2e" d="M8 15l6-5.6V12l-4.5 4 4.5 4v2.6L8 17v-2zm16 2.1l-6 5.6V20l4.6-4-4.6-4V9.3l6 5.6v2.2z"/></svg>`,this.java=I`<svg aria-label="java" xmlns="http://www.w3.org/2000/svg" viewBox="-4 -4 20 20"><path class="cls-1" d="M6 0a6 6 0 1 0 6 6 6 6 0 0 0-6-6zm2.14 6.8a2.16 2.16 0 0 1-2.29 2.41 2.5 2.5 0 0 1-2-.87l.73-.92a1.52 1.52 0 0 0 1.23.59c.66 0 1.06-.42 1.06-1.32V2.8h1.26z" fill="#b8383d"/></svg>`,this.javascript=I`<svg aria-label="js" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path fill="#b7b73b" d="M11.4 10h2.7v7.6c0 3.4-1.6 4.6-4.3 4.6-.6 0-1.5-.1-2-.3l.3-2.2c.4.2.9.3 1.4.3 1.1 0 1.9-.5 1.9-2.4V10zm5.1 9.2c.7.4 1.9.8 3 .8 1.3 0 1.9-.5 1.9-1.3s-.6-1.2-2-1.7c-2-.7-3.3-1.8-3.3-3.6 0-2.1 1.7-3.6 4.6-3.6 1.4 0 2.4.3 3.1.6l-.6 2.2c-.5-.2-1.3-.6-2.5-.6s-1.8.5-1.8 1.2c0 .8.7 1.1 2.2 1.7 2.1.8 3.1 1.9 3.1 3.6 0 2-1.6 3.7-4.9 3.7-1.4 0-2.7-.4-3.4-.7l.6-2.3z"/></svg>`,this.scala=I`<svg aria-label="scala" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M21.6 7v4.2c-.1.1-.1.2-.2.2-.3.3-.7.5-1.1.6-.9.3-1.9.5-2.8.7-1.6.3-3.1.5-4.7.7-.8.1-1.6.2-2.4.4V9.6c.1-.1.2-.1.4-.1 1.2-.2 2.5-.4 3.8-.5 1.9-.3 3.8-.5 5.6-1.1.5-.2 1.1-.4 1.4-.9zm0 5.6v4.2l-.2.2c-.5.4-1.1.6-1.6.8-.8.2-1.6.4-2.4.5-1 .2-1.9.3-2.9.5-1.4.2-2.7.3-4.1.6v-4.2c.1-.1.2-.1.3-.1 1.7-.2 3.4-.5 5.1-.7 1.4-.2 2.9-.5 4.3-.9.6-.2 1.1-.4 1.5-.9zM10.5 25h-.1v-4.2c.1-.1.2-.1.3-.1 1.2-.2 2.3-.3 3.5-.5 2-.3 3.9-.5 5.8-1.1.6-.2 1.2-.4 1.6-.9v4.2c-.1.2-.3.3-.5.5-.6.3-1.2.5-1.9.7-1.2.3-2.5.5-3.7.7-1.3.2-2.6.4-3.9.5-.4 0-.7.1-1.1.2z" fill="#b8383d"/></svg>`,this.typescript=I`<svg aria-label="ts" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M15.6 11.8h-3.4V22H9.7V11.8H6.3V10h9.2v1.8zm7.7 7.1c0-.5-.2-.8-.5-1.1-.3-.3-.9-.5-1.7-.8-1.4-.4-2.5-.9-3.3-1.5-.7-.6-1.1-1.3-1.1-2.3 0-1 .4-1.8 1.3-2.4.8-.6 1.9-.9 3.2-.9 1.3 0 2.4.4 3.2 1.1.8.7 1.2 1.6 1.2 2.6h-2.3c0-.6-.2-1-.6-1.4-.4-.3-.9-.5-1.6-.5-.6 0-1.1.1-1.5.4-.4.3-.5.7-.5 1.1 0 .4.2.7.6 1 .4.3 1 .5 2 .8 1.3.4 2.3.9 3 1.5.7.6 1 1.4 1 2.4s-.4 1.9-1.2 2.4c-.8.6-1.9.9-3.2.9-1.3 0-2.5-.3-3.4-1s-1.5-1.6-1.4-2.9h2.4c0 .7.2 1.2.7 1.6.4.3 1.1.5 1.8.5s1.2-.1 1.5-.4c.2-.3.4-.7.4-1.1z" fill="#498ba7"/></svg>`,this.svgMapping=new Map,this.svgMapping.set("cs",this.csharp),this.svgMapping.set("html",this.html),this.svgMapping.set("java",this.java),this.svgMapping.set("js",this.javascript),this.svgMapping.set("scala",this.scala),this.svgMapping.set("ts",this.typescript)}getIconForFile(e){const t=this.getFileExtension(e),n=this.svgMapping.get(t);return void 0!==n?n:this.file}getIconForFolder(){return this.directory}getFileExtension(e){const t=e.split(".");return t[t.length-1]}}var Pt=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};let Et=class extends se{constructor(){super(...arguments),this.currentPath=[],this.svgService=new St}render(){return this.model?F`
        <table class="table table-sm table-hover table-bordered table-no-top">
          ${this.renderHead()} ${this.renderTableBody(this.model)}
        </table>
      `:void 0}renderHead(){return F`<thead>
      <tr>
        <th colspan="2" style="width: 217px">
          <div><span>File / Directory</span></div>
        </th>
        <th colspan="2">
          <div><span>Mutation score</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># Killed</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># Survived</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># Timeout</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># No coverage</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># Ignored</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># Runtime errors</span></div>
        </th>
        <th class="rotate text-center" style="width: 50px">
          <div><span># Compile errors</span></div>
        </th>
        <th class="rotate rotate-width-70 text-center" style="width: 70px">
          <div><span>Total detected</span></div>
        </th>
        <th class="rotate rotate-width-70 text-center" style="width: 70px">
          <div><span>Total undetected</span></div>
        </th>
        <th class="rotate rotate-width-70 text-center" style="width: 70px">
          <div><span>Total mutants</span></div>
        </th>
      </tr>
    </thead>`}renderTableBody(e){return F`
      <tbody>
        ${this.renderRow(e.name,e,void 0)} ${(()=>e.file?void 0:e.childResults.map(e=>{let t=e.name;for(;!e.file&&1===e.childResults.length;)t=yt(t,(e=e.childResults[0]).name);return this.renderRow(t,e,yt(...this.currentPath,t))}))()}
      </tbody>
    `}renderRow(e,t,n){const{mutationScore:r}=t.metrics,o=!isNaN(r),i=this.determineColoringClass(r),s=r.toFixed(2),a=`width: ${r}%`;return F` <tr title="${t.name}">
      <td style="width: 32px;" class="icon no-border-right"
        >${t.file?this.svgService.getIconForFile(t.name):this.svgService.getIconForFolder()}</td
      >
      <td width="" class="no-border-left"
        >${"string"==typeof n?F`<a href="${ft(n)}">${e}</a>`:F`<span>${t.name}</span>`}</td
      >
      <td class="no-border-right vertical-middle">
        ${o?F` <div class="progress">
              <div
                class="progress-bar bg-${i}"
                role="progressbar"
                aria-valuenow="${s}"
                aria-valuemin="0"
                aria-valuemax="100"
                style="${a}"
              >
                ${s}%
              </div>
            </div>`:F` <span class="font-weight-bold text-muted">N/A</span> `}
      </td>
      <td style="width: 50px;" class="no-border-left font-weight-bold text-center text-${i}">
        ${o?s:void 0}
      </td>
      <td class="text-center">${t.metrics.killed}</td>
      <td class="text-center">${t.metrics.survived}</td>
      <td class="text-center">${t.metrics.timeout}</td>
      <td class="text-center">${t.metrics.noCoverage}</td>
      <td class="text-center">${t.metrics.ignored}</td>
      <td class="text-center">${t.metrics.runtimeErrors}</td>
      <td class="text-center">${t.metrics.compileErrors}</td>
      <th class="text-center">${t.metrics.totalDetected}</th>
      <th class="text-center">${t.metrics.totalUndetected}</th>
      <th class="text-center">${t.metrics.totalMutants}</th>
    </tr>`}determineColoringClass(e){return!isNaN(e)&&this.thresholds?e<this.thresholds.low?"danger":e<this.thresholds.high?"warning":"success":"default"}};Et.styles=[de,oe(n(25))],Pt([ee()],Et.prototype,"model",void 0),Pt([ee()],Et.prototype,"thresholds",void 0),Pt([ee()],Et.prototype,"currentPath",void 0),Et=Pt([X("mutation-test-report-totals")],Et);var Ct=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};let $t=class extends se{render(){return F`
      <ol class="breadcrumb">
        ${this.renderRootItem()} ${this.renderBreadcrumbItems()}
      </ol>
    `}renderRootItem(){return this.path&&this.path.length?this.renderLink("All files",""):this.renderActiveItem("All files")}renderBreadcrumbItems(){if(this.path){const e=this.path;return e.map((t,n)=>n===e.length-1?this.renderActiveItem(t):this.renderLink(t,`${e.filter((e,t)=>t<=n).join("/")}`))}}renderActiveItem(e){return F` <li class="breadcrumb-item active" aria-current="page">${e}</li> `}renderLink(e,t){return F` <li class="breadcrumb-item"><a href="${ft(t)}">${e}</a></li> `}};$t.styles=[de],Ct([ee()],$t.prototype,"path",void 0),$t=Ct([X("mutation-test-report-breadcrumb")],$t);var Nt=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};let At=class extends se{constructor(){super(...arguments),this.show=!1,this.emitCloseEvent=e=>{this.dispatchEvent(new CustomEvent("close-dialog",{bubbles:!0,detail:this,composed:!0})),e.stopPropagation()}}render(){return F`
      <div .hidden="${!this.show}" class="modal show" style="display: block;" tabindex="-1" role="dialog" @click="${this.emitCloseEvent}">
        <div class="modal-dialog" role="document" @click="${e=>e.stopPropagation()}">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">${this.header}</h5>
            </div>
            <div class="modal-body">
              <slot></slot>
            </div>
            <div class="modal-footer">
              <button type="button" @click="${this.emitCloseEvent}" class="btn btn-link">Close</button>
            </div>
          </div>
        </div>
      </div>
      <slot></slot>
    `}};At.styles=[de,oe(n(26))],Nt([ee({converter:e=>"string"==typeof e})],At.prototype,"show",void 0),Nt([ee()],At.prototype,"header",void 0),At=Nt([X("mutation-test-report-modal-dialog")],At);var Tt=function(e,t,n,r){var o,i=arguments.length,s=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(i<3?o(s):i>3?o(t,n,s):o(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};let Mt=class extends se{constructor(){super(...arguments),this.mutants=[],this.collapsed=!0,this.filters=[],this.toggleOpenAll=()=>{this.collapsed=!this.collapsed,this.collapsed?this.dispatchEvent(new CustomEvent("collapse-all")):this.dispatchEvent(new CustomEvent("expand-all"))}}get collapseButtonText(){return this.collapsed?"Expand all":"Collapse all"}updated(e){e.has("mutants")&&this.updateModel()}updateModel(){this.filters=["Killed","Survived","NoCoverage","Ignored","Timeout","CompileError","RuntimeError"].filter(e=>this.mutants.some(t=>t.status===e)).map(e=>({enabled:["Survived","NoCoverage","Timeout"].some(t=>t===e),numberOfMutants:this.mutants.filter(t=>t.status===e).length,status:e})),this.dispatchFiltersChangedEvent()}checkboxClicked(e){e.enabled=!e.enabled,this.dispatchFiltersChangedEvent()}dispatchFiltersChangedEvent(){this.dispatchEvent(new CustomEvent("filters-changed",{detail:this.filters}))}render(){return F`
      <div class="row legend col-md-12">
        ${this.filters.map(e=>F`
            <div data-status="${e.status}" class="form-check form-check-inline">
              <label class="form-check-label">
                <input
                  class="form-check-input"
                  type="checkbox"
                  ?checked="${e.enabled}"
                  value="${e.status}"
                  @input="${()=>this.checkboxClicked(e)}"
                />
                <span class="badge badge-${pt(e.status)}"
                  >${ht(e.status)} ${e.status} (${e.numberOfMutants})</span
                >
              </label>
            </div>
          `)}
        <button @click="${this.toggleOpenAll}" class="btn btn-sm btn-secondary" type="button">${this.collapseButtonText}</button>
      </div>
    `}};Mt.styles=[de,oe(n(27))],Tt([ee()],Mt.prototype,"mutants",void 0),Tt([ee()],Mt.prototype,"collapseButtonText",null),Tt([ee()],Mt.prototype,"collapsed",void 0),Tt([ee()],Mt.prototype,"filters",void 0),Mt=Tt([X("mutation-test-report-file-legend")],Mt)}]);</script>
    </head>
    <body>
        <mutation-test-report-app title-postfix="Stryker.NET Report">
            Your browser doesn't support <a href="https://caniuse.com/#search=custom%20elements">custom elements</a>.
            Please use a latest version of an evergreen browser (Firefox, Chrome, Safari, Opera, etc).
        </mutation-test-report-app>
        <script>
            document.querySelector('mutation-test-report-app').report =
            {
  "schemaVersion": "1.3",
  "thresholds": {
    "high": 80,
    "low": 60
  },
  "files": {
    "AssemblyInfo.cs": {
      "language": "cs",
      "source": "using System.Runtime.CompilerServices;\r\n\r\n[assembly: InternalsVisibleTo(\"Core.Test\")]\r\n[assembly: InternalsVisibleTo(\"DynamicProxyGenAssembly2\")]",
      "mutants": []
    },
    "Configuration.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\nusing YamlDotNet.Serialization;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// Additional configuration that may be needed in some use cases.\r\n    /// <" + "/summary>\r\n    public sealed class Configuration\r\n    {\r\n        /// <" + "summary>\r\n        /// Additional requirements, beyond the default for this step.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 1)]\r\n        public List<" + "Requirement>? AdditionalRequirements { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Tags that the target machine must have (defined in a the config file) for this to be run on that machine.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 2)]\r\n        public List<" + "string>? TargetMachineTags { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Conditional true, this step will not be split into multiple steps.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 3)]\r\n        public bool DoNotSplit { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// The priority of this step. Steps with higher priorities will be run first.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 5)]\r\n        public byte? Priority { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Combines two step configurations, deferring to the child where there is a conflict.\r\n        /// <" + "/summary>\r\n        public static Configuration? Combine(Configuration? parent, Configuration? child)\r\n        {\r\n            if (parent == null)\r\n                return child;\r\n            if (child == null)\r\n                return parent;\r\n\r\n            return new Configuration\r\n            {\r\n                AdditionalRequirements = Combine(parent.AdditionalRequirements, child.AdditionalRequirements, true),\r\n                TargetMachineTags = Combine(parent.TargetMachineTags, child.TargetMachineTags, true),\r\n                DoNotSplit = parent.DoNotSplit || child.DoNotSplit,\r\n                Priority = child.Priority?? parent.Priority\r\n            };\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Tries to convert an object to a configuration.\r\n        /// <" + "/summary>\r\n        public static Result<" + "Configuration> TryConvert(object o)\r\n        {\r\n            if (o is Configuration pc) return pc;\r\n\r\n            if (o is IReadOnlyDictionary<" + "object, object> dictionary)\r\n            {\r\n                var processConfiguration = new Configuration();\r\n\r\n                var results = new List<" + "Result>();\r\n\r\n\r\n                foreach (var (key, value) in dictionary.Where(x=>x.Value != null))\r\n                {\r\n                    var result = key switch\r\n                    {\r\n                        nameof(Priority)=> value.TryConvert<" + "byte>().Tap(x=>processConfiguration.Priority = x),\r\n                        nameof(DoNotSplit)=> value.TryConvert<" + "bool>().Tap(x=>processConfiguration.DoNotSplit = x),\r\n                        nameof(TargetMachineTags)=> value.TryCast<" + "List<" + "object>>()\r\n                            .Bind(x=>x.TryConvertElements<" + "object, string>())\r\n                            .Tap(x=>processConfiguration.TargetMachineTags = x.ToList()),\r\n                        nameof(AdditionalRequirements)=> value.TryCast<" + "List<" + "object>>()\r\n                            .Bind(x=>x.TryConvertElements(Requirement.TryConvert))\r\n                            .Tap(x=>processConfiguration.AdditionalRequirements = x.ToList()),\r\n                        _ => Result.Failure($\"Could not recognize property '{key}'.\")\r\n                    };\r\n\r\n                    results.Add(result);\r\n                }\r\n\r\n                var r = results\r\n                    .Combine().Bind<" + "Configuration>(() => processConfiguration);\r\n\r\n                return r;\r\n\r\n            }\r\n            return Result.Failure<" + "Configuration>(\"Could not deserialize step configuration.\");\r\n        }\r\n\r\n\r\n        private static List<" + "T>? Combine<" + "T>(List<" + "T>? l1, List<" + "T>? l2, bool distinct)\r\n        {\r\n            if (l1 == null) return l2;\r\n            if (l2 == null) return l1;\r\n\r\n            return distinct ? l1.Concat(l2).Distinct().ToList() : l1.Concat(l2).ToList();\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "0",
          "mutatorName": "Equality mutation",
          "replacement": "parent != null",
          "location": {
            "start": {
              "line": 44,
              "column": 17
            },
            "end": {
              "line": 44,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "1",
          "mutatorName": "Negate expression",
          "replacement": "!(parent == null)",
          "location": {
            "start": {
              "line": 44,
              "column": 17
            },
            "end": {
              "line": 44,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "2",
          "mutatorName": "Equality mutation",
          "replacement": "child != null",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "3",
          "mutatorName": "Negate expression",
          "replacement": "!(child == null)",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "4",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 51,
              "column": 111
            },
            "end": {
              "line": 51,
              "column": 115
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "5",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 52,
              "column": 96
            },
            "end": {
              "line": 52,
              "column": 100
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "6",
          "mutatorName": "Logical mutation",
          "replacement": "parent.DoNotSplit && child.DoNotSplit",
          "location": {
            "start": {
              "line": 53,
              "column": 30
            },
            "end": {
              "line": 53,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "7",
          "mutatorName": "Equality mutation",
          "replacement": "x.Value == null",
          "location": {
            "start": {
              "line": 73,
              "column": 66
            },
            "end": {
              "line": 73,
              "column": 81
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "8",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 85,
              "column": 45
            },
            "end": {
              "line": 85,
              "column": 85
            }
          },
          "status": "Ignored"
        },
        {
          "id": "9",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 97,
              "column": 50
            },
            "end": {
              "line": 97,
              "column": 93
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "10",
          "mutatorName": "Equality mutation",
          "replacement": "l1 != null",
          "location": {
            "start": {
              "line": 103,
              "column": 17
            },
            "end": {
              "line": 103,
              "column": 27
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "11",
          "mutatorName": "Negate expression",
          "replacement": "!(l1 == null)",
          "location": {
            "start": {
              "line": 103,
              "column": 17
            },
            "end": {
              "line": 103,
              "column": 27
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "12",
          "mutatorName": "Equality mutation",
          "replacement": "l2 != null",
          "location": {
            "start": {
              "line": 104,
              "column": 17
            },
            "end": {
              "line": 104,
              "column": 27
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "13",
          "mutatorName": "Negate expression",
          "replacement": "!(l2 == null)",
          "location": {
            "start": {
              "line": 104,
              "column": 17
            },
            "end": {
              "line": 104,
              "column": 27
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "14",
          "mutatorName": "Negate expression",
          "replacement": "!(distinct )",
          "location": {
            "start": {
              "line": 106,
              "column": 20
            },
            "end": {
              "line": 106,
              "column": 28
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "CSVReader.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Data;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.VisualBasic.FileIO;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    internal static class CsvReader\r\n    {\r\n\r\n        public static Result<" + "DataTable> TryReadCSVFromFile(\r\n            string filePath, string delimiter, string? commentToken, bool enclosedInQuotes)\r\n        {\r\n            if(filePath == null)\r\n                return Result.Failure<" + "DataTable>(\"File path is null.\");\r\n            if (!File.Exists(filePath))\r\n                return Result.Failure<" + "DataTable>($\"'{filePath}' does not exist.\");\r\n\r\n            using var csvParser = new TextFieldParser(filePath);\r\n\r\n            return TryReadCSV(csvParser, delimiter, commentToken, enclosedInQuotes);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Extracts data from a CSV string\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"csvString\">The CSV string<" + "/param>\r\n        /// <" + "param name=\"delimiter\">The delimiter to use<" + "/param>\r\n        /// <" + "param name=\"commentToken\">The token to indicate a comment<" + "/param>\r\n        /// <" + "param name=\"enclosedInQuotes\">Whether the csv fields are enclosed in quotes<" + "/param>\r\n        /// <" + "returns><" + "/returns>\r\n        public static Result<" + "DataTable> TryReadCSVFromString(\r\n            string csvString, string delimiter, string? commentToken, bool enclosedInQuotes)\r\n        {\r\n            if(csvString == null)\r\n                return Result.Failure<" + "DataTable>(\"CSV string is null.\");\r\n\r\n            var byteArray = Encoding.UTF8.GetBytes( csvString );\r\n            var stream = new MemoryStream( byteArray );\r\n\r\n            using var csvParser = new TextFieldParser(stream);\r\n\r\n            return TryReadCSV(csvParser, delimiter, commentToken, enclosedInQuotes);\r\n        }\r\n\r\n        public static Result<" + "DataTable> TryReadCSV(TextFieldParser csvParser,\r\n            string delimiter, string? commentToken, bool enclosedInQuotes)\r\n        {\r\n            var errorsSoFar = new List<" + "string>();\r\n\r\n            if(commentToken != null)\r\n                csvParser.CommentTokens = new[] {commentToken};\r\n\r\n            csvParser.SetDelimiters(delimiter);\r\n            csvParser.HasFieldsEnclosedInQuotes = enclosedInQuotes;\r\n\r\n            var dataTable = new DataTable();\r\n\r\n            try\r\n            {\r\n                var headers = csvParser.ReadFields();\r\n                foreach (var header in headers)\r\n                    dataTable.Columns.Add(header, typeof(string));\r\n            }\r\n            catch (MalformedLineException e)\r\n            {\r\n                return Result.Failure<" + "DataTable>(e.Message);\r\n            }\r\n\r\n            var rowNumber = 1;\r\n            while (!csvParser.EndOfData)\r\n            {\r\n                // Read current line fields, pointer moves to the next line.\r\n                try\r\n                {\r\n                    var fields = csvParser.ReadFields();\r\n\r\n                    if (fields.Length != dataTable.Columns.Count)\r\n                        errorsSoFar.Add($\"There were {fields.Length} columns in row {rowNumber} but we expected {dataTable.Columns.Count}.\");\r\n                    else\r\n                        dataTable.Rows.Add(fields.ToArray<" + "object>());\r\n\r\n                }\r\n                catch (MalformedLineException e)\r\n                {\r\n                    errorsSoFar.Add(e.Message);\r\n                }\r\n\r\n                rowNumber++;\r\n            }\r\n\r\n            if (errorsSoFar.Any())\r\n                return Result.Failure<" + "DataTable>(string.Join(\"\\r\\n\", errorsSoFar));\r\n\r\n            return Result.Success(dataTable);\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "15",
          "mutatorName": "Equality mutation",
          "replacement": "filePath != null",
          "location": {
            "start": {
              "line": 17,
              "column": 16
            },
            "end": {
              "line": 17,
              "column": 32
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "16",
          "mutatorName": "Negate expression",
          "replacement": "!(filePath == null)",
          "location": {
            "start": {
              "line": 17,
              "column": 16
            },
            "end": {
              "line": 17,
              "column": 32
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "17",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 18,
              "column": 50
            },
            "end": {
              "line": 18,
              "column": 70
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "18",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "File.Exists(filePath)",
          "location": {
            "start": {
              "line": 19,
              "column": 17
            },
            "end": {
              "line": 19,
              "column": 39
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "19",
          "mutatorName": "Negate expression",
          "replacement": "!(!File.Exists(filePath))",
          "location": {
            "start": {
              "line": 19,
              "column": 17
            },
            "end": {
              "line": 19,
              "column": 39
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "20",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 20,
              "column": 50
            },
            "end": {
              "line": 20,
              "column": 81
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "21",
          "mutatorName": "Equality mutation",
          "replacement": "csvString != null",
          "location": {
            "start": {
              "line": 38,
              "column": 16
            },
            "end": {
              "line": 38,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "22",
          "mutatorName": "Negate expression",
          "replacement": "!(csvString == null)",
          "location": {
            "start": {
              "line": 38,
              "column": 16
            },
            "end": {
              "line": 38,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "23",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 39,
              "column": 50
            },
            "end": {
              "line": 39,
              "column": 71
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "24",
          "mutatorName": "Equality mutation",
          "replacement": "commentToken == null",
          "location": {
            "start": {
              "line": 54,
              "column": 16
            },
            "end": {
              "line": 54,
              "column": 36
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "25",
          "mutatorName": "Negate expression",
          "replacement": "!(commentToken != null)",
          "location": {
            "start": {
              "line": 54,
              "column": 16
            },
            "end": {
              "line": 54,
              "column": 36
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "26",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "csvParser.EndOfData",
          "location": {
            "start": {
              "line": 74,
              "column": 20
            },
            "end": {
              "line": 74,
              "column": 40
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "27",
          "mutatorName": "Negate expression",
          "replacement": "!(!csvParser.EndOfData)",
          "location": {
            "start": {
              "line": 74,
              "column": 20
            },
            "end": {
              "line": 74,
              "column": 40
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "28",
          "mutatorName": "Equality mutation",
          "replacement": "fields.Length == dataTable.Columns.Count",
          "location": {
            "start": {
              "line": 81,
              "column": 25
            },
            "end": {
              "line": 81,
              "column": 65
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "29",
          "mutatorName": "Negate expression",
          "replacement": "!(fields.Length != dataTable.Columns.Count)",
          "location": {
            "start": {
              "line": 81,
              "column": 25
            },
            "end": {
              "line": 81,
              "column": 65
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "30",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 82,
              "column": 41
            },
            "end": {
              "line": 82,
              "column": 140
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "31",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "\r\n                rowNumber--",
          "location": {
            "start": {
              "line": 92,
              "column": 17
            },
            "end": {
              "line": 92,
              "column": 28
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "32",
          "mutatorName": "Negate expression",
          "replacement": "!(errorsSoFar.Any())",
          "location": {
            "start": {
              "line": 95,
              "column": 17
            },
            "end": {
              "line": 95,
              "column": 34
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "33",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 96,
              "column": 62
            },
            "end": {
              "line": 96,
              "column": 68
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "EmptySettings.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// A settings object with no fields.\r\n    /// <" + "/summary>\r\n    public class EmptySettings : ISettings\r\n    {\r\n        /// <" + "summary>\r\n        /// Gets the instance of EmptySettings.\r\n        /// <" + "/summary>\r\n        public static ISettings Instance = new EmptySettings();\r\n\r\n\r\n        private EmptySettings() {}\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "Unit, IRunErrors> CheckRequirement(string processName, Requirement requirement) =>\r\n            new RunError($\"Requirement '{requirement}' not met.\", processName, null,\r\n                ErrorCode.RequirementsNotMet);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "34",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 22,
              "column": 26
            },
            "end": {
              "line": 22,
              "column": 65
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "ExternalProcessRunner.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading.Tasks;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// Basic external step runner.\r\n    /// <" + "/summary>\r\n    public class ExternalProcessRunner : IExternalProcessRunner\r\n    {\r\n        private ExternalProcessRunner() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static IExternalProcessRunner Instance { get; } = new ExternalProcessRunner();\r\n\r\n        private enum Source\r\n        {\r\n            Output,\r\n            Error\r\n        }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public async Task<" + "Result<" + "Unit, IRunErrors>> RunExternalProcess(string processPath, ILogger logger, string callingProcessName, IErrorHandler errorHandler, IEnumerable<" + "string> arguments)\r\n        {\r\n            if (!File.Exists(processPath))\r\n                return new RunError($\"Could not find '{processPath}'\", callingProcessName, null, ErrorCode.ExternalProcessNotFound);\r\n\r\n            var argumentString = string.Join(' ', arguments.Select(EncodeParameterArgument));\r\n            using var pProcess = new System.Diagnostics.Process\r\n            {\r\n                StartInfo =\r\n                {\r\n                    FileName = processPath,\r\n                    Arguments = argumentString,\r\n                    UseShellExecute = false,\r\n                    RedirectStandardOutput = true,\r\n                    RedirectStandardError = true,\r\n                    WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden, //don't display a window\r\n                    CreateNoWindow = true,\r\n                    StandardErrorEncoding = System.Text.Encoding.UTF8,\r\n                    StandardOutputEncoding = System.Text.Encoding.UTF8\r\n                }\r\n            };\r\n            pProcess.Start();\r\n\r\n            var multiStreamReader = new MultiStreamReader<" + "(string line, Source source)>(new IStreamReader<" + "(string, Source)>[]\r\n            {\r\n                new StreamReaderWithSource<" + "Source>(pProcess.StandardOutput, Source.Output),\r\n                new StreamReaderWithSource<" + "Source>(pProcess.StandardError, Source.Error),\r\n            });\r\n\r\n            var errors = new List<" + "RunError>();\r\n\r\n            //Read the output one line at a time\r\n            while (true)\r\n            {\r\n                var line = await multiStreamReader.ReadLineAsync();\r\n                if (line == null) //We've reached the end of the file\r\n                    break;\r\n                if (line.Value.source == Source.Error)\r\n                {\r\n                    var errorText = string.IsNullOrWhiteSpace(line.Value.line) ? \"Unknown Error\" : line.Value.line;\r\n\r\n                    if (errorHandler.ShouldIgnoreError(errorText))\r\n                        logger.LogWarning(line.Value.line);\r\n                    else\r\n                        errors.Add(new RunError(errorText, callingProcessName, null, ErrorCode.ExternalProcessError));\r\n\r\n                }\r\n                else\r\n                    logger.LogInformation(line.Value.line);\r\n            }\r\n\r\n            pProcess.WaitForExit();\r\n\r\n            if (errors.Any())\r\n            {\r\n                var e = RunErrorList.Combine(errors);\r\n                return Result.Failure<" + "Unit, IRunErrors>(e);\r\n            }\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        private static readonly Regex BackslashRegex = new Regex(@\"(\\\\*)\" + \"\\\"\", RegexOptions.Compiled);\r\n        private static readonly Regex TermWithSpaceRegex = new Regex(@\"^(.*\\s.*?)(\\\\*)$\", RegexOptions.Compiled | RegexOptions.Singleline);\r\n\r\n        private static string EncodeParameterArgument(string original)\r\n        {\r\n            if (string.IsNullOrEmpty(original))\r\n                return $\"\\\"{original}\\\"\";\r\n            var value = BackslashRegex.Replace(original, @\"$1\\$0\");\r\n\r\n            value = TermWithSpaceRegex.Replace(value, \"\\\"$1$2$2\\\"\");\r\n            return value;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "35",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "File.Exists(processPath)",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "36",
          "mutatorName": "Negate expression",
          "replacement": "!(!File.Exists(processPath))",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "37",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 36,
              "column": 37
            },
            "end": {
              "line": 36,
              "column": 70
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "38",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 45,
              "column": 39
            },
            "end": {
              "line": 45,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "39",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 46,
              "column": 46
            },
            "end": {
              "line": 46,
              "column": 50
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "40",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 47,
              "column": 45
            },
            "end": {
              "line": 47,
              "column": 49
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "41",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 49,
              "column": 38
            },
            "end": {
              "line": 49,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "42",
          "mutatorName": "Array initializer mutation",
          "replacement": "new IStreamReader<" + "(string, Source)>[]\r\n{}",
          "location": {
            "start": {
              "line": 56,
              "column": 89
            },
            "end": {
              "line": 60,
              "column": 14
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "43",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 65,
              "column": 20
            },
            "end": {
              "line": 65,
              "column": 24
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "44",
          "mutatorName": "Negate expression",
          "replacement": "!(true)",
          "location": {
            "start": {
              "line": 65,
              "column": 20
            },
            "end": {
              "line": 65,
              "column": 24
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "45",
          "mutatorName": "Equality mutation",
          "replacement": "line != null",
          "location": {
            "start": {
              "line": 68,
              "column": 21
            },
            "end": {
              "line": 68,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "46",
          "mutatorName": "Negate expression",
          "replacement": "!(line == null)",
          "location": {
            "start": {
              "line": 68,
              "column": 21
            },
            "end": {
              "line": 68,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "47",
          "mutatorName": "Equality mutation",
          "replacement": "line.Value.source != Source.Error",
          "location": {
            "start": {
              "line": 70,
              "column": 21
            },
            "end": {
              "line": 70,
              "column": 54
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "48",
          "mutatorName": "Negate expression",
          "replacement": "!(line.Value.source == Source.Error)",
          "location": {
            "start": {
              "line": 70,
              "column": 21
            },
            "end": {
              "line": 70,
              "column": 54
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "49",
          "mutatorName": "Negate expression",
          "replacement": "!(string.IsNullOrWhiteSpace(line.Value.line) )",
          "location": {
            "start": {
              "line": 72,
              "column": 37
            },
            "end": {
              "line": 72,
              "column": 79
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "50",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 72,
              "column": 82
            },
            "end": {
              "line": 72,
              "column": 97
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "51",
          "mutatorName": "Negate expression",
          "replacement": "!(errorHandler.ShouldIgnoreError(errorText))",
          "location": {
            "start": {
              "line": 74,
              "column": 25
            },
            "end": {
              "line": 74,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "52",
          "mutatorName": "Negate expression",
          "replacement": "!(errors.Any())",
          "location": {
            "start": {
              "line": 86,
              "column": 17
            },
            "end": {
              "line": 86,
              "column": 29
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "53",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 95,
              "column": 66
            },
            "end": {
              "line": 95,
              "column": 74
            }
          },
          "status": "Survived"
        },
        {
          "id": "54",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 95,
              "column": 77
            },
            "end": {
              "line": 95,
              "column": 81
            }
          },
          "status": "Survived"
        },
        {
          "id": "55",
          "mutatorName": "Regex anchor removal mutation",
          "replacement": "\"(.*\\\\s.*?)(\\\\\\\\*)$\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived",
          "description": "Anchor \"^\" was removed at offset 0."
        },
        {
          "id": "56",
          "mutatorName": "Regex quantifier removal mutation",
          "replacement": "\"^(.\\\\s.*?)(\\\\\\\\*)$\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived",
          "description": "Quantifier \"*\" was removed at offset 3."
        },
        {
          "id": "57",
          "mutatorName": "Regex character class shorthand negation mutation",
          "replacement": "\"^(.*\\\\S.*?)(\\\\\\\\*)$\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived",
          "description": "Character class shorthand \"\\s\" was replaced with \"\\S\" at offset 4."
        },
        {
          "id": "58",
          "mutatorName": "Regex quantifier removal mutation",
          "replacement": "\"^(.*\\\\s.)(\\\\\\\\*)$\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived",
          "description": "Quantifier \"*?\" was removed at offset 7."
        },
        {
          "id": "59",
          "mutatorName": "Regex quantifier removal mutation",
          "replacement": "\"^(.*\\\\s.*?)(\\\\\\\\)$\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived",
          "description": "Quantifier \"*\" was removed at offset 13."
        },
        {
          "id": "60",
          "mutatorName": "Regex anchor removal mutation",
          "replacement": "\"^(.*\\\\s.*?)(\\\\\\\\*)\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived",
          "description": "Anchor \"$\" was removed at offset 15."
        },
        {
          "id": "61",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 96,
              "column": 70
            },
            "end": {
              "line": 96,
              "column": 89
            }
          },
          "status": "Survived"
        },
        {
          "id": "62",
          "mutatorName": "Bitwise mutation",
          "replacement": "RegexOptions.Compiled & RegexOptions.Singleline",
          "location": {
            "start": {
              "line": 96,
              "column": 91
            },
            "end": {
              "line": 96,
              "column": 138
            }
          },
          "status": "Survived"
        },
        {
          "id": "63",
          "mutatorName": "Negate expression",
          "replacement": "!(string.IsNullOrEmpty(original))",
          "location": {
            "start": {
              "line": 100,
              "column": 17
            },
            "end": {
              "line": 100,
              "column": 47
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "64",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 101,
              "column": 24
            },
            "end": {
              "line": 101,
              "column": 41
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "65",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 102,
              "column": 58
            },
            "end": {
              "line": 102,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "66",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 104,
              "column": 55
            },
            "end": {
              "line": 104,
              "column": 67
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "IErrorHandler.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// Determines how to handle errors coming from an external step.\r\n    /// <" + "/summary>\r\n    public interface IErrorHandler\r\n    {\r\n        /// <" + "summary>\r\n        /// Whether to ignore a particular error.\r\n        /// <" + "/summary>\r\n        public bool ShouldIgnoreError(string s);\r\n    }\r\n}",
      "mutants": []
    },
    "IExternalProcessRunner.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Threading.Tasks;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// Runs external processes.\r\n    /// <" + "/summary>\r\n    public interface IExternalProcessRunner\r\n    {\r\n        /// <" + "summary>\r\n        /// Runs an external step and returns the output and errors\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"processPath\">The path to the step<" + "/param>\r\n        /// <" + "param name=\"logger\"><" + "/param>\r\n        /// <" + "param name=\"callingProcessName\">The name of the calling step. For error reporting.<" + "/param>\r\n        /// <" + "param name=\"errorHandler\">The error handler.<" + "/param>\r\n        /// <" + "param name=\"arguments\">The arguments to provide to the step. These will all be escaped<" + "/param>\r\n        /// <" + "returns>The output of the step<" + "/returns>\r\n        Task<" + "Result<" + "Unit, IRunErrors>> RunExternalProcess(\r\n            string processPath,\r\n            ILogger logger,\r\n            string callingProcessName,\r\n            IErrorHandler errorHandler,\r\n            IEnumerable<" + "string> arguments);\r\n    }\r\n}",
      "mutants": []
    },
    "IgnoreAllErrorHandler.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// Ignores all errors.\r\n    /// <" + "/summary>\r\n    public class IgnoreAllErrorHandler : IErrorHandler\r\n    {\r\n        private IgnoreAllErrorHandler(){}\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static IErrorHandler Instance = new IgnoreAllErrorHandler();\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool ShouldIgnoreError(string s) => true;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "67",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 16,
              "column": 52
            },
            "end": {
              "line": 16,
              "column": 56
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "IgnoreNoneErrorHandler.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// Does not ignore any errors.\r\n    /// <" + "/summary>\r\n    public class IgnoreNoneErrorHandler : IErrorHandler\r\n    {\r\n        private IgnoreNoneErrorHandler(){}\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static IErrorHandler Instance = new IgnoreNoneErrorHandler();\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool ShouldIgnoreError(string s) => false;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "68",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 16,
              "column": 52
            },
            "end": {
              "line": 16,
              "column": 57
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "ISettings.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// External settings for running the step.\r\n    /// <" + "/summary>\r\n    public interface ISettings\r\n    {\r\n\r\n        /// <" + "summary>\r\n        /// Check that the requirement is met by these settings.\r\n        /// <" + "/summary>\r\n        Result<" + "Unit, IRunErrors> CheckRequirement(string processName, Requirement requirement);\r\n    }\r\n}",
      "mutants": []
    },
    "Requirement.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\nusing YamlDotNet.Serialization;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// A requirement of a step.\r\n    /// <" + "/summary>\r\n    public sealed class Requirement\r\n    {\r\n        /// <" + "summary>\r\n        /// The name of the required software.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 1)]\r\n        [Required]\r\n#pragma warning disable 8618\r\n        public string Name { get; set; }\r\n#pragma warning restore 8618\r\n\r\n        /// <" + "summary>\r\n        /// The minimum required version. Inclusive.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 1)]\r\n        public Version? MinVersion { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// The The version above the highest allowed version.\r\n        /// <" + "/summary>\r\n        [YamlMember(Order = 1)]\r\n        public Version? MaxVersion { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Notes on the requirement.\r\n        /// <" + "/summary>\r\n        public string? Notes { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Tries to convert an object to a requirement\r\n        /// <" + "/summary>\r\n        public static Result<" + "Requirement> TryConvert(object o)\r\n        {\r\n            if (o is Requirement req) return req;\r\n\r\n            if (o is IReadOnlyDictionary<" + "object, object> dictionary)\r\n            {\r\n                var requirement = new Requirement();\r\n\r\n                var results = new List<" + "Result>();\r\n\r\n\r\n                foreach (var (key, value) in dictionary.Where(x => x.Value != null))\r\n                {\r\n                    var result = key switch\r\n                    {\r\n                        nameof(MinVersion) => TryConvertToVersion(value).Tap(x => requirement.MinVersion = x),\r\n                        nameof(MaxVersion) => TryConvertToVersion(value).Tap(x => requirement.MaxVersion = x),\r\n                        nameof(Name) => value.TryConvert<" + "string>().Tap(x => requirement.Name = x),\r\n                        nameof(Notes) => value.TryConvert<" + "string>().Tap(x => requirement.Notes = x),\r\n                        _ => Result.Failure($\"Could not recognize property '{key}'.\")\r\n                    };\r\n\r\n                    results.Add(result);\r\n                }\r\n\r\n                var r = results\r\n                    .Combine().Bind<" + "Requirement>(() => requirement);\r\n\r\n                return r;\r\n\r\n            }\r\n\r\n\r\n            return Result.Failure<" + "Requirement>($\"Could not convert '{o}' to {nameof(Requirement)}\");\r\n        }\r\n\r\n        private static Result<" + "Version> TryConvertToVersion(object o)\r\n        {\r\n            if (o is Version ver) return ver;\r\n\r\n            if (o is IReadOnlyDictionary<" + "object, object> dictionary)\r\n            {\r\n                var major = -1;\r\n                var minor = -1;\r\n                var build = -1;\r\n                var revision = -1;\r\n\r\n                var results = new List<" + "Result>();\r\n\r\n\r\n                foreach (var (key, value) in dictionary.Where(x => x.Value != null))\r\n                {\r\n                    var result = key switch\r\n                    {\r\n                        nameof(Version.Major) => value.TryConvert<" + "int>().Tap(x =>major = x),\r\n                        nameof(Version.Minor) => value.TryConvert<" + "int>().Tap(x =>minor = x),\r\n                        nameof(Version.Build) => value.TryConvert<" + "int>().Tap(x =>build = x),\r\n                        nameof(Version.Revision) => value.TryConvert<" + "int>().Tap(x =>revision = x),\r\n                        nameof(Version.MajorRevision) => Result.Success(),\r\n                        nameof(Version.MinorRevision) => Result.Success(),\r\n                        _ => Result.Failure($\"Could not recognize property '{key}'.\")\r\n                    };\r\n\r\n                    results.Add(result);\r\n                }\r\n\r\n                var r = results\r\n                    .Combine().Bind(() =>\r\n                    {\r\n                        Version version;\r\n\r\n                        if (major <" + " 0 || minor <" + " 0)\r\n                            return Result.Failure<" + "Version>(\"Major and Minor versions must both be greater than zero\");\r\n                        if (build <" + " 0) version = new Version(major, minor);\r\n                        else if (revision <" + " 0) version = new Version(major, minor, build);\r\n                        else version = new Version(major, minor, build, revision);\r\n\r\n                        return version;\r\n                    });\r\n\r\n                return r;\r\n\r\n            }\r\n\r\n\r\n            return Result.Failure<" + "Version>($\"Could not convert '{o}' to {nameof(Version)}\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString()\r\n        {\r\n            var sb = new StringBuilder();\r\n\r\n            sb.Append(Name);\r\n            if (MinVersion != null)\r\n                sb.Append($\" Version {MinVersion}\");\r\n            if (MaxVersion != null)\r\n                sb.Append($\" Version <" + "= {MaxVersion}\");\r\n\r\n            if (Notes != null)\r\n                sb.Append($\" ({Notes})\");\r\n\r\n            return sb.ToString();\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj)\r\n        {\r\n            return obj is Requirement r && ToTuple.Equals(r.ToTuple);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => ToTuple.GetHashCode();\r\n\r\n        private object ToTuple => (Name, MinVersion, MaxVersion, Notes);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "69",
          "mutatorName": "Equality mutation",
          "replacement": "x.Value == null",
          "location": {
            "start": {
              "line": 57,
              "column": 68
            },
            "end": {
              "line": 57,
              "column": 83
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "70",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 65,
              "column": 45
            },
            "end": {
              "line": 65,
              "column": 85
            }
          },
          "status": "Ignored"
        },
        {
          "id": "71",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 79,
              "column": 48
            },
            "end": {
              "line": 79,
              "column": 99
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "72",
          "mutatorName": "UnaryMinusExpression to UnaryPlusExpression mutation",
          "replacement": "+1",
          "location": {
            "start": {
              "line": 88,
              "column": 29
            },
            "end": {
              "line": 88,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "73",
          "mutatorName": "UnaryMinusExpression to UnaryPlusExpression mutation",
          "replacement": "+1",
          "location": {
            "start": {
              "line": 89,
              "column": 29
            },
            "end": {
              "line": 89,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "74",
          "mutatorName": "UnaryMinusExpression to UnaryPlusExpression mutation",
          "replacement": "+1",
          "location": {
            "start": {
              "line": 90,
              "column": 29
            },
            "end": {
              "line": 90,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "75",
          "mutatorName": "UnaryMinusExpression to UnaryPlusExpression mutation",
          "replacement": "+1",
          "location": {
            "start": {
              "line": 91,
              "column": 32
            },
            "end": {
              "line": 91,
              "column": 34
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "76",
          "mutatorName": "Equality mutation",
          "replacement": "x.Value == null",
          "location": {
            "start": {
              "line": 96,
              "column": 68
            },
            "end": {
              "line": 96,
              "column": 83
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "77",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 106,
              "column": 45
            },
            "end": {
              "line": 106,
              "column": 85
            }
          },
          "status": "Ignored"
        },
        {
          "id": "78",
          "mutatorName": "Logical mutation",
          "replacement": "major <" + " 0 && minor <" + " 0",
          "location": {
            "start": {
              "line": 117,
              "column": 29
            },
            "end": {
              "line": 117,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "79",
          "mutatorName": "Negate expression",
          "replacement": "!(major <" + " 0 || minor <" + " 0)",
          "location": {
            "start": {
              "line": 117,
              "column": 29
            },
            "end": {
              "line": 117,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "80",
          "mutatorName": "Equality mutation",
          "replacement": "major > 0 ",
          "location": {
            "start": {
              "line": 117,
              "column": 29
            },
            "end": {
              "line": 117,
              "column": 38
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "81",
          "mutatorName": "Equality mutation",
          "replacement": "major <" + "= 0 ",
          "location": {
            "start": {
              "line": 117,
              "column": 29
            },
            "end": {
              "line": 117,
              "column": 38
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "82",
          "mutatorName": "Equality mutation",
          "replacement": "minor > 0",
          "location": {
            "start": {
              "line": 117,
              "column": 42
            },
            "end": {
              "line": 117,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "83",
          "mutatorName": "Equality mutation",
          "replacement": "minor <" + "= 0",
          "location": {
            "start": {
              "line": 117,
              "column": 42
            },
            "end": {
              "line": 117,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "84",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 118,
              "column": 60
            },
            "end": {
              "line": 118,
              "column": 117
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "85",
          "mutatorName": "Equality mutation",
          "replacement": "build > 0",
          "location": {
            "start": {
              "line": 119,
              "column": 29
            },
            "end": {
              "line": 119,
              "column": 38
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "86",
          "mutatorName": "Equality mutation",
          "replacement": "build <" + "= 0",
          "location": {
            "start": {
              "line": 119,
              "column": 29
            },
            "end": {
              "line": 119,
              "column": 38
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "87",
          "mutatorName": "Negate expression",
          "replacement": "!(build <" + " 0)",
          "location": {
            "start": {
              "line": 119,
              "column": 29
            },
            "end": {
              "line": 119,
              "column": 38
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "88",
          "mutatorName": "Equality mutation",
          "replacement": "revision > 0",
          "location": {
            "start": {
              "line": 120,
              "column": 34
            },
            "end": {
              "line": 120,
              "column": 46
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "89",
          "mutatorName": "Equality mutation",
          "replacement": "revision <" + "= 0",
          "location": {
            "start": {
              "line": 120,
              "column": 34
            },
            "end": {
              "line": 120,
              "column": 46
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "90",
          "mutatorName": "Negate expression",
          "replacement": "!(revision <" + " 0)",
          "location": {
            "start": {
              "line": 120,
              "column": 34
            },
            "end": {
              "line": 120,
              "column": 46
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "91",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 131,
              "column": 44
            },
            "end": {
              "line": 131,
              "column": 91
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "92",
          "mutatorName": "Equality mutation",
          "replacement": "MinVersion == null",
          "location": {
            "start": {
              "line": 140,
              "column": 17
            },
            "end": {
              "line": 140,
              "column": 35
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "93",
          "mutatorName": "Negate expression",
          "replacement": "!(MinVersion != null)",
          "location": {
            "start": {
              "line": 140,
              "column": 17
            },
            "end": {
              "line": 140,
              "column": 35
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "94",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 141,
              "column": 27
            },
            "end": {
              "line": 141,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "95",
          "mutatorName": "Equality mutation",
          "replacement": "MaxVersion == null",
          "location": {
            "start": {
              "line": 142,
              "column": 17
            },
            "end": {
              "line": 142,
              "column": 35
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "96",
          "mutatorName": "Negate expression",
          "replacement": "!(MaxVersion != null)",
          "location": {
            "start": {
              "line": 142,
              "column": 17
            },
            "end": {
              "line": 142,
              "column": 35
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "97",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 143,
              "column": 27
            },
            "end": {
              "line": 143,
              "column": 54
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "98",
          "mutatorName": "Equality mutation",
          "replacement": "Notes == null",
          "location": {
            "start": {
              "line": 145,
              "column": 17
            },
            "end": {
              "line": 145,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "99",
          "mutatorName": "Negate expression",
          "replacement": "!(Notes != null)",
          "location": {
            "start": {
              "line": 145,
              "column": 17
            },
            "end": {
              "line": 145,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "100",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 146,
              "column": 27
            },
            "end": {
              "line": 146,
              "column": 40
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "101",
          "mutatorName": "Logical mutation",
          "replacement": "obj is Requirement r || ToTuple.Equals(r.ToTuple)",
          "location": {
            "start": {
              "line": 154,
              "column": 20
            },
            "end": {
              "line": 154,
              "column": 69
            }
          },
          "status": "CompileError"
        }
      ]
    },
    "StateMonad.cs": {
      "language": "cs",
      "source": "using System.Collections.Concurrent;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core\r\n{\r\n    /// <" + "summary>\r\n    /// The state monad that is passed between steps.\r\n    /// <" + "/summary>\r\n    public sealed class StateMonad\r\n    {\r\n        private readonly ConcurrentDictionary<" + "VariableName, object>  _stateDictionary = new ConcurrentDictionary<" + "VariableName, object>();\r\n\r\n        /// <" + "summary>\r\n        /// Create a new StateMonad\r\n        /// <" + "/summary>\r\n        public StateMonad(ILogger logger, ISettings settings, IExternalProcessRunner externalProcessRunner)\r\n        {\r\n            Logger = logger;\r\n            Settings = settings;\r\n            ExternalProcessRunner = externalProcessRunner;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The logger that steps will use to output messages.\r\n        /// <" + "/summary>\r\n        public ILogger Logger { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The settings for this step.\r\n        /// <" + "/summary>\r\n        public ISettings Settings { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The runner of external processes.\r\n        /// <" + "/summary>\r\n        public IExternalProcessRunner ExternalProcessRunner { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Get settings of a particular type.\r\n        /// <" + "/summary>\r\n        public Result<" + "T, IRunErrors> GetSettings<" + "T>(string stepName) where T : ISettings =>\r\n            Settings.TryCast<" + "T>()\r\n                .MapFailure(x => new RunError(x, stepName, null, ErrorCode.MissingStepSettings) as IRunErrors);\r\n\r\n        /// <" + "summary>\r\n        /// Gets the current value of this variable.\r\n        /// <" + "/summary>\r\n        public Result<" + "T,IRunErrors> GetVariable<" + "T>(VariableName key, string stepName)\r\n        {\r\n            if (_stateDictionary.TryGetValue(key, out var value))\r\n            {\r\n                if (value is T typedValue)\r\n                    return typedValue;\r\n\r\n                return new RunError($\"Variable '{key}' does not have type '{typeof(T)}'.\", stepName, null, ErrorCode.WrongVariableType);\r\n            }\r\n\r\n            return new RunError($\"Variable '{key}' does not exist.\", stepName, null, ErrorCode.MissingVariable);\r\n\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Creates or set the value of this variable.\r\n        /// <" + "/summary>\r\n        public Result<" + "Unit, IRunErrors> SetVariable<" + "T>(VariableName key, T variable)\r\n        {\r\n            _stateDictionary\r\n                .AddOrUpdate(key, _ => variable!, (_1, _2) => variable!);\r\n\r\n            return Unit.Default;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "102",
          "mutatorName": "Negate expression",
          "replacement": "!(_stateDictionary.TryGetValue(key, out var value))",
          "location": {
            "start": {
              "line": 53,
              "column": 17
            },
            "end": {
              "line": 53,
              "column": 65
            }
          },
          "status": "Killed"
        },
        {
          "id": "103",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 58,
              "column": 37
            },
            "end": {
              "line": 58,
              "column": 90
            }
          },
          "status": "Killed"
        },
        {
          "id": "104",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 61,
              "column": 33
            },
            "end": {
              "line": 61,
              "column": 68
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Attributes\\AllowedRangeAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates the allowed range of values.\r\n    /// <" + "/summary>\r\n    public sealed class AllowedRangeAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new AllowedRangeAttribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"allowedRangeValue\"><" + "/param>\r\n        public AllowedRangeAttribute(string allowedRangeValue)\r\n        {\r\n            AllowedRangeValue = allowedRangeValue;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The range allowed.\r\n        /// <" + "/summary>\r\n        public string AllowedRangeValue { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\DefaultValueExplanationAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Use this attribute to explain the meaning of the default value.\r\n    /// <" + "/summary>\r\n    [AttributeUsage(AttributeTargets.Property)]\r\n    public sealed class DefaultValueExplanationAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new DefaultValueExplanationAttribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"explanation\"><" + "/param>\r\n        public DefaultValueExplanationAttribute(string explanation)\r\n        {\r\n            Explanation = explanation;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// What the default value means.\r\n        /// <" + "/summary>\r\n        public string Explanation { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\DocumentationURLAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Points to a documentation page for this parameter.\r\n    /// <" + "/summary>\r\n    public sealed class DocumentationURLAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new DocumentationURLAttribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"documentationURL\"><" + "/param>\r\n        public DocumentationURLAttribute(string documentationURL)\r\n        {\r\n            DocumentationURL = documentationURL;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The url to the documentation.\r\n        /// <" + "/summary>\r\n        public string DocumentationURL { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\ExampleAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates an example value for this parameter.\r\n    /// <" + "/summary>\r\n    public sealed class ExampleAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new ExampleAttribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"example\"><" + "/param>\r\n        public ExampleAttribute(string example)\r\n        {\r\n            Example = example;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The example value.\r\n        /// <" + "/summary>\r\n        public string Example { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\NotAParameterAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates that this is parameter should not be used by YAML\r\n    /// <" + "/summary>\r\n    public sealed class NotAParameterAttribute : Attribute {\r\n\r\n        /// <" + "summary>\r\n        /// Creates a new NotAParameterAttribute\r\n        /// <" + "/summary>\r\n        public NotAParameterAttribute()\r\n        {\r\n        }\r\n\r\n    }\r\n}\r\n",
      "mutants": []
    },
    "Core\\Attributes\\RecommendedRangeAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates the recommended range for this parameter.\r\n    /// <" + "/summary>\r\n    public sealed class RecommendedRangeAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new RecommendedRangeAttribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"recommendedRange\"><" + "/param>\r\n        public RecommendedRangeAttribute(string recommendedRange)\r\n        {\r\n            RecommendedRange = recommendedRange;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The recommended range for this parameter.\r\n        /// <" + "/summary>\r\n        public string RecommendedRange { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\RecommendedValueAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// The recommended value for this parameter.\r\n    /// <" + "/summary>\r\n    public sealed class RecommendedValueAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new RecommendedValueAttribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"recommendedValue\"><" + "/param>\r\n        public RecommendedValueAttribute(string recommendedValue)\r\n        {\r\n            RecommendedValue = recommendedValue;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The recommended value.\r\n        /// <" + "/summary>\r\n        public string RecommendedValue { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\RequiredVersionAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Use this attribute to denote the required version of some software.\r\n    /// <" + "/summary>\r\n    [AttributeUsage(AttributeTargets.Property)]\r\n    public sealed class RequiredVersionAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new RequiredVersion attribute\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"softwareName\">e.g. \"Nuix\"<" + "/param>\r\n        /// <" + "param name=\"requiredVersion\">e.g. \"6.2\"<" + "/param>\r\n        public RequiredVersionAttribute(string softwareName, string requiredVersion)\r\n        {\r\n            SoftwareName = softwareName;\r\n            RequiredVersion = new Version(requiredVersion);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The software whose version is required.\r\n        /// <" + "/summary>\r\n        public string SoftwareName { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The required version of the software.\r\n        /// <" + "/summary>\r\n        public Version RequiredVersion { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The required version in human readable form.\r\n        /// <" + "/summary>\r\n        public string Text => $\"{SoftwareName} {RequiredVersion}\";\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString()\r\n        {\r\n            return Text;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "105",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 35,
              "column": 31
            },
            "end": {
              "line": 35,
              "column": 66
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Attributes\\SeeAlsoAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates a related topic.\r\n    /// <" + "/summary>\r\n    public sealed class SeeAlsoAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new SeeAlsoAttribute\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"seeAlso\"><" + "/param>\r\n        public SeeAlsoAttribute(string seeAlso)\r\n        {\r\n            SeeAlso = seeAlso;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Where to go to see something else.\r\n        /// <" + "/summary>\r\n        public string SeeAlso { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\StepAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Optional attribute allowing you to assign an alias to a step.\r\n    /// <" + "/summary>\r\n    [AttributeUsage(AttributeTargets.Class)]\r\n    public sealed class StepAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// The new name for this step.\r\n        /// <" + "/summary>\r\n        public string? Alias { get; set; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\StepListPropertyAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates that this is a list of configurable properties of the step.\r\n    /// <" + "/summary>\r\n\r\n    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]\r\n    public sealed class StepListPropertyAttribute : StepPropertyBaseAttribute { }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\StepPropertyAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates that this is a configurable property of the step.\r\n    /// <" + "/summary>\r\n\r\n    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]\r\n    public sealed class StepPropertyAttribute : StepPropertyBaseAttribute{ }\r\n}\r\n",
      "mutants": []
    },
    "Core\\Attributes\\StepPropertyBaseAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// A property that will be used by the step.\r\n    /// <" + "/summary>\r\n    public abstract class StepPropertyBaseAttribute : Attribute\r\n    {\r\n        /// <" + "summary>\r\n        /// The order where this property should appear.\r\n        /// <" + "/summary>\r\n        public int Order { get; set; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\ValueDelimiterAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates the value to be used as a delimiter\r\n    /// <" + "/summary>\r\n    public sealed class ValueDelimiterAttribute : Attribute {\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Create a new ValueDelimiterAttribute\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"delimiter\"><" + "/param>\r\n        public ValueDelimiterAttribute(string delimiter)\r\n        {\r\n            Delimiter = delimiter;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The delimiter.\r\n        /// <" + "/summary>\r\n        public string Delimiter { get;  }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Attributes\\VariableNameAttribute.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Attributes\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates that this property is the name of a variable.\r\n    /// <" + "/summary>\r\n    [AttributeUsage(AttributeTargets.Property)]\r\n    public sealed class VariableNameAttribute : StepPropertyBaseAttribute { }\r\n}",
      "mutants": []
    },
    "Core\\General\\AppendString.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Appends a string to an existing string variable.\r\n    /// <" + "/summary>\r\n    public sealed class AppendString : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "summary>\r\n        /// The variable to append to.\r\n        /// <" + "/summary>\r\n        [VariableName(Order = 1)]\r\n        [Required]\r\n        public VariableName Variable { get; set; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The string to append.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 2)]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var currentValue = stateMonad.GetVariable<" + "string>(Variable, Name);\r\n            if (currentValue.IsFailure)\r\n                return currentValue.ConvertFailure<" + "Unit>();\r\n\r\n\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure)\r\n                return str.ConvertFailure<" + "Unit>();\r\n\r\n            var value = currentValue.Value + str.Value;\r\n\r\n            var r = stateMonad.SetVariable(Variable, value);\r\n            if (r.IsFailure)\r\n                return r.ConvertFailure<" + "Unit>();\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => AppendStringStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "106",
          "mutatorName": "Negate expression",
          "replacement": "!(currentValue.IsFailure)",
          "location": {
            "start": {
              "line": 33,
              "column": 17
            },
            "end": {
              "line": 33,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "107",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 30
            }
          },
          "status": "Killed"
        },
        {
          "id": "108",
          "mutatorName": "Arithmetic mutation",
          "replacement": "currentValue.Value - str.Value",
          "location": {
            "start": {
              "line": 41,
              "column": 25
            },
            "end": {
              "line": 41,
              "column": 55
            }
          },
          "status": "CompileError"
        },
        {
          "id": "109",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsFailure)",
          "location": {
            "start": {
              "line": 44,
              "column": 17
            },
            "end": {
              "line": 44,
              "column": 28
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\AppendStringStepFactory.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Appends a string to an existing string variable.\r\n    /// <" + "/summary>\r\n    public sealed class AppendStringStepFactory : SimpleStepFactory<" + "AppendString, Unit>\r\n    {\r\n        private AppendStringStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "AppendString, Unit> Instance { get; } = new AppendStringStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData) => Maybe<" + "ITypeReference>.From(new ActualTypeReference(typeof(string)));\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Append [{nameof(AppendString.String)}] to [{nameof(AppendString.Variable)}]\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "110",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 24,
              "column": 93
            },
            "end": {
              "line": 24,
              "column": 171
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\ApplyBooleanOperator.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Returns true if both operands are true\r\n    /// <" + "/summary>\r\n    public sealed class ApplyBooleanOperator : CompoundStep<" + "bool>\r\n    {\r\n        /// <" + "summary>\r\n        /// The left operand. Will always be evaluated.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Left { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The operator to apply.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "BooleanOperator> Operator { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The right operand. Will not be evaluated unless necessary.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Right { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "bool, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var l = Left.Run(stateMonad);\r\n            if (l.IsFailure) return l;\r\n            var op = Operator.Run(stateMonad);\r\n            if (op.IsFailure) return op.ConvertFailure<" + "bool>();\r\n\r\n            switch (op.Value)\r\n            {\r\n                case BooleanOperator.And:\r\n                {\r\n                    if (l.Value == false)\r\n                        return false;\r\n\r\n                    var r = Right.Run(stateMonad);\r\n                    return r;\r\n                }\r\n                case BooleanOperator.Or:\r\n                {\r\n                    if (l.Value)\r\n                        return true;\r\n\r\n                    var r = Right.Run(stateMonad);\r\n                    return r;\r\n                }\r\n                default:\r\n                    throw new ArgumentOutOfRangeException();\r\n            }\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ApplyBooleanStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "111",
          "mutatorName": "Negate expression",
          "replacement": "!(l.IsFailure)",
          "location": {
            "start": {
              "line": 42,
              "column": 17
            },
            "end": {
              "line": 42,
              "column": 28
            }
          },
          "status": "Killed"
        },
        {
          "id": "112",
          "mutatorName": "Negate expression",
          "replacement": "!(op.IsFailure)",
          "location": {
            "start": {
              "line": 44,
              "column": 17
            },
            "end": {
              "line": 44,
              "column": 29
            }
          },
          "status": "Killed"
        },
        {
          "id": "113",
          "mutatorName": "Equality mutation",
          "replacement": "l.Value != false",
          "location": {
            "start": {
              "line": 50,
              "column": 25
            },
            "end": {
              "line": 50,
              "column": 41
            }
          },
          "status": "Killed"
        },
        {
          "id": "114",
          "mutatorName": "Negate expression",
          "replacement": "!(l.Value == false)",
          "location": {
            "start": {
              "line": 50,
              "column": 25
            },
            "end": {
              "line": 50,
              "column": 41
            }
          },
          "status": "Killed"
        },
        {
          "id": "115",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 50,
              "column": 36
            },
            "end": {
              "line": 50,
              "column": 41
            }
          },
          "status": "Killed"
        },
        {
          "id": "116",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 51,
              "column": 32
            },
            "end": {
              "line": 51,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "117",
          "mutatorName": "Negate expression",
          "replacement": "!(l.Value)",
          "location": {
            "start": {
              "line": 58,
              "column": 25
            },
            "end": {
              "line": 58,
              "column": 32
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "118",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 59,
              "column": 32
            },
            "end": {
              "line": 59,
              "column": 36
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\ApplyBooleanStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns true if both operands are true\r\n    /// <" + "/summary>\r\n    public sealed class ApplyBooleanStepFactory : SimpleStepFactory<" + "ApplyBooleanOperator, bool>\r\n    {\r\n        private ApplyBooleanStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static StepFactory Instance { get; } = new ApplyBooleanStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"[{nameof(ApplyBooleanOperator.Left)}] [{nameof(ApplyBooleanOperator.Operator)}] [{nameof(ApplyBooleanOperator.Right)}]\");\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => new[] {typeof(BooleanOperator)};\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer { get; } = new StepSerializer(\r\n            new FixedStringComponent(\"(\"),\r\n            new BooleanComponent(nameof(ApplyBooleanOperator.Left)),\r\n            new SpaceComponent(),\r\n            new EnumDisplayComponent<" + "BooleanOperator>(nameof(ApplyBooleanOperator.Operator)),\r\n            new SpaceComponent(),\r\n            new BooleanComponent(nameof(ApplyBooleanOperator.Right)),\r\n            new FixedStringComponent(\")\")\r\n        );\r\n    }\r\n}",
      "mutants": [
        {
          "id": "119",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 21,
              "column": 93
            },
            "end": {
              "line": 21,
              "column": 214
            }
          },
          "status": "Killed"
        },
        {
          "id": "120",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 28,
              "column": 38
            },
            "end": {
              "line": 28,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "121",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 34,
              "column": 38
            },
            "end": {
              "line": 34,
              "column": 41
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\ApplyMathOperator.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Applies a mathematical operator to two integers.\r\n    /// <" + "/summary>\r\n    public sealed class ApplyMathOperator : CompoundStep<" + "int>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "int, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var left = Left.Run(stateMonad);\r\n            if (left.IsFailure) return left;\r\n\r\n            var right = Right.Run(stateMonad);\r\n            if (right.IsFailure) return right;\r\n\r\n            var @operator = Operator.Run(stateMonad);\r\n            if (@operator.IsFailure) return @operator.ConvertFailure<" + "int>();\r\n\r\n            var result = @operator.Value switch\r\n            {\r\n                MathOperator.Add => left.Value + right.Value,\r\n                MathOperator.Subtract => left.Value - right.Value,\r\n                MathOperator.Multiply => left.Value * right.Value,\r\n                MathOperator.Divide => left.Value / right.Value,\r\n                MathOperator.Modulo => left.Value % right.Value,\r\n                MathOperator.Power => Convert.ToInt32(Math.Pow(left.Value, right.Value)),\r\n                _ => throw new ArgumentOutOfRangeException()\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ApplyMathOperatorStepFactory.Instance;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The left operand.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Left { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The operator to apply.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n\r\n        public IStep<" + "MathOperator> Operator { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The right operand.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Right { get; set; } = null!;\r\n\r\n\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "122",
          "mutatorName": "Negate expression",
          "replacement": "!(left.IsFailure)",
          "location": {
            "start": {
              "line": 18,
              "column": 17
            },
            "end": {
              "line": 18,
              "column": 31
            }
          },
          "status": "Killed"
        },
        {
          "id": "123",
          "mutatorName": "Negate expression",
          "replacement": "!(right.IsFailure)",
          "location": {
            "start": {
              "line": 21,
              "column": 17
            },
            "end": {
              "line": 21,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "124",
          "mutatorName": "Negate expression",
          "replacement": "!(@operator.IsFailure)",
          "location": {
            "start": {
              "line": 24,
              "column": 17
            },
            "end": {
              "line": 24,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "125",
          "mutatorName": "Arithmetic mutation",
          "replacement": "left.Value - right.Value",
          "location": {
            "start": {
              "line": 28,
              "column": 37
            },
            "end": {
              "line": 28,
              "column": 61
            }
          },
          "status": "Killed"
        },
        {
          "id": "126",
          "mutatorName": "Arithmetic mutation",
          "replacement": "left.Value + right.Value",
          "location": {
            "start": {
              "line": 29,
              "column": 42
            },
            "end": {
              "line": 29,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "127",
          "mutatorName": "Arithmetic mutation",
          "replacement": "left.Value / right.Value",
          "location": {
            "start": {
              "line": 30,
              "column": 42
            },
            "end": {
              "line": 30,
              "column": 66
            }
          },
          "status": "Killed"
        },
        {
          "id": "128",
          "mutatorName": "Arithmetic mutation",
          "replacement": "left.Value * right.Value",
          "location": {
            "start": {
              "line": 31,
              "column": 40
            },
            "end": {
              "line": 31,
              "column": 64
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "129",
          "mutatorName": "Arithmetic mutation",
          "replacement": "left.Value * right.Value",
          "location": {
            "start": {
              "line": 32,
              "column": 40
            },
            "end": {
              "line": 32,
              "column": 64
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\ApplyMathOperatorStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Applies a mathematical operator to two integers.\r\n    /// <" + "/summary>\r\n    public class ApplyMathOperatorStepFactory : SimpleStepFactory<" + "ApplyMathOperator, int>\r\n    {\r\n        private ApplyMathOperatorStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "ApplyMathOperator, int> Instance { get; } = new ApplyMathOperatorStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => new[] {typeof(MathOperator)};\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer { get; } = new StepSerializer(\r\n            new FixedStringComponent(\"(\"),\r\n            new IntegerComponent(nameof(ApplyMathOperator.Left)),\r\n            new SpaceComponent(),\r\n            new EnumDisplayComponent<" + "MathOperator>(nameof(ApplyMathOperator.Operator)),\r\n            new SpaceComponent(),\r\n            new IntegerComponent(nameof(ApplyMathOperator.Right)),\r\n            new FixedStringComponent(\")\")\r\n        );\r\n    }\r\n}",
      "mutants": [
        {
          "id": "130",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 25,
              "column": 38
            },
            "end": {
              "line": 25,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "131",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 31,
              "column": 38
            },
            "end": {
              "line": 31,
              "column": 41
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\Array.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Represents an ordered collection of objects.\r\n    /// <" + "/summary>\r\n    public sealed class Array<" + "T> : CompoundStep<" + "List<" + "T>>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "List<" + "T>, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var result = Elements.Select(x => x.Run(stateMonad))\r\n                .Combine(RunErrorList.Combine)\r\n                .Map(x => x.ToList());\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ArrayStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The elements of this array.\r\n        /// <" + "/summary>\r\n        [StepListProperty]\r\n        [Required]\r\n        public IReadOnlyList<" + "IStep<" + "T>> Elements { get; set; } = null!;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ArrayCount.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Counts the elements in an array.\r\n    /// <" + "/summary>\r\n    public sealed class ArrayCount<" + "T> : CompoundStep<" + "int>\r\n    {\r\n        /// <" + "summary>\r\n        /// The array to count.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "T>> Array { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "int, IRunErrors> Run(StateMonad stateMonad) => Array.Run(stateMonad).Map(x => x.Count);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ArrayCountStepFactory.Instance;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ArrayCountStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Counts the elements in an array.\r\n    /// <" + "/summary>\r\n    public sealed class ArrayCountStepFactory : GenericStepFactory\r\n    {\r\n        private ArrayCountStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new ArrayCountStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(ArrayCount<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Int32);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new ActualTypeReference(typeof(int));\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(ArrayCount<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ArrayIsEmpty.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Checks if an array is empty.\r\n    /// <" + "/summary>\r\n    public sealed class ArrayIsEmpty<" + "T> : CompoundStep<" + "bool>\r\n    {\r\n        /// <" + "summary>\r\n        /// The array to check for emptiness.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "T>> Array { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "bool, IRunErrors> Run(StateMonad stateMonad) => Array.Run(stateMonad).Map(x => !x.Any());\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ArrayIsEmptyStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "132",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "x.Any()",
          "location": {
            "start": {
              "line": 23,
              "column": 111
            },
            "end": {
              "line": 23,
              "column": 119
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\ArrayIsEmptyStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Checks if an array is empty.\r\n    /// <" + "/summary>\r\n    public sealed class ArrayIsEmptyStepFactory : GenericStepFactory\r\n    {\r\n        private ArrayIsEmptyStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new ArrayIsEmptyStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(ArrayIsEmpty<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Boolean);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new ActualTypeReference(typeof(bool));\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(ArrayCount<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ArrayStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// The factory for creating Arrays.\r\n    /// <" + "/summary>\r\n    public class ArrayStepFactory : GenericStepFactory\r\n    {\r\n        private ArrayStepFactory() {}\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new ArrayStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(Array<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => \"List<" + "T>\";\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new GenericTypeReference(typeof(List<" + ">), new []{memberTypeReference});\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"[[{nameof(Array<" + "object>.Elements)}]]\");\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData)\r\n        {\r\n            var result =\r\n                freezableStepData.GetListArgument(nameof(Array<" + "object>.Elements))\r\n                    .Bind(x => x.Select(r => r.TryGetOutputTypeReference()).Combine())\r\n                    .Bind(x => MultipleTypeReference.TryCreate(x, TypeName));\r\n\r\n\r\n            return result;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "133",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 25,
              "column": 57
            },
            "end": {
              "line": 25,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "134",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 31,
              "column": 93
            },
            "end": {
              "line": 31,
              "column": 132
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\AssertError.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns success if the Test step returns an error and a failure otherwise.\r\n    /// <" + "/summary>\r\n    public sealed class AssertError : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var result = Test.Run(stateMonad);\r\n\r\n            if (result.IsFailure)\r\n                return Unit.Default;\r\n\r\n            return new RunError(\"Expected an error but step was successful.\", Name, null, ErrorCode.AssertionFailed);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => AssertErrorStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The step to test.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "Unit> Test { get; set; } = null!;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "135",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsFailure)",
          "location": {
            "start": {
              "line": 19,
              "column": 17
            },
            "end": {
              "line": 19,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "136",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 22,
              "column": 33
            },
            "end": {
              "line": 22,
              "column": 77
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\AssertErrorStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns success if the Test step returns an error and a failure otherwise.\r\n    /// <" + "/summary>\r\n    public sealed class AssertErrorStepFactory : SimpleStepFactory<" + "AssertError, Unit>\r\n    {\r\n        private AssertErrorStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "AssertError, Unit> Instance { get; } = new AssertErrorStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\AssertTrue.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns an error if the nested step does not return true.\r\n    /// <" + "/summary>\r\n    public sealed class AssertTrue : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad) =>\r\n            Test.Run(stateMonad).Ensure(x => x,\r\n                new RunError($\"Assertion Failed '{Test.Name}'\", Name, null, ErrorCode.IndexOutOfBounds)).Map(x=> Unit.Default);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => AssertTrueStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The step to test.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Test { get; set; } = null!;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "137",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 17,
              "column": 30
            },
            "end": {
              "line": 17,
              "column": 63
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\AssertTrueStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns an error if the nested step does not return true.\r\n    /// <" + "/summary>\r\n    public sealed class AssertTrueStepFactory : SimpleStepFactory<" + "AssertTrue, Unit>\r\n    {\r\n        private AssertTrueStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "AssertTrue, Unit> Instance { get; } = new AssertTrueStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\BooleanOperator.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// A boolean operator.\r\n    /// <" + "/summary>\r\n    public enum BooleanOperator\r\n    {\r\n        /// <" + "summary>\r\n        /// Sentinel value.\r\n        /// <" + "/summary>\r\n        None,\r\n\r\n        /// <" + "summary>\r\n        /// Returns true if both left and right are true.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"&&\")]\r\n        And,\r\n        /// <" + "summary>\r\n        /// Returns true if either left or right is true.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"||\")]\r\n        Or\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\Compare.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Compares two items.\r\n    /// <" + "/summary>\r\n    public sealed class Compare<" + "T> : CompoundStep<" + "bool> where T : IComparable\r\n    {\r\n        /// <" + "summary>\r\n        /// The item to the left of the operator.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> Left { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The operator to use for comparison.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n\r\n        public IStep<" + "CompareOperator> Operator { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The item to the right of the operator.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> Right { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "bool, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var result = Left.Run(stateMonad)\r\n                .Compose(() => Operator.Run(stateMonad), () => Right.Run(stateMonad))\r\n                .Bind(x => CompareItems(x.Item1, x.Item2, x.Item3));\r\n\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => CompareStepFactory.Instance;\r\n\r\n        private static Result<" + "bool, IRunErrors> CompareItems(T item1, CompareOperator compareOperator, T item2)\r\n        {\r\n            return compareOperator switch\r\n            {\r\n                CompareOperator.Equals => item1.Equals(item2),\r\n                CompareOperator.NotEquals => !item1.Equals(item2),\r\n                CompareOperator.LessThan => item1.CompareTo(item2) <" + " 0,\r\n                CompareOperator.LessThanOrEqual => item1.CompareTo(item2) <" + "= 0,\r\n                CompareOperator.GreaterThan => item1.CompareTo(item2) > 0,\r\n                CompareOperator.GreaterThanOrEqual => item1.CompareTo(item2) >= 0,\r\n                _ => throw new ArgumentOutOfRangeException(nameof(compareOperator), compareOperator, null)\r\n            };\r\n        }\r\n\r\n    }\r\n}",
      "mutants": [
        {
          "id": "138",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "item1.Equals(item2)",
          "location": {
            "start": {
              "line": 57,
              "column": 46
            },
            "end": {
              "line": 57,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "139",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) > 0",
          "location": {
            "start": {
              "line": 58,
              "column": 45
            },
            "end": {
              "line": 58,
              "column": 71
            }
          },
          "status": "Killed"
        },
        {
          "id": "140",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) <" + "= 0",
          "location": {
            "start": {
              "line": 58,
              "column": 45
            },
            "end": {
              "line": 58,
              "column": 71
            }
          },
          "status": "Survived"
        },
        {
          "id": "141",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) > 0",
          "location": {
            "start": {
              "line": 59,
              "column": 52
            },
            "end": {
              "line": 59,
              "column": 79
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "142",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) <" + " 0",
          "location": {
            "start": {
              "line": 59,
              "column": 52
            },
            "end": {
              "line": 59,
              "column": 79
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "143",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) <" + " 0",
          "location": {
            "start": {
              "line": 60,
              "column": 48
            },
            "end": {
              "line": 60,
              "column": 74
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "144",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) >= 0",
          "location": {
            "start": {
              "line": 60,
              "column": 48
            },
            "end": {
              "line": 60,
              "column": 74
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "145",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) <" + " 0",
          "location": {
            "start": {
              "line": 61,
              "column": 55
            },
            "end": {
              "line": 61,
              "column": 82
            }
          },
          "status": "Killed"
        },
        {
          "id": "146",
          "mutatorName": "Equality mutation",
          "replacement": "item1.CompareTo(item2) > 0",
          "location": {
            "start": {
              "line": 61,
              "column": 55
            },
            "end": {
              "line": 61,
              "column": 82
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\CompareOperator.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// An operator to use for comparison.\r\n    /// <" + "/summary>\r\n    public enum CompareOperator\r\n    {\r\n        /// <" + "summary>\r\n        /// Sentinel value.\r\n        /// <" + "/summary>\r\n        None,\r\n#pragma warning disable 1591\r\n        [Display(Name = \"==\")]\r\n        Equals,\r\n\r\n        [Display(Name = \"!=\")]\r\n        NotEquals,\r\n        [Display(Name = \"<" + "\")]\r\n        LessThan,\r\n        [Display(Name = \"<" + "=\")]\r\n        LessThanOrEqual,\r\n        [Display(Name = \">\")]\r\n        GreaterThan,\r\n        [Display(Name = \">=\")]\r\n        GreaterThanOrEqual\r\n#pragma warning restore 1591\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\CompareStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Compares two items.\r\n    /// <" + "/summary>\r\n    public sealed class CompareStepFactory : GenericStepFactory\r\n    {\r\n        private CompareStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static StepFactory Instance { get; } = new CompareStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(Compare<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => new[] {typeof(CompareOperator)};\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Boolean);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new ActualTypeReference(typeof(bool));\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData)\r\n        {\r\n            var result = freezableStepData.GetArgument(nameof(Compare<" + "int>.Left))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .Compose(() => freezableStepData.GetArgument(nameof(Compare<" + "int>.Right))\r\n                    .Bind(x => x.TryGetOutputTypeReference()))\r\n                .Map(x => new[] { x.Item1, x.Item2 })\r\n                .Bind((x) => MultipleTypeReference.TryCreate(x, TypeName));\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"[{nameof(Compare<" + "int>.Left)}] [{nameof(Compare<" + "int>.Operator)}] [{nameof(Compare<" + "int>.Right)}]\");\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer { get; } = new StepSerializer(\r\n            new FixedStringComponent(\"(\"),\r\n            new IntegerComponent(nameof(Compare<" + "int>.Left)),\r\n            new SpaceComponent(),\r\n            new EnumDisplayComponent<" + "CompareOperator>(nameof(Compare<" + "int>.Operator)),\r\n            new SpaceComponent(),\r\n            new IntegerComponent(nameof(Compare<" + "int>.Right)),\r\n            new FixedStringComponent(\")\")\r\n        );\r\n    }\r\n}",
      "mutants": [
        {
          "id": "147",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 48,
              "column": 93
            },
            "end": {
              "line": 48,
              "column": 190
            }
          },
          "status": "Killed"
        },
        {
          "id": "148",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 53,
              "column": 38
            },
            "end": {
              "line": 53,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "149",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 59,
              "column": 38
            },
            "end": {
              "line": 59,
              "column": 41
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\Conditional.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Executes a statement if a condition is true.\r\n    /// <" + "/summary>\r\n    public sealed class Conditional : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var result = Condition.Run(stateMonad)\r\n                .Bind(r =>\r\n                {\r\n                    if (r)\r\n                        return ThenStep.Run(stateMonad);\r\n                    return ElseStep?.Run(stateMonad) ?? Unit.Default;\r\n                });\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ConditionalStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// Whether to follow the Then Branch\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Condition { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The Then Branch.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "Unit> ThenStep { get; set; } = null!;\r\n\r\n        //TODO else if\r\n\r\n        /// <" + "summary>\r\n        /// The Else branch, if it exists.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        public IStep<" + "Unit>? ElseStep { get; set; } = null;\r\n\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "150",
          "mutatorName": "Negate expression",
          "replacement": "!(r)",
          "location": {
            "start": {
              "line": 21,
              "column": 25
            },
            "end": {
              "line": 21,
              "column": 26
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\ConditionalStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Executes a statement if a condition is true.\r\n    /// <" + "/summary>\r\n    public sealed class ConditionalStepFactory : SimpleStepFactory<" + "Conditional, Unit>\r\n    {\r\n        private ConditionalStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static ConditionalStepFactory Instance { get; } = new ConditionalStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"If [{nameof(Conditional.Condition)}] then [{nameof(Conditional.ThenStep)}] else [{nameof(Conditional.ElseStep)}]\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "151",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 19,
              "column": 93
            },
            "end": {
              "line": 19,
              "column": 208
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\CreateDirectory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.IO;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Creates a new directory in the file system.\r\n    /// <" + "/summary>\r\n    public class CreateDirectory : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var pathResult = Path.Run(stateMonad);\r\n            if (pathResult.IsFailure)\r\n                return pathResult.ConvertFailure<" + "Unit>();\r\n\r\n            var path = pathResult.Value;\r\n\r\n\r\n            Maybe<" + "IRunErrors> error;\r\n            try\r\n            {\r\n                Directory.CreateDirectory(path);\r\n                error = Maybe<" + "IRunErrors>.None;\r\n            }\r\n#pragma warning disable CA1031 // Do not catch general exception types\r\n            catch (Exception e)\r\n            {\r\n                error = Maybe<" + "IRunErrors>.From(new RunError(e.Message, Name, null, ErrorCode.ExternalProcessError));\r\n            }\r\n#pragma warning restore CA1031 // Do not catch general exception types\r\n\r\n            if (error.HasValue)\r\n                return Result.Failure<" + "Unit, IRunErrors>(error.Value);\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The path to the directory to create.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Path { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => CreateDirectoryStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "152",
          "mutatorName": "Negate expression",
          "replacement": "!(pathResult.IsFailure)",
          "location": {
            "start": {
              "line": 20,
              "column": 17
            },
            "end": {
              "line": 20,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "153",
          "mutatorName": "Negate expression",
          "replacement": "!(error.HasValue)",
          "location": {
            "start": {
              "line": 39,
              "column": 17
            },
            "end": {
              "line": 39,
              "column": 31
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\CreateDirectoryStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Creates a new directory in the file system.\r\n    /// <" + "/summary>\r\n    public class CreateDirectoryStepFactory : SimpleStepFactory<" + "CreateDirectory, Unit>\r\n    {\r\n        private CreateDirectoryStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "CreateDirectory, Unit> Instance { get; } = new CreateDirectoryStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\DeleteItem.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing System.IO;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Deletes a file or folder from the file system.\r\n    /// <" + "/summary>\r\n    public class DeleteItem : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var pathResult = Path.Run(stateMonad);\r\n            if (pathResult.IsFailure)\r\n                return pathResult.ConvertFailure<" + "Unit>();\r\n\r\n            var path = pathResult.Value;\r\n\r\n\r\n            if (Directory.Exists(path))\r\n            {\r\n                Directory.Delete(path, true);\r\n                stateMonad.Logger.LogInformation($\"Directory '{path}' Deleted.\");\r\n            }\r\n            else if (File.Exists(path))\r\n            {\r\n                File.Delete(path);\r\n                stateMonad.Logger.LogInformation($\"File '{path}' Deleted.\");\r\n            }\r\n            else\r\n                stateMonad.Logger.LogInformation($\"Item '{path}' did not exist.\");\r\n\r\n            return Unit.Default;\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The path to the file or folder to delete.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Path { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => DeleteItemStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "154",
          "mutatorName": "Negate expression",
          "replacement": "!(pathResult.IsFailure)",
          "location": {
            "start": {
              "line": 20,
              "column": 17
            },
            "end": {
              "line": 20,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "155",
          "mutatorName": "Negate expression",
          "replacement": "!(Directory.Exists(path))",
          "location": {
            "start": {
              "line": 26,
              "column": 17
            },
            "end": {
              "line": 26,
              "column": 39
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "156",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 28,
              "column": 40
            },
            "end": {
              "line": 28,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "157",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 29,
              "column": 50
            },
            "end": {
              "line": 29,
              "column": 80
            }
          },
          "status": "Ignored"
        },
        {
          "id": "158",
          "mutatorName": "Negate expression",
          "replacement": "!(File.Exists(path))",
          "location": {
            "start": {
              "line": 31,
              "column": 22
            },
            "end": {
              "line": 31,
              "column": 39
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "159",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 34,
              "column": 50
            },
            "end": {
              "line": 34,
              "column": 75
            }
          },
          "status": "Ignored"
        },
        {
          "id": "160",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 37,
              "column": 50
            },
            "end": {
              "line": 37,
              "column": 81
            }
          },
          "status": "Ignored"
        }
      ]
    },
    "Core\\General\\DeleteItemStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Deletes a file or folder from the file system.\r\n    /// <" + "/summary>\r\n    public class DeleteItemStepFactory : SimpleStepFactory<" + "DeleteItem, Unit>\r\n    {\r\n        private DeleteItemStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "DeleteItem, Unit> Instance { get; } = new DeleteItemStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\DoesFileContain.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.IO;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns whether a file on the file system contains a particular string.\r\n    /// <" + "/summary>\r\n    public class DoesFileContain : CompoundStep<" + "bool>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "bool, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var pathResult = Path.Run(stateMonad);\r\n\r\n            if (pathResult.IsFailure) return pathResult.ConvertFailure<" + "bool>();\r\n\r\n            if (!File.Exists(pathResult.Value))\r\n                return new RunError($\"File '{pathResult.Value}' does not exist\", Name, null,\r\n                    ErrorCode.ExternalProcessError);\r\n\r\n            var textResult = Text.Run(stateMonad);\r\n            if (textResult.IsFailure) return textResult.ConvertFailure<" + "bool>();\r\n\r\n            Maybe<" + "RunError> error;\r\n            string realText;\r\n\r\n            try\r\n            {\r\n                realText = File.ReadAllText(pathResult.Value);\r\n                error = Maybe<" + "RunError>.None;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                realText = \"\";\r\n                error = Maybe<" + "RunError>.From(new RunError(e.Message, Name, null, ErrorCode.ExternalProcessError));\r\n            }\r\n\r\n            if (error.HasValue)\r\n                return error.Value;\r\n\r\n            var r = realText.Contains(textResult.Value);\r\n\r\n            return r;\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The path to the file or folder to check.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Path { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The text to check for.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Text { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => DoesFileContainStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "161",
          "mutatorName": "Negate expression",
          "replacement": "!(pathResult.IsFailure)",
          "location": {
            "start": {
              "line": 20,
              "column": 17
            },
            "end": {
              "line": 20,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "162",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "File.Exists(pathResult.Value)",
          "location": {
            "start": {
              "line": 22,
              "column": 17
            },
            "end": {
              "line": 22,
              "column": 47
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "163",
          "mutatorName": "Negate expression",
          "replacement": "!(!File.Exists(pathResult.Value))",
          "location": {
            "start": {
              "line": 22,
              "column": 17
            },
            "end": {
              "line": 22,
              "column": 47
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "164",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 23,
              "column": 37
            },
            "end": {
              "line": 23,
              "column": 80
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "165",
          "mutatorName": "Negate expression",
          "replacement": "!(textResult.IsFailure)",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "166",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 39,
              "column": 28
            },
            "end": {
              "line": 39,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "167",
          "mutatorName": "Negate expression",
          "replacement": "!(error.HasValue)",
          "location": {
            "start": {
              "line": 43,
              "column": 17
            },
            "end": {
              "line": 43,
              "column": 31
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\DoesFileContainStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns whether a file on the file system contains a particular string.\r\n    /// <" + "/summary>\r\n    public class DoesFileContainStepFactory : SimpleStepFactory<" + "DoesFileContain, bool>\r\n    {\r\n        private DoesFileContainStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "DoesFileContain, bool> Instance { get; } = new DoesFileContainStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ElementAtIndex.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the array element at a particular index.\r\n    /// <" + "/summary>\r\n    public sealed class ElementAtIndex<" + "T> : CompoundStep<" + "T>\r\n    {\r\n        /// <" + "summary>\r\n        /// The array to check.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "T>> Array { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The index to get the element at.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Index { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "T, IRunErrors> Run(StateMonad stateMonad) =>\r\n            Array.Run(stateMonad)\r\n                .Compose(() => Index.Run(stateMonad))\r\n                .Ensure(x => x.Item2 >= 0 && x.Item2 <" + " x.Item1.Count,\r\n                    new RunError( \"Index was out of the range of the array.\", Name, null, ErrorCode.IndexOutOfBounds))\r\n                .Map(x=>x.Item1[x.Item2]);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ElementAtIndexStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "168",
          "mutatorName": "Logical mutation",
          "replacement": "x.Item2 >= 0 || x.Item2 <" + " x.Item1.Count",
          "location": {
            "start": {
              "line": 33,
              "column": 30
            },
            "end": {
              "line": 33,
              "column": 69
            }
          },
          "status": "Survived"
        },
        {
          "id": "169",
          "mutatorName": "Equality mutation",
          "replacement": "x.Item2 <" + " 0 ",
          "location": {
            "start": {
              "line": 33,
              "column": 30
            },
            "end": {
              "line": 33,
              "column": 42
            }
          },
          "status": "Killed"
        },
        {
          "id": "170",
          "mutatorName": "Equality mutation",
          "replacement": "x.Item2 > 0 ",
          "location": {
            "start": {
              "line": 33,
              "column": 30
            },
            "end": {
              "line": 33,
              "column": 42
            }
          },
          "status": "Survived"
        },
        {
          "id": "171",
          "mutatorName": "Equality mutation",
          "replacement": "x.Item2 > x.Item1.Count",
          "location": {
            "start": {
              "line": 33,
              "column": 46
            },
            "end": {
              "line": 33,
              "column": 69
            }
          },
          "status": "Killed"
        },
        {
          "id": "172",
          "mutatorName": "Equality mutation",
          "replacement": "x.Item2 <" + "= x.Item1.Count",
          "location": {
            "start": {
              "line": 33,
              "column": 46
            },
            "end": {
              "line": 33,
              "column": 69
            }
          },
          "status": "Survived"
        },
        {
          "id": "173",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 34,
              "column": 35
            },
            "end": {
              "line": 34,
              "column": 77
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\ElementAtIndexStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the array element at a particular index.\r\n    /// <" + "/summary>\r\n    public sealed class ElementAtIndexStepFactory : GenericStepFactory\r\n    {\r\n        private ElementAtIndexStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new ElementAtIndexStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(ElementAtIndex<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => \"T\";\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => memberTypeReference;\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(ElementAtIndex<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle();\r\n    }\r\n}",
      "mutants": [
        {
          "id": "174",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 24,
              "column": 57
            },
            "end": {
              "line": 24,
              "column": 60
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\FirstIndexOf.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the first instance of substring in a string.\r\n    /// <" + "/summary>\r\n    public sealed class FirstIndexOf : CompoundStep<" + "int>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to check.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The substring to find.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> SubString { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "int, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure) return str.ConvertFailure<" + "int>();\r\n\r\n            var subString = SubString.Run(stateMonad);\r\n            if (subString.IsFailure) return subString.ConvertFailure<" + "int>();\r\n\r\n\r\n            return str.Value.IndexOf(subString.Value, StringComparison.Ordinal);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => FirstIndexOfStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "175",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 32,
              "column": 17
            },
            "end": {
              "line": 32,
              "column": 30
            }
          },
          "status": "Killed"
        },
        {
          "id": "176",
          "mutatorName": "Negate expression",
          "replacement": "!(subString.IsFailure)",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 36
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\FirstIndexOfElement.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the first index of an element in an array.\r\n    /// <" + "/summary>\r\n    /// <" + "typeparam name=\"T\"><" + "/typeparam>\r\n    public sealed class FirstIndexOfElement<" + "T> : CompoundStep<" + "int>\r\n    {\r\n        /// <" + "summary>\r\n        /// The array to check.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "T>> Array { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The element to look for.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> Element { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "int, IRunErrors> Run(StateMonad stateMonad) =>\r\n            Array.Run(stateMonad).Compose(() => Element.Run(stateMonad))\r\n                .Map(x => x.Item1.IndexOf(x.Item2));\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => FirstIndexOfElementStepFactory.Instance;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\FirstIndexOfElementStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the first index of an element in an array.\r\n    /// <" + "/summary>\r\n    public sealed class FirstIndexOfElementStepFactory : GenericStepFactory\r\n    {\r\n        private FirstIndexOfElementStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new FirstIndexOfElementStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(FirstIndexOfElement<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Int32);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new ActualTypeReference(typeof(int));\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(FirstIndexOfElement<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\FirstIndexOfStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the first instance of substring in a string.\r\n    /// <" + "/summary>\r\n    public sealed class FirstIndexOfStepFactory : SimpleStepFactory<" + "FirstIndexOf, int>\r\n    {\r\n        private FirstIndexOfStepFactory() { }\r\n\r\n        public static SimpleStepFactory<" + "FirstIndexOf, int> Instance { get; } = new FirstIndexOfStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"First index of '[{nameof(FirstIndexOf.SubString)}]' in '[{nameof(FirstIndexOf.String)}]'\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "177",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 15,
              "column": 93
            },
            "end": {
              "line": 15,
              "column": 184
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\For.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Do an action for each value of a given variable in a range.\r\n    /// <" + "/summary>\r\n    public sealed class For : CompoundStep<" + "Unit>\r\n    {\r\n\r\n        /// <" + "summary>\r\n        /// The action to perform repeatedly.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "Unit> Action { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The name of the variable to loop over.\r\n        /// <" + "/summary>\r\n        [VariableName]\r\n        [Required]\r\n        public VariableName VariableName { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// The first value of the variable to use.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> From { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The highest value of the variable to use\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> To { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The amount to increment by each iteration.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Increment { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var from = From.Run(stateMonad);\r\n            if (from.IsFailure) return from.ConvertFailure<" + "Unit>();\r\n\r\n            var to = To.Run(stateMonad);\r\n            if (to.IsFailure) return from.ConvertFailure<" + "Unit>();\r\n\r\n            var increment = Increment.Run(stateMonad);\r\n            if (increment.IsFailure) return from.ConvertFailure<" + "Unit>();\r\n\r\n            var currentValue = from.Value;\r\n\r\n            var setResult = stateMonad.SetVariable(VariableName, currentValue);\r\n            if (setResult.IsFailure) return setResult.ConvertFailure<" + "Unit>();\r\n\r\n            while (currentValue <" + "= to.Value)\r\n            {\r\n                var r = Action.Run(stateMonad);\r\n                if (r.IsFailure) return r;\r\n\r\n\r\n                var currentValueResult = stateMonad.GetVariable<" + "int>(VariableName, Name);\r\n                if (currentValueResult.IsFailure) return currentValueResult.ConvertFailure<" + "Unit>();\r\n                currentValue = currentValueResult.Value;\r\n                currentValue += increment.Value;\r\n\r\n                var setResult2 = stateMonad.SetVariable(VariableName, currentValue);\r\n                if (setResult2.IsFailure) return setResult.ConvertFailure<" + "Unit>();\r\n            }\r\n\r\n            return Unit.Default;\r\n\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ForStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "178",
          "mutatorName": "Negate expression",
          "replacement": "!(from.IsFailure)",
          "location": {
            "start": {
              "line": 56,
              "column": 17
            },
            "end": {
              "line": 56,
              "column": 31
            }
          },
          "status": "Killed"
        },
        {
          "id": "179",
          "mutatorName": "Negate expression",
          "replacement": "!(to.IsFailure)",
          "location": {
            "start": {
              "line": 59,
              "column": 17
            },
            "end": {
              "line": 59,
              "column": 29
            }
          },
          "status": "Killed"
        },
        {
          "id": "180",
          "mutatorName": "Negate expression",
          "replacement": "!(increment.IsFailure)",
          "location": {
            "start": {
              "line": 62,
              "column": 17
            },
            "end": {
              "line": 62,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "181",
          "mutatorName": "Negate expression",
          "replacement": "!(setResult.IsFailure)",
          "location": {
            "start": {
              "line": 67,
              "column": 17
            },
            "end": {
              "line": 67,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "182",
          "mutatorName": "Equality mutation",
          "replacement": "currentValue > to.Value",
          "location": {
            "start": {
              "line": 69,
              "column": 20
            },
            "end": {
              "line": 69,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "183",
          "mutatorName": "Equality mutation",
          "replacement": "currentValue <" + " to.Value",
          "location": {
            "start": {
              "line": 69,
              "column": 20
            },
            "end": {
              "line": 69,
              "column": 44
            }
          },
          "status": "Survived"
        },
        {
          "id": "184",
          "mutatorName": "Negate expression",
          "replacement": "!(currentValue <" + "= to.Value)",
          "location": {
            "start": {
              "line": 69,
              "column": 20
            },
            "end": {
              "line": 69,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "185",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsFailure)",
          "location": {
            "start": {
              "line": 72,
              "column": 21
            },
            "end": {
              "line": 72,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "186",
          "mutatorName": "Negate expression",
          "replacement": "!(currentValueResult.IsFailure)",
          "location": {
            "start": {
              "line": 76,
              "column": 21
            },
            "end": {
              "line": 76,
              "column": 49
            }
          },
          "status": "Killed"
        },
        {
          "id": "187",
          "mutatorName": "AddAssignmentExpression to SubtractAssignmentExpression mutation",
          "replacement": "                currentValue -=increment.Value",
          "location": {
            "start": {
              "line": 78,
              "column": 17
            },
            "end": {
              "line": 78,
              "column": 48
            }
          },
          "status": "Timeout"
        },
        {
          "id": "188",
          "mutatorName": "Negate expression",
          "replacement": "!(setResult2.IsFailure)",
          "location": {
            "start": {
              "line": 81,
              "column": 21
            },
            "end": {
              "line": 81,
              "column": 41
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\ForEach.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Do an action for each member of the list.\r\n    /// <" + "/summary>\r\n    public sealed class ForEach<" + "T> : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "summary>\r\n        /// The action to perform repeatedly.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "Unit> Action { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The name of the variable to loop over.\r\n        /// <" + "/summary>\r\n        [VariableName]\r\n        [Required]\r\n        public VariableName VariableName { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// The elements to iterate over.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "T>> Array { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var elements = Array.Run(stateMonad);\r\n            if (elements.IsFailure) return elements.ConvertFailure<" + "Unit>();\r\n\r\n            foreach (var element in elements.Value)\r\n            {\r\n                var setResult = stateMonad.SetVariable(VariableName, element);\r\n                if (setResult.IsFailure) return setResult.ConvertFailure<" + "Unit>();\r\n\r\n                var r = Action.Run(stateMonad);\r\n                if (r.IsFailure) return r;\r\n            }\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ForeachStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "189",
          "mutatorName": "Negate expression",
          "replacement": "!(elements.IsFailure)",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 35
            }
          },
          "status": "Killed"
        },
        {
          "id": "190",
          "mutatorName": "Negate expression",
          "replacement": "!(setResult.IsFailure)",
          "location": {
            "start": {
              "line": 46,
              "column": 21
            },
            "end": {
              "line": 46,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "191",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsFailure)",
          "location": {
            "start": {
              "line": 49,
              "column": 21
            },
            "end": {
              "line": 49,
              "column": 32
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\ForeachStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Do an action for each member of the list.\r\n    /// <" + "/summary>\r\n    public sealed class ForeachStepFactory : GenericStepFactory\r\n    {\r\n        private ForeachStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static StepFactory Instance { get; } = new ForeachStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(ForEach<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new ActualTypeReference(typeof(Unit));\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(ForEach<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Unit);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(ForEach<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle()\r\n                .Map(Maybe<" + "ITypeReference>.From);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Foreach [{nameof(ForEach<" + "object>.VariableName)}] in [{nameof(ForEach<" + "object>.Array)}]; [{nameof(ForEach<" + "object>.Action)}]\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "192",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 47,
              "column": 93
            },
            "end": {
              "line": 47,
              "column": 217
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\ForStepFactory.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Do an action for each value of a given variable in a range.\r\n    /// <" + "/summary>\r\n    public class ForStepFactory : SimpleStepFactory<" + "For, Unit>\r\n    {\r\n        private ForStepFactory() { }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "For, Unit> Instance { get; } = new ForStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"For [{nameof(For.VariableName)}] = [{nameof(For.From)}]; [{nameof(For.VariableName)}] <" + "= [{nameof(For.To)}]; += [{nameof(For.Increment)}]; [{nameof(For.Action)}]\");\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData) => Maybe<" + "ITypeReference>.From(new ActualTypeReference(typeof(int)));\r\n    }\r\n}",
      "mutants": [
        {
          "id": "193",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 21,
              "column": 93
            },
            "end": {
              "line": 21,
              "column": 257
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\GetLetterAtIndex.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the letters that appears at a specific index\r\n    /// <" + "/summary>\r\n    public sealed class GetLetterAtIndex : CompoundStep<" + "string>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to extract a substring from.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The index.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Index { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "string, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var index = Index.Run(stateMonad);\r\n            if (index.IsFailure) return index.ConvertFailure<" + "string>();\r\n\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure) return str;\r\n\r\n            if (index.Value <" + " 0 || index.Value >= str.Value.Length)\r\n                return new RunError(\"Index was outside the bounds of the string\", Name, null, ErrorCode.IndexOutOfBounds);\r\n\r\n            return str.Value[index.Value].ToString();\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => GetLetterAtIndexStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "194",
          "mutatorName": "Negate expression",
          "replacement": "!(index.IsFailure)",
          "location": {
            "start": {
              "line": 32,
              "column": 17
            },
            "end": {
              "line": 32,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "195",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 30
            }
          },
          "status": "Killed"
        },
        {
          "id": "196",
          "mutatorName": "Logical mutation",
          "replacement": "index.Value <" + " 0 && index.Value >= str.Value.Length",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 67
            }
          },
          "status": "Survived"
        },
        {
          "id": "197",
          "mutatorName": "Negate expression",
          "replacement": "!(index.Value <" + " 0 || index.Value >= str.Value.Length)",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 67
            }
          },
          "status": "Killed"
        },
        {
          "id": "198",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value > 0 ",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "199",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value <" + "= 0 ",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 32
            }
          },
          "status": "Survived"
        },
        {
          "id": "200",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value <" + " str.Value.Length",
          "location": {
            "start": {
              "line": 37,
              "column": 36
            },
            "end": {
              "line": 37,
              "column": 67
            }
          },
          "status": "Killed"
        },
        {
          "id": "201",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value > str.Value.Length",
          "location": {
            "start": {
              "line": 37,
              "column": 36
            },
            "end": {
              "line": 37,
              "column": 67
            }
          },
          "status": "Survived"
        },
        {
          "id": "202",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 38,
              "column": 37
            },
            "end": {
              "line": 38,
              "column": 81
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\GetLetterAtIndexStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the letters that appears at a specific index\r\n    /// <" + "/summary>\r\n    public sealed class GetLetterAtIndexStepFactory : SimpleStepFactory<" + "GetLetterAtIndex, string>\r\n    {\r\n        private GetLetterAtIndexStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "GetLetterAtIndex, string> Instance { get; } = new GetLetterAtIndexStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Get character at index '[{nameof(GetLetterAtIndex.Index)}]' in '[{nameof(GetLetterAtIndex.String)}]'\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "203",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 18,
              "column": 93
            },
            "end": {
              "line": 18,
              "column": 196
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\GetSubstring.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets a substring from a string.\r\n    /// <" + "/summary>\r\n    public sealed class GetSubstring : CompoundStep<" + "string>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to extract a substring from.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The index.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Index { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The length of the substring to extract.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Length { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "string, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure) return str;\r\n            var index = Index.Run(stateMonad);\r\n            if (index.IsFailure) return index.ConvertFailure<" + "string>();\r\n            var length = Length.Run(stateMonad);\r\n            if (length.IsFailure) return length.ConvertFailure<" + "string>();\r\n\r\n\r\n            if (index.Value <" + " 0 || index.Value >= str.Value.Length)\r\n                return new RunError(\"Index was outside the bounds of the string\", Name, null, ErrorCode.IndexOutOfBounds);\r\n\r\n            return str.Value.Substring(index.Value, length.Value);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => GetSubstringStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "204",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 39,
              "column": 17
            },
            "end": {
              "line": 39,
              "column": 30
            }
          },
          "status": "Killed"
        },
        {
          "id": "205",
          "mutatorName": "Negate expression",
          "replacement": "!(index.IsFailure)",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "206",
          "mutatorName": "Negate expression",
          "replacement": "!(length.IsFailure)",
          "location": {
            "start": {
              "line": 43,
              "column": 17
            },
            "end": {
              "line": 43,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "207",
          "mutatorName": "Logical mutation",
          "replacement": "index.Value <" + " 0 && index.Value >= str.Value.Length",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 67
            }
          },
          "status": "Survived"
        },
        {
          "id": "208",
          "mutatorName": "Negate expression",
          "replacement": "!(index.Value <" + " 0 || index.Value >= str.Value.Length)",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 67
            }
          },
          "status": "Killed"
        },
        {
          "id": "209",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value > 0 ",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "210",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value <" + "= 0 ",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 32
            }
          },
          "status": "Survived"
        },
        {
          "id": "211",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value <" + " str.Value.Length",
          "location": {
            "start": {
              "line": 46,
              "column": 36
            },
            "end": {
              "line": 46,
              "column": 67
            }
          },
          "status": "Killed"
        },
        {
          "id": "212",
          "mutatorName": "Equality mutation",
          "replacement": "index.Value > str.Value.Length",
          "location": {
            "start": {
              "line": 46,
              "column": 36
            },
            "end": {
              "line": 46,
              "column": 67
            }
          },
          "status": "Survived"
        },
        {
          "id": "213",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 47,
              "column": 37
            },
            "end": {
              "line": 47,
              "column": 81
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\GetSubstringStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets a substring from a string.\r\n    /// <" + "/summary>\r\n    public sealed class GetSubstringStepFactory : SimpleStepFactory<" + "GetSubstring, string>\r\n    {\r\n        private GetSubstringStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "GetSubstring, string> Instance { get; } = new GetSubstringStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\GetVariable.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Gets the value of a named variable.\r\n    /// <" + "/summary>\r\n    public sealed class GetVariable<" + "T> : CompoundStep<" + "T>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "T, IRunErrors> Run(StateMonad stateMonad) => stateMonad.GetVariable<" + "T>(VariableName, Name);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => GetVariableStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the variable to get.\r\n        /// <" + "/summary>\r\n        [VariableName] [Required]\r\n        public VariableName VariableName { get; set; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\GetVariableStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the value of a named variable.\r\n    /// <" + "/summary>\r\n    public class GetVariableStepFactory : GenericStepFactory\r\n    {\r\n        private GetVariableStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The Instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new GetVariableStepFactory();\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"[{nameof(GetVariable<" + "object>.VariableName)}]\");\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(GetVariable<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => memberTypeReference;\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetVariableName(nameof(GetVariable<" + "object>.VariableName))\r\n                .Map(x => new VariableTypeReference(x) as ITypeReference);\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => \"T\";\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer { get; } = new StepSerializer(\r\n            new VariableNameComponent(nameof(GetVariable<" + "object>.VariableName)));\r\n\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Create a freezable GetVariable step.\r\n        /// <" + "/summary>\r\n        public static IFreezableStep CreateFreezable(VariableName variableName)\r\n        {\r\n            var dict = new Dictionary<" + "string, StepMember>\r\n            {\r\n                {nameof(GetVariable<" + "object>.VariableName), new StepMember(variableName)}\r\n            };\r\n\r\n            var fpd = new FreezableStepData(dict);\r\n\r\n            return new CompoundFreezableStep(Instance, fpd, null);\r\n        }\r\n\r\n    }\r\n}",
      "mutants": [
        {
          "id": "214",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 23,
              "column": 93
            },
            "end": {
              "line": 23,
              "column": 140
            }
          },
          "status": "Killed"
        },
        {
          "id": "215",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 38,
              "column": 57
            },
            "end": {
              "line": 38,
              "column": 60
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "216",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>\r\n{}",
          "location": {
            "start": {
              "line": 51,
              "column": 24
            },
            "end": {
              "line": 54,
              "column": 14
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\IncrementVariable.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Increment an integer variable by a particular amount\r\n    /// <" + "/summary>\r\n    public sealed class IncrementVariable : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "summary>\r\n        /// The variable to increment.\r\n        /// <" + "/summary>\r\n        [VariableName]\r\n        [Required]\r\n        public VariableName Variable { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// The amount to increment by.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Amount { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad) =>\r\n            stateMonad.GetVariable<" + "int>(Variable, Name)\r\n                .Compose(() => Amount.Run(stateMonad))\r\n                .Tap(x => stateMonad.SetVariable(Variable, x.Item1 + x.Item2))\r\n                .Map(x => Unit.Default);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => IncrementVariableStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "217",
          "mutatorName": "Arithmetic mutation",
          "replacement": "x.Item1 - x.Item2",
          "location": {
            "start": {
              "line": 32,
              "column": 60
            },
            "end": {
              "line": 32,
              "column": 77
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\IncrementVariableStepFactory.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Increment an integer variable by a particular amount\r\n    /// <" + "/summary>\r\n    public sealed class IncrementVariableStepFactory :SimpleStepFactory<" + "IncrementVariable, int>\r\n    {\r\n        private IncrementVariableStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "IncrementVariable, int> Instance { get; } = new IncrementVariableStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData) => Maybe<" + "ITypeReference>.From(new ActualTypeReference(typeof(int)));\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\JoinStrings.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Join strings with a delimiter.\r\n    /// <" + "/summary>\r\n    public sealed class JoinStrings : CompoundStep<" + "string>\r\n    {\r\n        /// <" + "summary>\r\n        /// The delimiter to use.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Delimiter { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The elements to iterate over.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "string>> List { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "string, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var list = List.Run(stateMonad);\r\n            if (list.IsFailure) return list.ConvertFailure<" + "string>();\r\n\r\n            var delimiter = Delimiter.Run(stateMonad);\r\n            if (delimiter.IsFailure) return delimiter;\r\n\r\n\r\n            var result = string.Join(delimiter.Value, list.Value);\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => JoinStringsStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "218",
          "mutatorName": "Negate expression",
          "replacement": "!(list.IsFailure)",
          "location": {
            "start": {
              "line": 32,
              "column": 17
            },
            "end": {
              "line": 32,
              "column": 31
            }
          },
          "status": "Killed"
        },
        {
          "id": "219",
          "mutatorName": "Negate expression",
          "replacement": "!(delimiter.IsFailure)",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 36
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\JoinStringsStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Join strings with a delimiter.\r\n    /// <" + "/summary>\r\n    public sealed class JoinStringsStepFactory : SimpleStepFactory<" + "JoinStrings, string>\r\n    {\r\n        private JoinStringsStepFactory() { }\r\n\r\n        public static SimpleStepFactory<" + "JoinStrings, string> Instance { get; } = new JoinStringsStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Join [{nameof(JoinStrings.List)}]\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "220",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 15,
              "column": 93
            },
            "end": {
              "line": 15,
              "column": 129
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\LastIndexOf.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the last instance of substring in a string.\r\n    /// <" + "/summary>\r\n    public sealed class LastIndexOf : CompoundStep<" + "int>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to check.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The substring to find.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> SubString { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "int, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure) return str.ConvertFailure<" + "int>();\r\n\r\n            var subString = SubString.Run(stateMonad);\r\n            if (subString.IsFailure) return subString.ConvertFailure<" + "int>();\r\n\r\n\r\n            return str.Value.LastIndexOf(subString.Value, StringComparison.Ordinal);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => LastIndexOfStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "221",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 32,
              "column": 17
            },
            "end": {
              "line": 32,
              "column": 30
            }
          },
          "status": "Killed"
        },
        {
          "id": "222",
          "mutatorName": "Negate expression",
          "replacement": "!(subString.IsFailure)",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 36
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\LastIndexOfStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Gets the last instance of substring in a string.\r\n    /// <" + "/summary>\r\n    public sealed class LastIndexOfStepFactory : SimpleStepFactory<" + "LastIndexOf, int>\r\n    {\r\n        private LastIndexOfStepFactory() { }\r\n\r\n        public static SimpleStepFactory<" + "LastIndexOf, int> Instance { get; } = new LastIndexOfStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Last index of '[{nameof(LastIndexOf.SubString)}]' in '[{nameof(LastIndexOf.String)}]'\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "223",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 15,
              "column": 93
            },
            "end": {
              "line": 15,
              "column": 181
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\LengthOfString.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Calculates the length of the string.\r\n    /// <" + "/summary>\r\n    public sealed class LengthOfString : CompoundStep<" + "int>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to measure the length of.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "int, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure) return str.ConvertFailure<" + "int>();\r\n\r\n            return str.Value.Length;\r\n\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => LengthOfStringStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "224",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 24,
              "column": 17
            },
            "end": {
              "line": 24,
              "column": 30
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\LengthOfStringStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Calculates the length of the string.\r\n    /// <" + "/summary>\r\n    public sealed class LengthOfStringStepFactory : SimpleStepFactory<" + "LengthOfString, int>\r\n    {\r\n        private LengthOfStringStepFactory() { }\r\n\r\n        public static SimpleStepFactory<" + "LengthOfString, int> Instance { get; } = new LengthOfStringStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Length of [{nameof(LengthOfString.String)}]\");\r\n\r\n    }\r\n}",
      "mutants": [
        {
          "id": "225",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 15,
              "column": 93
            },
            "end": {
              "line": 15,
              "column": 139
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\MathOperator.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// An operator that can be applied to two numbers.\r\n    /// <" + "/summary>\r\n    public enum MathOperator\r\n    {\r\n        /// <" + "summary>\r\n        /// Sentinel value\r\n        /// <" + "/summary>\r\n        None,\r\n\r\n        /// <" + "summary>\r\n        /// Add the left and right operands.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"+\")]\r\n        Add,\r\n        /// <" + "summary>\r\n        /// Subtract the right operand from the left.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"-\")]\r\n        Subtract,\r\n        /// <" + "summary>\r\n        /// Multiply the left and right operands.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"*\")]\r\n        Multiply,\r\n        /// <" + "summary>\r\n        /// Divide the left operand by the right.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"/\")]\r\n        Divide,\r\n        /// <" + "summary>\r\n        /// Reduce the left operand modulo the right.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"%\")]\r\n        Modulo,\r\n        /// <" + "summary>\r\n        /// Raise the left operand to the power of the right.\r\n        /// <" + "/summary>\r\n        [Display(Name = \"^\")]\r\n        Power\r\n\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\Not.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Negation of a boolean value.\r\n    /// <" + "/summary>\r\n    public sealed class Not : CompoundStep<" + "bool>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "bool, IRunErrors> Run(StateMonad stateMonad) => Boolean.Run(stateMonad).Map(x => !x);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => NotStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The value to negate.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Boolean { get; set; } = null!;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "226",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "x",
          "location": {
            "start": {
              "line": 15,
              "column": 113
            },
            "end": {
              "line": 15,
              "column": 115
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\NotStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Negation of a boolean value.\r\n    /// <" + "/summary>\r\n    public class NotStepFactory : SimpleStepFactory<" + "Not, bool>\r\n    {\r\n        private NotStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static StepFactory Instance { get; } = new NotStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Not [{nameof(Not.Boolean)}]\");\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer { get; } = new StepSerializer(\r\n            new FixedStringComponent(\"not\"),\r\n            new FixedStringComponent(\"(\"),\r\n            new BooleanComponent(nameof(Not.Boolean)),\r\n            new FixedStringComponent(\")\")\r\n        );\r\n    }\r\n}",
      "mutants": [
        {
          "id": "227",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 19,
              "column": 93
            },
            "end": {
              "line": 19,
              "column": 123
            }
          },
          "status": "Killed"
        },
        {
          "id": "228",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 23,
              "column": 38
            },
            "end": {
              "line": 23,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "229",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 24,
              "column": 38
            },
            "end": {
              "line": 24,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "230",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 26,
              "column": 38
            },
            "end": {
              "line": 26,
              "column": 41
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\Print.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Prints a value to the log.\r\n    /// <" + "/summary>\r\n    public sealed class Print<" + "T> : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var r = Value.Run(stateMonad);\r\n            if (r.IsFailure) return r.ConvertFailure<" + "Unit>();\r\n\r\n            stateMonad.Logger.LogInformation(r.Value?.ToString());\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The Value to Print.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> Value { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => PrintStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "231",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsFailure)",
          "location": {
            "start": {
              "line": 19,
              "column": 17
            },
            "end": {
              "line": 19,
              "column": 28
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\PrintStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Prints a value to the log.\r\n    /// <" + "/summary>\r\n    public sealed class PrintStepFactory : GenericStepFactory\r\n    {\r\n        private PrintStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new PrintStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(Print<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new ActualTypeReference(typeof(Unit));\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder { get; } = new StepNameBuilderFromTemplate($\"Print [{nameof(Print<" + "object>.Value)}]\");\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Unit);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(Print<" + "object>.Value))\r\n                .Bind(x => x.TryGetOutputTypeReference());\r\n\r\n    }\r\n}",
      "mutants": [
        {
          "id": "232",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 27,
              "column": 101
            },
            "end": {
              "line": 27,
              "column": 141
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\General\\ReadCsv.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Data;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Extracts elements from a CSV file\r\n    /// <" + "/summary>\r\n    public sealed class ReadCsv : CompoundStep<" + "List<" + "List<" + "string>>>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "List<" + "List<" + "string>>, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var textResult = Text.Run(stateMonad);\r\n            if (textResult.IsFailure) return textResult.ConvertFailure<" + "List<" + "List<" + "string>>>();\r\n\r\n            var delimiterResult = Delimiter.Run(stateMonad);\r\n            if (delimiterResult.IsFailure) return delimiterResult.ConvertFailure<" + "List<" + "List<" + "string>>>();\r\n\r\n            string? commentToken;\r\n\r\n            if (CommentToken == null)\r\n                commentToken = null;\r\n            else\r\n            {\r\n                var commentTokenResult = CommentToken.Run(stateMonad);\r\n                if (commentTokenResult.IsFailure) return commentTokenResult.ConvertFailure<" + "List<" + "List<" + "string>>>();\r\n                commentToken = commentTokenResult.Value;\r\n            }\r\n\r\n            var fieldsEnclosedInQuotesResult = HasFieldsEnclosedInQuotes.Run(stateMonad);\r\n            if (fieldsEnclosedInQuotesResult.IsFailure) return fieldsEnclosedInQuotesResult.ConvertFailure<" + "List<" + "List<" + "string>>>();\r\n\r\n            var columnsToMapResult = ColumnsToMap.Run(stateMonad);\r\n            if (columnsToMapResult.IsFailure) return columnsToMapResult.ConvertFailure<" + "List<" + "List<" + "string>>>();\r\n\r\n\r\n            var dataTableResult = CsvReader.TryReadCSVFromString(textResult.Value, delimiterResult.Value, commentToken,\r\n                fieldsEnclosedInQuotesResult.Value);\r\n\r\n            if (dataTableResult.IsFailure) return dataTableResult\r\n                .MapFailure(x=> new RunError(x, nameof(RunExternalProcess), null, ErrorCode.CSVError) as IRunErrors)\r\n                .ConvertFailure<" + "List<" + "List<" + "string>>>();\r\n\r\n            var missingColumnsErrors = columnsToMapResult.Value\r\n                .Where(x => !dataTableResult.Value.Columns.Contains(x))\r\n                .Select(x=> new RunError($\"Missing Column: '{x}'\", nameof(ReadCsv), null, ErrorCode.CSVError))\r\n                .ToList();\r\n\r\n            if (missingColumnsErrors.Any())\r\n                return new RunErrorList(missingColumnsErrors);\r\n\r\n            var results = new List<" + "List<" + "string>>();\r\n\r\n            foreach (DataRow row in dataTableResult.Value.Rows.Cast<" + "DataRow>())\r\n            {\r\n                var result = new List<" + "string>();\r\n\r\n                foreach (var columnName in columnsToMapResult.Value)\r\n                {\r\n                    var current = row[columnName, DataRowVersion.Default];\r\n\r\n                    result.Add(current.ToString()!);\r\n                }\r\n\r\n                results.Add(result);\r\n            }\r\n\r\n            return results;\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The text of the CSV file.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 1)]\r\n        [Required]\r\n        public IStep<" + "string> Text { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The delimiter to use to separate rows.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 2)]\r\n        [Required]\r\n        [DefaultValueExplanation(\",\")]\r\n        public IStep<" + "string> Delimiter { get; set; } = new Constant<" + "string>(\",\");\r\n\r\n        /// <" + "summary>\r\n        /// The token to use to indicate comments.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 3)]\r\n        public IStep<" + "string>? CommentToken { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Whether CSV fields are enclosed in quotes.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 4)]\r\n        [DefaultValueExplanation(\"false\")]\r\n        [Required]\r\n        public IStep<" + "bool> HasFieldsEnclosedInQuotes { get; set; } = new Constant<" + "bool>(false);\r\n\r\n        /// <" + "summary>\r\n        /// The csv columns to map to result columns, in order.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 5)]\r\n        [Required]\r\n        public IStep<" + "List<" + "string>> ColumnsToMap { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ReadCsvStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "233",
          "mutatorName": "Negate expression",
          "replacement": "!(textResult.IsFailure)",
          "location": {
            "start": {
              "line": 21,
              "column": 17
            },
            "end": {
              "line": 21,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "234",
          "mutatorName": "Negate expression",
          "replacement": "!(delimiterResult.IsFailure)",
          "location": {
            "start": {
              "line": 24,
              "column": 17
            },
            "end": {
              "line": 24,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "235",
          "mutatorName": "Equality mutation",
          "replacement": "CommentToken != null",
          "location": {
            "start": {
              "line": 28,
              "column": 17
            },
            "end": {
              "line": 28,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "236",
          "mutatorName": "Negate expression",
          "replacement": "!(CommentToken == null)",
          "location": {
            "start": {
              "line": 28,
              "column": 17
            },
            "end": {
              "line": 28,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "237",
          "mutatorName": "Negate expression",
          "replacement": "!(commentTokenResult.IsFailure)",
          "location": {
            "start": {
              "line": 33,
              "column": 21
            },
            "end": {
              "line": 33,
              "column": 49
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "238",
          "mutatorName": "Negate expression",
          "replacement": "!(fieldsEnclosedInQuotesResult.IsFailure)",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 55
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "239",
          "mutatorName": "Negate expression",
          "replacement": "!(columnsToMapResult.IsFailure)",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 45
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "240",
          "mutatorName": "Negate expression",
          "replacement": "!(dataTableResult.IsFailure)",
          "location": {
            "start": {
              "line": 47,
              "column": 17
            },
            "end": {
              "line": 47,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "241",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "dataTableResult.Value.Columns.Contains(x)",
          "location": {
            "start": {
              "line": 52,
              "column": 29
            },
            "end": {
              "line": 52,
              "column": 71
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "242",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 53,
              "column": 42
            },
            "end": {
              "line": 53,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "243",
          "mutatorName": "Negate expression",
          "replacement": "!(missingColumnsErrors.Any())",
          "location": {
            "start": {
              "line": 56,
              "column": 17
            },
            "end": {
              "line": 56,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "244",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 92,
              "column": 77
            },
            "end": {
              "line": 92,
              "column": 80
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "245",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 106,
              "column": 89
            },
            "end": {
              "line": 106,
              "column": 94
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\ReadCsvStepFactory.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Extracts elements from a CSV file\r\n    /// <" + "/summary>\r\n    public sealed class ReadCsvStepFactory : SimpleStepFactory<" + "ReadCsv, List<" + "List<" + "string>>>\r\n    {\r\n        private ReadCsvStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "ReadCsv, List<" + "List<" + "string>>> Instance { get; } = new ReadCsvStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ReadFile.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.IO;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Reads text from a file.\r\n    /// <" + "/summary>\r\n    public sealed class ReadFile : CompoundStep<" + "string>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "string, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var data = Folder.Run(stateMonad).Compose(() => FileName.Run(stateMonad));\r\n\r\n            if (data.IsFailure)\r\n                return data.ConvertFailure<" + "string>();\r\n\r\n\r\n            var path = Path.Combine(data.Value.Item1, data.Value.Item2);\r\n\r\n            Result<" + "string, IRunErrors> result;\r\n            try\r\n            {\r\n                result = File.ReadAllText(path);\r\n            }\r\n#pragma warning disable CA1031 // Do not catch general exception types\r\n            catch (Exception e)\r\n            {\r\n                result = new RunError(e.Message, Name, null, ErrorCode.ExternalProcessError);\r\n            }\r\n#pragma warning restore CA1031 // Do not catch general exception types\r\n\r\n            return result;\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The name of the folder.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Folder { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the file to write to.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> FileName { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ReadFileStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "246",
          "mutatorName": "Negate expression",
          "replacement": "!(data.IsFailure)",
          "location": {
            "start": {
              "line": 21,
              "column": 17
            },
            "end": {
              "line": 21,
              "column": 31
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\ReadFileStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Reads text from a file.\r\n    /// <" + "/summary>\r\n    public sealed class ReadFileStepFactory : SimpleStepFactory<" + "ReadFile, string>\r\n    {\r\n        private ReadFileStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "ReadFile, string> Instance { get; } = new ReadFileStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\Repeat.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Creates an array by repeating an element.\r\n    /// <" + "/summary>\r\n    public sealed class Repeat<" + "T> : CompoundStep<" + "List<" + "T>>\r\n    {\r\n        /// <" + "summary>\r\n        /// The element to repeat.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> Element { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The number of times to repeat the element\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Number { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "List<" + "T>, IRunErrors> Run(StateMonad stateMonad) =>\r\n            Element.Run(stateMonad).Compose(() => Number.Run(stateMonad))\r\n                .Map(x => Enumerable.Repeat(x.Item1, x.Item2).ToList());\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => RepeatStepFactory.Instance;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\RepeatStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Creates an array by repeating an element.\r\n    /// <" + "/summary>\r\n    public sealed class RepeatStepFactory : GenericStepFactory\r\n    {\r\n        private RepeatStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new RepeatStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(Repeat<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => \"List<" + "T>\";\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new GenericTypeReference(typeof(List<" + ">), new []{memberTypeReference});\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(Repeat<" + "object>.Element))\r\n                .Bind(x => x.TryGetOutputTypeReference());\r\n    }\r\n}",
      "mutants": [
        {
          "id": "247",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 24,
              "column": 57
            },
            "end": {
              "line": 24,
              "column": 66
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\RepeatWhile.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Repeat an action while the condition is met.\r\n    /// <" + "/summary>\r\n    public sealed class RepeatWhile : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            while (true)\r\n            {\r\n                var conditionResult = Condition.Run(stateMonad);\r\n                if (conditionResult.IsFailure) return conditionResult.ConvertFailure<" + "Unit>();\r\n\r\n                if (conditionResult.Value)\r\n                {\r\n                    var actionResult = Action.Run(stateMonad);\r\n                    if (actionResult.IsFailure) return actionResult.ConvertFailure<" + "Unit>();\r\n                }\r\n                else break;\r\n            }\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The condition to check before performing the action.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Condition { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The action to perform repeatedly.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "Unit> Action { get; set; } = null!;\r\n\r\n\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => RepeatWhileStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "248",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 18,
              "column": 20
            },
            "end": {
              "line": 18,
              "column": 24
            }
          },
          "status": "Killed"
        },
        {
          "id": "249",
          "mutatorName": "Negate expression",
          "replacement": "!(true)",
          "location": {
            "start": {
              "line": 18,
              "column": 20
            },
            "end": {
              "line": 18,
              "column": 24
            }
          },
          "status": "Killed"
        },
        {
          "id": "250",
          "mutatorName": "Negate expression",
          "replacement": "!(conditionResult.IsFailure)",
          "location": {
            "start": {
              "line": 21,
              "column": 21
            },
            "end": {
              "line": 21,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "251",
          "mutatorName": "Negate expression",
          "replacement": "!(conditionResult.Value)",
          "location": {
            "start": {
              "line": 23,
              "column": 21
            },
            "end": {
              "line": 23,
              "column": 42
            }
          },
          "status": "Killed"
        },
        {
          "id": "252",
          "mutatorName": "Negate expression",
          "replacement": "!(actionResult.IsFailure)",
          "location": {
            "start": {
              "line": 26,
              "column": 25
            },
            "end": {
              "line": 26,
              "column": 47
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\RepeatWhileStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Repeat an action while the condition is met.\r\n    /// <" + "/summary>\r\n    public sealed class RepeatWhileStepFactory : SimpleStepFactory<" + "RepeatWhile, Unit>\r\n    {\r\n        private RepeatWhileStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "RepeatWhile, Unit> Instance { get; } = new RepeatWhileStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Repeat '[{nameof(RepeatWhile.Action)}]' while '[{nameof(RepeatWhile.Condition)}]'\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "253",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 19,
              "column": 93
            },
            "end": {
              "line": 19,
              "column": 177
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\RepeatXTimes.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Repeat a step a set number of times.\r\n    /// <" + "/summary>\r\n    public sealed class RepeatXTimes : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "summary>\r\n        /// The action to perform repeatedly.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "Unit> Action { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The number of times to perform the action.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "int> Number { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var numberResult = Number.Run(stateMonad);\r\n\r\n            if (numberResult.IsFailure) return numberResult.ConvertFailure<" + "Unit>();\r\n\r\n            for (var i = 0; i <" + " numberResult.Value; i++)\r\n            {\r\n                var result = Action.Run(stateMonad);\r\n                if (result.IsFailure) return result.ConvertFailure<" + "Unit>();\r\n            }\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => RepeatXTimesStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "254",
          "mutatorName": "Negate expression",
          "replacement": "!(numberResult.IsFailure)",
          "location": {
            "start": {
              "line": 33,
              "column": 17
            },
            "end": {
              "line": 33,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "255",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "i--",
          "location": {
            "start": {
              "line": 35,
              "column": 53
            },
            "end": {
              "line": 35,
              "column": 56
            }
          },
          "status": "Killed"
        },
        {
          "id": "256",
          "mutatorName": "Equality mutation",
          "replacement": "i > numberResult.Value",
          "location": {
            "start": {
              "line": 35,
              "column": 29
            },
            "end": {
              "line": 35,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "257",
          "mutatorName": "Equality mutation",
          "replacement": "i <" + "= numberResult.Value",
          "location": {
            "start": {
              "line": 35,
              "column": 29
            },
            "end": {
              "line": 35,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "258",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsFailure)",
          "location": {
            "start": {
              "line": 5,
              "column": 21
            },
            "end": {
              "line": 5,
              "column": 37
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\RepeatXTimesStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Repeat a step a set number of times.\r\n    /// <" + "/summary>\r\n    public sealed class RepeatXTimesStepFactory : SimpleStepFactory<" + "RepeatXTimes, Unit>\r\n    {\r\n        private RepeatXTimesStepFactory() { }\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "RepeatXTimes, Unit> Instance { get; } = new RepeatXTimesStepFactory();\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"Repeat '[{nameof(RepeatXTimes.Action)}]' '[{nameof(RepeatXTimes.Number)}]' times.\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "259",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 19,
              "column": 93
            },
            "end": {
              "line": 19,
              "column": 177
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\RunExternalProcess.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Runs an external executable program.\r\n    /// <" + "/summary>\r\n    public sealed class RunExternalProcess : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var pathResult = ProcessPath.Run(stateMonad);\r\n            if (pathResult.IsFailure) return pathResult.ConvertFailure<" + "Unit>();\r\n\r\n            List<" + "string> arguments;\r\n\r\n            if(Arguments == null)\r\n                arguments = new List<" + "string>();\r\n            else\r\n            {\r\n                var argsResult = Arguments.Run(stateMonad);\r\n\r\n                if (argsResult.IsFailure) return argsResult.ConvertFailure<" + "Unit>();\r\n                arguments = argsResult.Value;\r\n            }\r\n\r\n            var r =\r\n                stateMonad.ExternalProcessRunner.RunExternalProcess(pathResult.Value,\r\n                    stateMonad.Logger,\r\n                    nameof(RunExternalProcess),\r\n                    IgnoreNoneErrorHandler.Instance,\r\n                    arguments).Result;\r\n\r\n            return r;\r\n        }\r\n\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The path to the external process\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 1)]\r\n        [Required]\r\n        public IStep<" + "string> ProcessPath { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// Arguments to the step.\r\n        /// <" + "/summary>\r\n        [StepProperty(Order = 2)]\r\n        public IStep<" + "List<" + "string>>? Arguments { get; set; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => RunExternalProcessStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "260",
          "mutatorName": "Negate expression",
          "replacement": "!(pathResult.IsFailure)",
          "location": {
            "start": {
              "line": 19,
              "column": 17
            },
            "end": {
              "line": 19,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "261",
          "mutatorName": "Equality mutation",
          "replacement": "Arguments != null",
          "location": {
            "start": {
              "line": 23,
              "column": 16
            },
            "end": {
              "line": 23,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "262",
          "mutatorName": "Negate expression",
          "replacement": "!(Arguments == null)",
          "location": {
            "start": {
              "line": 23,
              "column": 16
            },
            "end": {
              "line": 23,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "263",
          "mutatorName": "Negate expression",
          "replacement": "!(argsResult.IsFailure)",
          "location": {
            "start": {
              "line": 29,
              "column": 21
            },
            "end": {
              "line": 29,
              "column": 41
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\RunExternalProcessStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Runs an external executable program.\r\n    /// <" + "/summary>\r\n    public sealed class RunExternalProcessStepFactory : SimpleStepFactory<" + "RunExternalProcess, Unit>\r\n    {\r\n        private RunExternalProcessStepFactory() {}\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "RunExternalProcess, Unit> Instance { get; } = new RunExternalProcessStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\Sequence.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// A sequence of steps to be run one after the other.\r\n    /// <" + "/summary>\r\n    public sealed class Sequence : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var remainingSteps = new Stack<" + "IStep<" + "Unit>>(Steps.Reverse());\r\n\r\n            while (remainingSteps.TryPop(out var step))\r\n            {\r\n                if (step.StepCombiners.Any() && remainingSteps.TryPop(out var nextStep))\r\n                {\r\n                    var combined = false;\r\n                    foreach (var stepCombiner in step.StepCombiners)\r\n                    {\r\n                        var combineResult = stepCombiner.TryCombine(step, nextStep);\r\n                        if (combineResult.IsSuccess)\r\n                        {\r\n                            remainingSteps.Push(combineResult.Value);\r\n                            combined = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(!combined)\r\n                        remainingSteps.Push(nextStep); //put it back\r\n                    else\r\n                        continue; //try combining the combined result\r\n\r\n                }\r\n\r\n                var r = step.Run(stateMonad);\r\n                if (r.IsFailure)\r\n                    return r.ConvertFailure<" + "Unit>();\r\n\r\n            }\r\n\r\n            return Unit.Default;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => SequenceStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The steps of this sequence.\r\n        /// <" + "/summary>\r\n        [StepListProperty]\r\n        [Required]\r\n        public IReadOnlyList<" + "IStep<" + "Unit>> Steps { get; set; } = null!;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "264",
          "mutatorName": "Linq method mutation (Reverse() to AsEnumerable())",
          "replacement": "Steps.AsEnumerable()",
          "location": {
            "start": {
              "line": 19,
              "column": 57
            },
            "end": {
              "line": 19,
              "column": 72
            }
          },
          "status": "Killed"
        },
        {
          "id": "265",
          "mutatorName": "Negate expression",
          "replacement": "!(remainingSteps.TryPop(out var step))",
          "location": {
            "start": {
              "line": 21,
              "column": 20
            },
            "end": {
              "line": 21,
              "column": 55
            }
          },
          "status": "Killed"
        },
        {
          "id": "266",
          "mutatorName": "Logical mutation",
          "replacement": "step.StepCombiners.Any() || remainingSteps.TryPop(out var nextStep)",
          "location": {
            "start": {
              "line": 23,
              "column": 21
            },
            "end": {
              "line": 23,
              "column": 88
            }
          },
          "status": "CompileError"
        },
        {
          "id": "267",
          "mutatorName": "Negate expression",
          "replacement": "!(step.StepCombiners.Any() && remainingSteps.TryPop(out var nextStep))",
          "location": {
            "start": {
              "line": 23,
              "column": 21
            },
            "end": {
              "line": 23,
              "column": 88
            }
          },
          "status": "CompileError"
        },
        {
          "id": "268",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 25,
              "column": 36
            },
            "end": {
              "line": 25,
              "column": 41
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "269",
          "mutatorName": "Negate expression",
          "replacement": "!(combineResult.IsSuccess)",
          "location": {
            "start": {
              "line": 29,
              "column": 29
            },
            "end": {
              "line": 29,
              "column": 52
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "270",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 32,
              "column": 40
            },
            "end": {
              "line": 32,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "271",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "combined",
          "location": {
            "start": {
              "line": 37,
              "column": 24
            },
            "end": {
              "line": 37,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "272",
          "mutatorName": "Negate expression",
          "replacement": "!(!combined)",
          "location": {
            "start": {
              "line": 37,
              "column": 24
            },
            "end": {
              "line": 37,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "273",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsFailure)",
          "location": {
            "start": {
              "line": 45,
              "column": 21
            },
            "end": {
              "line": 45,
              "column": 32
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\SequenceStepFactory.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Linq;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// A sequence of steps to be run one after the other.\r\n    /// <" + "/summary>\r\n    public sealed class SequenceStepFactory : SimpleStepFactory<" + "Sequence, Unit>\r\n    {\r\n        private SequenceStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static StepFactory Instance { get; } = new SequenceStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"[{nameof(Sequence.Steps)}]\");\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer => NoSpecialSerializer.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// Create a new Freezable Sequence\r\n        /// <" + "/summary>\r\n        public static IFreezableStep CreateFreezable(IEnumerable<" + "IFreezableStep> steps, Configuration? configuration)\r\n        {\r\n            var fpd = new FreezableStepData(new Dictionary<" + "string, StepMember>()\r\n            {\r\n                {nameof(Sequence.Steps), new StepMember(steps.ToList())}\r\n            });\r\n\r\n            return new CompoundFreezableStep(Instance, fpd, configuration);\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "274",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 22,
              "column": 93
            },
            "end": {
              "line": 22,
              "column": 122
            }
          },
          "status": "Killed"
        },
        {
          "id": "275",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>()\r\n{}",
          "location": {
            "start": {
              "line": 33,
              "column": 45
            },
            "end": {
              "line": 36,
              "column": 14
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\SetVariable.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Gets the value of a named variable.\r\n    /// <" + "/summary>\r\n    public sealed class SetVariable<" + "T> : CompoundStep<" + "Unit>\r\n    {\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad) =>\r\n            Value.Run(stateMonad)\r\n                .Bind(x => stateMonad.SetVariable(VariableName, x));\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => SetVariableStepFactory.Instance;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the variable to set.\r\n        /// <" + "/summary>\r\n        [VariableName]\r\n        [Required]\r\n        public VariableName VariableName { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// The value to set the variable to.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> Value { get; set; } = null!;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\SetVariableStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Serialization;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Sets the value of a named variable.\r\n    /// <" + "/summary>\r\n    public class SetVariableStepFactory : StepFactory\r\n    {\r\n        private SetVariableStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static StepFactory Instance { get; } = new SetVariableStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "ITypeReference> TryGetOutputTypeReference(FreezableStepData freezableStepData) => new ActualTypeReference(typeof(Unit));\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(SetVariable<" + ">);\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"[{nameof(SetVariable<" + "object>.VariableName)}] = [{nameof(SetVariable<" + "object>.Value)}]\");\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => ImmutableArray<" + "Type>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => nameof(Unit);\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData)\r\n        {\r\n            var result = freezableStepData.GetArgument(nameof(SetVariable<" + "object>.Value))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .Map(Maybe<" + "ITypeReference>.From);\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ICompoundStep> TryCreateInstance(StepContext stepContext, FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetVariableName(nameof(SetVariable<" + "object>.VariableName))\r\n                .Bind(x => stepContext.TryGetTypeFromReference(new VariableTypeReference(x)))\r\n                .Bind(x => TryCreateGeneric(typeof(SetVariable<" + ">), x));\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepSerializer Serializer { get; } = new StepSerializer(\r\n            new VariableNameComponent(nameof(SetVariable<" + "object>.VariableName)),\r\n            new SpaceComponent(),\r\n            new FixedStringComponent(\"=\"),\r\n            new SpaceComponent(),\r\n            new AnyPrimitiveComponent(nameof(SetVariable<" + "object>.Value))\r\n        );\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Create a freezable SetVariable step.\r\n        /// <" + "/summary>\r\n        public static IFreezableStep CreateFreezable(VariableName variableName, IFreezableStep value)\r\n        {\r\n            var dict = new Dictionary<" + "string, StepMember>\r\n            {\r\n                {nameof(SetVariable<" + "object>.VariableName), new StepMember(variableName)},\r\n                {nameof(SetVariable<" + "object>.Value), new StepMember(value)}\r\n            };\r\n\r\n            var fpd = new FreezableStepData(dict);\r\n\r\n            return new CompoundFreezableStep(Instance, fpd, null);\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "276",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 31,
              "column": 93
            },
            "end": {
              "line": 31,
              "column": 180
            }
          },
          "status": "Killed"
        },
        {
          "id": "277",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 61,
              "column": 38
            },
            "end": {
              "line": 61,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "278",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>\r\n{}",
          "location": {
            "start": {
              "line": 72,
              "column": 24
            },
            "end": {
              "line": 76,
              "column": 14
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\SortArray.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Reorder an array.\r\n    /// <" + "/summary>\r\n    public sealed class SortArray<" + "T> : CompoundStep<" + "List<" + "T>>\r\n    {\r\n        /// <" + "summary>\r\n        /// The array to modify.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "List<" + "T>> Array { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The order to use.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "SortOrder> Order { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "List<" + "T>, IRunErrors> Run(StateMonad stateMonad) =>\r\n            Array.Run(stateMonad)\r\n                .Compose(() => Order.Run(stateMonad))\r\n                .Map(x => Sort(x.Item1, x.Item2));\r\n\r\n        private static List<" + "T> Sort(IEnumerable<" + "T> list, SortOrder sortOrder) =>\r\n            sortOrder switch\r\n            {\r\n                SortOrder.Ascending => list.OrderBy(x => x).ToList(),\r\n                SortOrder.Descending => list.OrderByDescending(x => x).ToList(),\r\n                _ => throw new ArgumentOutOfRangeException(nameof(sortOrder), sortOrder, null)\r\n            };\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => SortArrayStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "279",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "list.OrderByDescending(x => x).ToList()",
          "location": {
            "start": {
              "line": 40,
              "column": 40
            },
            "end": {
              "line": 40,
              "column": 69
            }
          },
          "status": "Killed"
        },
        {
          "id": "280",
          "mutatorName": "Linq method mutation (OrderByDescending() to OrderBy())",
          "replacement": "list.OrderBy(x => x).ToList()",
          "location": {
            "start": {
              "line": 41,
              "column": 41
            },
            "end": {
              "line": 41,
              "column": 80
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\SortArrayStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Reorder an array.\r\n    /// <" + "/summary>\r\n\r\n    public sealed class SortArrayStepFactory : GenericStepFactory\r\n    {\r\n        private SortArrayStepFactory() { }\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new SortArrayStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(SortArray<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => new GenericTypeReference(typeof(List<" + ">), new []{memberTypeReference});\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => new[] {typeof(SortOrder)};\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => \"List<" + "T>\";\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(SortArray<" + "object>.Array))\r\n                .Bind(x => x.TryGetOutputTypeReference())\r\n                .BindCast<" + "ITypeReference, GenericTypeReference>()\r\n                .Map(x => x.ChildTypes)\r\n                .BindSingle();\r\n    }\r\n}",
      "mutants": [
        {
          "id": "281",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 31,
              "column": 57
            },
            "end": {
              "line": 31,
              "column": 66
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\SortOrder.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// The direction to sort by.\r\n    /// <" + "/summary>\r\n    public enum SortOrder\r\n    {\r\n        /// <" + "summary>\r\n        /// Sort array elements in ascending, or alphabetical order.\r\n        /// <" + "/summary>\r\n        Ascending,\r\n        /// <" + "summary>\r\n        /// Sort array elements in descending, or reverse-alphabetical order.\r\n        /// <" + "/summary>\r\n        Descending\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\SplitString.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Splits a string.\r\n    /// <" + "/summary>\r\n    public sealed class SplitString : CompoundStep<" + "List<" + "string>>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to split.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The delimiter to use.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Delimiter { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "List<" + "string>, IRunErrors> Run(StateMonad stateMonad) =>\r\n            String.Run(stateMonad).Compose(() => Delimiter.Run(stateMonad))\r\n                .Map(x => x.Item1.Split(new[] {x.Item2}, StringSplitOptions.None).ToList());\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => SplitStringStepFactory.Instance;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\SplitStringStepFactory.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Splits a string.\r\n    /// <" + "/summary>\r\n    public class SplitStringStepFactory : SimpleStepFactory<" + "SplitString, List<" + "string>>\r\n    {\r\n        private SplitStringStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "SplitString, List<" + "string>> Instance { get; } = new SplitStringStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\StringIsEmpty.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns whether a string is empty.\r\n    /// <" + "/summary>\r\n    public sealed class StringIsEmpty : CompoundStep<" + "bool>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "bool, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var str = String.Run(stateMonad);\r\n            if (str.IsFailure) return str.ConvertFailure<" + "bool>();\r\n\r\n            return string.IsNullOrWhiteSpace(str.Value);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The string to check for being empty.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => StringIsEmptyStepFactory.Instance;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "282",
          "mutatorName": "Negate expression",
          "replacement": "!(str.IsFailure)",
          "location": {
            "start": {
              "line": 17,
              "column": 17
            },
            "end": {
              "line": 17,
              "column": 30
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\StringIsEmptyStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns whether a string is empty.\r\n    /// <" + "/summary>\r\n    public sealed class StringIsEmptyStepFactory : SimpleStepFactory<" + "StringIsEmpty, bool>\r\n    {\r\n        private StringIsEmptyStepFactory() { }\r\n\r\n        public static SimpleStepFactory<" + "StringIsEmpty, bool> Instance { get; } = new StringIsEmptyStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new StepNameBuilderFromTemplate($\"'[{nameof(LengthOfString.String)}]' is empty?\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "283",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 15,
              "column": 93
            },
            "end": {
              "line": 15,
              "column": 141
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\Test.cs": {
      "language": "cs",
      "source": "using System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns one result if a condition is true and another if the condition is false.\r\n    /// <" + "/summary>\r\n    public sealed class Test<" + "T> : CompoundStep<" + "T>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "T, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var result = Condition.Run(stateMonad)\r\n                .Bind(r => r ? ThenValue.Run(stateMonad) : ElseValue.Run(stateMonad));\r\n\r\n            return result;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => TestStepFactory.Instance;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Whether to follow the Then Branch\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "bool> Condition { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The Then Branch.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "T> ThenValue { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The Else branch, if it exists.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        public IStep<" + "T> ElseValue { get; set; } = null!;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "284",
          "mutatorName": "Negate expression",
          "replacement": "!(r )",
          "location": {
            "start": {
              "line": 17,
              "column": 28
            },
            "end": {
              "line": 17,
              "column": 29
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\General\\TestStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Returns one result if a condition is true and another if the condition is false.\r\n    /// <" + "/summary>\r\n    public sealed class TestStepFactory : GenericStepFactory\r\n    {\r\n        private TestStepFactory() { }\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static GenericStepFactory Instance { get; } = new TestStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(Test<" + ">);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => \"T\";\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference) => memberTypeReference;\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData) =>\r\n            freezableStepData.GetArgument(nameof(Test<" + "object>.ThenValue))\r\n                .Compose(() => freezableStepData.GetArgument(nameof(Test<" + "object>.ElseValue)))\r\n                .Bind(x => x.Item1.TryGetOutputTypeReference().Compose(() => x.Item2.TryGetOutputTypeReference()))\r\n                .Bind(x => MultipleTypeReference.TryCreate(new[] { x.Item1, x.Item2 }, TypeName));\r\n    }\r\n}",
      "mutants": [
        {
          "id": "285",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 23,
              "column": 57
            },
            "end": {
              "line": 23,
              "column": 60
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\TextCase.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// The case to convert the text to.\r\n    /// <" + "/summary>\r\n    public enum TextCase\r\n    {\r\n        /// <" + "summary>\r\n        /// All characters will be in upper case.\r\n        /// <" + "/summary>\r\n        Upper,\r\n        /// <" + "summary>\r\n        /// All characters will be in lower case.\r\n        /// <" + "/summary>\r\n        Lower,\r\n        /// <" + "summary>\r\n        /// Only the first character in each word will be in upper case.\r\n        /// <" + "/summary>\r\n        Title\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ToCase.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Globalization;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Converts a string to a particular case.\r\n    /// <" + "/summary>\r\n    public sealed class ToCase : CompoundStep<" + "string>\r\n    {\r\n        /// <" + "summary>\r\n        /// The string to change the case of.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The case to change to.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "TextCase> Case { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "string, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            return String.Run(stateMonad).Compose(() => Case.Run(stateMonad))\r\n                .Map(x => Convert(x.Item1, x.Item2));\r\n        }\r\n\r\n        private static string Convert(string s, TextCase textCase) =>\r\n            textCase switch\r\n            {\r\n                TextCase.Upper => s.ToUpperInvariant(),\r\n                TextCase.Lower => s.ToLowerInvariant(),\r\n                TextCase.Title => CultureInfo.InvariantCulture.TextInfo.ToTitleCase(s),\r\n                _ => throw new ArgumentOutOfRangeException(nameof(textCase), textCase, null)\r\n            };\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => ToCaseStepFactory.Instance;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\ToCaseStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Converts a string to a particular case.\r\n    /// <" + "/summary>\r\n    public sealed class ToCaseStepFactory : SimpleStepFactory<" + "ToCase, string>\r\n    {\r\n        private ToCaseStepFactory() { }\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "ToCase, string> Instance { get; } = new ToCaseStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => new[] {typeof(TextCase)};\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\Trim.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Trims a string.\r\n    /// <" + "/summary>\r\n    public sealed class Trim : CompoundStep<" + "string>\r\n    {\r\n\r\n        /// <" + "summary>\r\n        /// The string to change the case of.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> String { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The side to trim.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "TrimSide> Side { get; set; } = null!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "string, IRunErrors> Run(StateMonad stateMonad) =>\r\n            String.Run(stateMonad).Compose(() => Side.Run(stateMonad))\r\n                .Map(x => TrimString(x.Item1, x.Item2));\r\n\r\n        private static string TrimString(string s, TrimSide side) =>\r\n            side switch\r\n            {\r\n                TrimSide.Left => s.TrimStart(),\r\n                TrimSide.Right => s.TrimEnd(),\r\n                TrimSide.Both => s.Trim(),\r\n                _ => throw new ArgumentOutOfRangeException(nameof(side), side, null)\r\n            };\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => TrimStepFactory.Instance;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\TrimSide.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// The side of the string to trim.\r\n    /// <" + "/summary>\r\n    public enum TrimSide\r\n    {\r\n        /// <" + "summary>\r\n        /// Removes whitespace from the left side of the string.\r\n        /// <" + "/summary>\r\n        Left,\r\n        /// <" + "summary>\r\n        /// Removes whitespace from the right side of the string.\r\n        /// <" + "/summary>\r\n        Right,\r\n        /// <" + "summary>\r\n        /// Removes whitespace from both sides of the string.\r\n        /// <" + "/summary>\r\n        Both\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\TrimStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Trims a string.\r\n    /// <" + "/summary>\r\n    public sealed class TrimStepFactory : SimpleStepFactory<" + "Trim, string>\r\n    {\r\n        private TrimStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "Trim, string> Instance { get; } = new TrimStepFactory();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => new[] { typeof(TrimSide) };\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\Unzip.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.IO.Compression;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Unzip a file in the file system.\r\n    /// <" + "/summary>\r\n    public class Unzip : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var data = ArchiveFilePath.Run(stateMonad)\r\n                .Compose(() => DestinationDirectory.Run(stateMonad), () => OverwriteFiles.Run(stateMonad));\r\n\r\n            if (data.IsFailure)\r\n                return data.ConvertFailure<" + "Unit>();\r\n\r\n            Maybe<" + "IRunErrors> error;\r\n            try\r\n            {\r\n                ZipFile.ExtractToDirectory(data.Value.Item1, data.Value.Item2, data.Value.Item3);\r\n                error = Maybe<" + "IRunErrors>.None;\r\n            }\r\n#pragma warning disable CA1031 // Do not catch general exception types\r\n            catch (Exception e)\r\n            {\r\n                error = Maybe<" + "IRunErrors>.From(new RunError(e.Message, Name, null, ErrorCode.ExternalProcessError));\r\n            }\r\n#pragma warning restore CA1031 // Do not catch general exception types\r\n\r\n            if (error.HasValue)\r\n                return Result.Failure<" + "Unit, IRunErrors>(error.Value);\r\n\r\n            return Unit.Default;\r\n\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The path to the archive to unzip.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> ArchiveFilePath { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The directory to unzip to.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> DestinationDirectory { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// Whether to overwrite files when unzipping.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        [DefaultValueExplanation(\"false\")]\r\n        public IStep<" + "bool> OverwriteFiles { get; set; } = new Constant<" + "bool>(false);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => UnzipStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "286",
          "mutatorName": "Negate expression",
          "replacement": "!(data.IsFailure)",
          "location": {
            "start": {
              "line": 22,
              "column": 17
            },
            "end": {
              "line": 22,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "287",
          "mutatorName": "Negate expression",
          "replacement": "!(error.HasValue)",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "288",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 66,
              "column": 78
            },
            "end": {
              "line": 66,
              "column": 83
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\UnzipStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Unzip a file in the file system.\r\n    /// <" + "/summary>\r\n    public class UnzipStepFactory : SimpleStepFactory<" + "Unzip, Unit>\r\n    {\r\n        private UnzipStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "Unzip, Unit> Instance { get; } = new UnzipStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\General\\WriteFile.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.IO;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Writes a file to the local file system.\r\n    /// <" + "/summary>\r\n    public sealed class WriteFile  : CompoundStep<" + "Unit>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "Unit, IRunErrors> Run(StateMonad stateMonad)\r\n        {\r\n            var data = Folder.Run(stateMonad).Compose(() => FileName.Run(stateMonad),()=> Text.Run(stateMonad));\r\n\r\n            if (data.IsFailure)\r\n                return data.ConvertFailure<" + "Unit>();\r\n\r\n\r\n            var path = Path.Combine(data.Value.Item1, data.Value.Item2);\r\n\r\n            Maybe<" + "IRunErrors> errors;\r\n            try\r\n            {\r\n                File.WriteAllText(path, data.Value.Item3);\r\n                errors = Maybe<" + "IRunErrors>.None;\r\n            }\r\n#pragma warning disable CA1031 // Do not catch general exception types\r\n            catch (Exception e)\r\n            {\r\n                errors = Maybe<" + "IRunErrors>.From(new RunError(e.Message, Name, null, ErrorCode.ExternalProcessError));\r\n            }\r\n#pragma warning restore CA1031 // Do not catch general exception types\r\n\r\n            if (errors.HasValue)\r\n                return Result.Failure<" + "Unit, IRunErrors>(errors.Value);\r\n            return Unit.Default;\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The name of the folder.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Folder { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the file to write to.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> FileName { get; set; } = null!;\r\n\r\n        /// <" + "summary>\r\n        /// The text to write.\r\n        /// <" + "/summary>\r\n        [StepProperty]\r\n        [Required]\r\n        public IStep<" + "string> Text { get; set; } = null!;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepFactory StepFactory => WriteFileStepFactory.Instance;\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "289",
          "mutatorName": "Negate expression",
          "replacement": "!(data.IsFailure)",
          "location": {
            "start": {
              "line": 21,
              "column": 17
            },
            "end": {
              "line": 21,
              "column": 31
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "290",
          "mutatorName": "Negate expression",
          "replacement": "!(errors.HasValue)",
          "location": {
            "start": {
              "line": 40,
              "column": 17
            },
            "end": {
              "line": 40,
              "column": 32
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\General\\WriteFileStepFactory.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.General\r\n{\r\n    /// <" + "summary>\r\n    /// Writes a file to the local file system.\r\n    /// <" + "/summary>\r\n    public sealed class WriteFileStepFactory : SimpleStepFactory<" + "WriteFile, Unit>\r\n    {\r\n        private WriteFileStepFactory() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static SimpleStepFactory<" + "WriteFile, Unit> Instance { get; } = new WriteFileStepFactory();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\ActualTypeReference.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.Linq;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// An actual instance of the type.\r\n    /// <" + "/summary>\r\n    public sealed class ActualTypeReference : ITypeReference, IEquatable<" + "ITypeReference>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new ActualTypeReference.\r\n        /// <" + "/summary>\r\n        public ActualTypeReference(Type type) => Type = type;\r\n\r\n        /// <" + "summary>\r\n        /// The type to use.\r\n        /// <" + "/summary>\r\n        public Type Type { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(ITypeReference? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n\r\n            return other switch\r\n            {\r\n                ActualTypeReference actualType => Type == actualType.Type,\r\n                MultipleTypeReference multipleTypeReference => multipleTypeReference.AllReferences.Count == 0 &&\r\n                                                               multipleTypeReference.AllReferences.Contains(this),\r\n                VariableTypeReference _ => false,\r\n                GenericTypeReference _ => false,\r\n                _ => throw new ArgumentOutOfRangeException(nameof(other))\r\n            };\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is ITypeReference other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => Type.GetHashCode();\r\n\r\n        /// <" + "inheritdoc />\r\n        IEnumerable<" + "VariableTypeReference> ITypeReference.VariableTypeReferences => ImmutableArray<" + "VariableTypeReference>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        IEnumerable<" + "ActualTypeReference> ITypeReference.ActualTypeReferences => new[] {this};\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "ITypeReference> TypeArgumentReferences => ImmutableList<" + "ITypeReference>.Empty;\r\n\r\n        /// <" + "summary>\r\n        /// Creates a fixed type reference from a type\r\n        /// <" + "/summary>\r\n        public static ITypeReference Create(Type type)\r\n        {\r\n            if (type.IsGenericType)\r\n            {\r\n                var genericTypeDef = type.GetGenericTypeDefinition();\r\n                var arguments = type.GenericTypeArguments;\r\n\r\n                return new GenericTypeReference(genericTypeDef, arguments.Select(Create).ToList());\r\n            }\r\n            else\r\n                return new ActualTypeReference(type);\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "291",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 26,
              "column": 39
            },
            "end": {
              "line": 26,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "292",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "293",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 27,
              "column": 54
            },
            "end": {
              "line": 27,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "294",
          "mutatorName": "Equality mutation",
          "replacement": "Type != actualType.Type",
          "location": {
            "start": {
              "line": 31,
              "column": 51
            },
            "end": {
              "line": 31,
              "column": 74
            }
          },
          "status": "Killed"
        },
        {
          "id": "295",
          "mutatorName": "Logical mutation",
          "replacement": "multipleTypeReference.AllReferences.Count == 0 ||\r\n                                                               multipleTypeReference.AllReferences.Contains(this)",
          "location": {
            "start": {
              "line": 32,
              "column": 64
            },
            "end": {
              "line": 33,
              "column": 114
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "296",
          "mutatorName": "Equality mutation",
          "replacement": "multipleTypeReference.AllReferences.Count != 0 ",
          "location": {
            "start": {
              "line": 32,
              "column": 64
            },
            "end": {
              "line": 32,
              "column": 110
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "297",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 34,
              "column": 44
            },
            "end": {
              "line": 34,
              "column": 49
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "298",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 35,
              "column": 43
            },
            "end": {
              "line": 35,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "299",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is ITypeReference other && Equals(other)",
          "location": {
            "start": {
              "line": 41,
              "column": 53
            },
            "end": {
              "line": 41,
              "column": 127
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "300",
          "mutatorName": "Logical mutation",
          "replacement": "obj is ITypeReference other || Equals(other)",
          "location": {
            "start": {
              "line": 41,
              "column": 83
            },
            "end": {
              "line": 41,
              "column": 127
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "301",
          "mutatorName": "Negate expression",
          "replacement": "!(type.IsGenericType)",
          "location": {
            "start": {
              "line": 60,
              "column": 17
            },
            "end": {
              "line": 60,
              "column": 35
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Internal\\CompoundFreezableStep.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step that is not a constant or a variable reference.\r\n    /// <" + "/summary>\r\n    public sealed class CompoundFreezableStep : IFreezableStep, IEquatable<" + "CompoundFreezableStep>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new CompoundFreezableStep.\r\n        /// <" + "/summary>\r\n        public CompoundFreezableStep(IStepFactory stepFactory, FreezableStepData freezableStepData, Configuration? stepConfiguration)\r\n        {\r\n            StepFactory = stepFactory;\r\n            FreezableStepData = freezableStepData;\r\n            StepConfiguration = stepConfiguration;\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The factory for this step.\r\n        /// <" + "/summary>\r\n        public IStepFactory StepFactory { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The data for this step.\r\n        /// <" + "/summary>\r\n        public FreezableStepData FreezableStepData { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Configuration for this step.\r\n        /// <" + "/summary>\r\n        public Configuration? StepConfiguration { get; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "IStep> TryFreeze(StepContext stepContext) => StepFactory.TryFreeze(stepContext, FreezableStepData, StepConfiguration);\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "IReadOnlyCollection<" + "(VariableName VariableName, ITypeReference type)>> TryGetVariablesSet\r\n        {\r\n            get\r\n            {\r\n                var result = FreezableStepData\r\n                    .Dictionary.Values\r\n                    .Select(TryGetStepMemberVariablesSet)\r\n                    .Combine()\r\n                    .Map(x=>x.SelectMany(y=>y).ToList() as IReadOnlyCollection<" + "(VariableName name, ITypeReference type)>);\r\n\r\n                return result;\r\n\r\n\r\n                 Result<" + "IReadOnlyCollection<" + "(VariableName, ITypeReference)>> TryGetStepMemberVariablesSet(StepMember stepMember) =>\r\n                     stepMember.Join(vn =>\r\n                             StepFactory.GetTypeReferencesSet(vn, FreezableStepData)\r\n                                 .Map(y=> y.Map(x => new[] { (vn, x) } as IReadOnlyCollection<" + "(VariableName, ITypeReference)>)\r\n                                 .Unwrap(ImmutableArray<" + "(VariableName, ITypeReference)>.Empty)),\r\n                         y => y.TryGetVariablesSet,\r\n                         y => y.Select(z => z.TryGetVariablesSet).Combine().Map(x =>\r\n                             x.SelectMany(q => q).ToList() as IReadOnlyCollection<" + "(VariableName, ITypeReference)>));\r\n            }\r\n        }\r\n\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public string StepName => StepFactory.StepNameBuilder.GetFromArguments(FreezableStepData);\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "ITypeReference> TryGetOutputTypeReference() => StepFactory.TryGetOutputTypeReference(FreezableStepData);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString() => StepName;\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(CompoundFreezableStep? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n            return StepFactory.Equals(other.StepFactory) &&\r\n                   FreezableStepData.Equals(other.FreezableStepData) &&\r\n                   Equals(StepConfiguration, other.StepConfiguration);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is CompoundFreezableStep other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => HashCode.Combine(StepFactory, FreezableStepData, StepConfiguration);\r\n\r\n        /// <" + "summary>\r\n        /// Equals Operator.\r\n        /// <" + "/summary>\r\n        public static bool operator ==(CompoundFreezableStep? left, CompoundFreezableStep? right) => Equals(left, right);\r\n\r\n        /// <" + "summary>\r\n        /// Not Equals Operator.\r\n        /// <" + "/summary>\r\n        public static bool operator !=(CompoundFreezableStep? left, CompoundFreezableStep? right) => !Equals(left, right);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "302",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 83,
              "column": 39
            },
            "end": {
              "line": 83,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "303",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 84,
              "column": 17
            },
            "end": {
              "line": 84,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "304",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 84,
              "column": 54
            },
            "end": {
              "line": 84,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "305",
          "mutatorName": "Logical mutation",
          "replacement": "StepFactory.Equals(other.StepFactory) &&\r\n                   FreezableStepData.Equals(other.FreezableStepData) ||\r\n                   Equals(StepConfiguration, other.StepConfiguration)",
          "location": {
            "start": {
              "line": 85,
              "column": 20
            },
            "end": {
              "line": 87,
              "column": 70
            }
          },
          "status": "Survived"
        },
        {
          "id": "306",
          "mutatorName": "Logical mutation",
          "replacement": "StepFactory.Equals(other.StepFactory) ||\r\n                   FreezableStepData.Equals(other.FreezableStepData) ",
          "location": {
            "start": {
              "line": 85,
              "column": 20
            },
            "end": {
              "line": 86,
              "column": 69
            }
          },
          "status": "Survived"
        },
        {
          "id": "307",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is CompoundFreezableStep other && Equals(other)",
          "location": {
            "start": {
              "line": 91,
              "column": 53
            },
            "end": {
              "line": 91,
              "column": 134
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "308",
          "mutatorName": "Logical mutation",
          "replacement": "obj is CompoundFreezableStep other || Equals(other)",
          "location": {
            "start": {
              "line": 91,
              "column": 83
            },
            "end": {
              "line": 91,
              "column": 134
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "309",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "Equals(left, right)",
          "location": {
            "start": {
              "line": 104,
              "column": 102
            },
            "end": {
              "line": 104,
              "column": 122
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\CompoundStep.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A runnable step that is not a constant.\r\n    /// <" + "/summary>\r\n    public abstract class CompoundStep<" + "T> : ICompoundStep<" + "T>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public abstract Result<" + "T, IRunErrors> Run(StateMonad stateMonad);\r\n\r\n        /// <" + "summary>\r\n        /// The factory used to create steps of this type.\r\n        /// <" + "/summary>\r\n        public abstract IStepFactory StepFactory { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public string Name => StepFactory.StepNameBuilder.GetFromArguments(FreezableStepData);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString() => StepFactory.TypeName;\r\n\r\n        /// <" + "summary>\r\n        /// Configuration for this step.\r\n        /// <" + "/summary>\r\n        public Configuration? Configuration { get; set; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public virtual IEnumerable<" + "Requirement> RuntimeRequirements => ImmutableArray<" + "Requirement>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "IStepCombiner> StepCombiners =>\r\n            StepFactory.StepCombiner.ToList()\r\n                .Concat(\r\n                    RunnableArguments.Select(x => x.step)\r\n                        .Concat(RunnableListArguments.SelectMany(x => x.list))\r\n                        .OfType<" + "ICompoundStep>()\r\n                        .SelectMany(x => x.StepCombiners)\r\n\r\n                ).Distinct();\r\n\r\n\r\n        private IEnumerable<" + "(string name, IStep step) > RunnableArguments\r\n        {\r\n            get\r\n            {\r\n                return GetType().GetProperties()\r\n                    .Where(x => x.GetCustomAttribute<" + "StepPropertyAttribute>() != null)\r\n                    .Select(x => (x.Name, step: x.GetValue(this) as IStep))\r\n                    .Where(x => x.step != null)!;\r\n            }\r\n        }\r\n\r\n        private IEnumerable<" + "(string name, IEnumerable<" + "IStep> list)> RunnableListArguments\r\n        {\r\n            get\r\n            {\r\n                return GetType()\r\n                    .GetProperties()\r\n                    .Where(x => x.GetCustomAttribute<" + "StepListPropertyAttribute>() != null)\r\n                    .Select(x => (x.Name, list: x.GetValue(this) as IEnumerable<" + "IStep>))\r\n                    .Where(x => x.list != null)!;\r\n            }\r\n        }\r\n\r\n        private FreezableStepData FreezableStepData\r\n        {\r\n            get\r\n            {\r\n                var variableNames = GetType().GetProperties()\r\n                .Where(x => x.GetCustomAttribute<" + "VariableNameAttribute>() != null)\r\n                .Select(x => (x.Name, variableName: (VariableName)x.GetValue(this)!))\r\n                .Where(x => x.variableName != null)\r\n\r\n                .ToDictionary(x => x.Name, x => new StepMember(x.variableName)  );\r\n\r\n\r\n                var arguments  = RunnableArguments\r\n                 .ToDictionary(x => x.name, x => new StepMember(x.step!.Unfreeze()));\r\n\r\n                var listArguments = RunnableListArguments\r\n                .ToDictionary(x => x.name,\r\n                    x => new StepMember( x.list.Select(y => y.Unfreeze()).ToList()));\r\n\r\n\r\n                var stepMembers = variableNames.Concat(arguments).Concat(listArguments)\r\n                    .ToDictionary(x => x.Key, x => x.Value);\r\n\r\n\r\n                return new FreezableStepData(stepMembers);\r\n            }\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public IFreezableStep Unfreeze() => new CompoundFreezableStep(StepFactory,FreezableStepData, Configuration);\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "T1, IRunErrors> Run<" + "T1>(StateMonad stateMonad) =>\r\n            Run(stateMonad).BindCast<" + "T, T1, IRunErrors>(new RunError($\"Could not cast {typeof(T)} to {typeof(T1)}\", Name, null, ErrorCode.InvalidCast));\r\n\r\n        /// <" + "summary>\r\n        /// Check that this step meets requirements\r\n        /// <" + "/summary>\r\n        public virtual Result<" + "Unit, IRunErrors> VerifyThis(ISettings settings) => Unit.Default;\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "Unit, IRunErrors> Verify(ISettings settings)\r\n        {\r\n            var r0 = new[] {VerifyThis(settings)};\r\n\r\n            var rRequirements = RuntimeRequirements.Concat(StepFactory.Requirements)\r\n                .Select(req => settings.CheckRequirement(Name, req));\r\n\r\n\r\n            var r1 = RunnableArguments.Select(x => x.step.Verify(settings));\r\n            var r2 = RunnableListArguments.Select(x => x.list.Select(l => l.Verify(settings))\r\n                    .Combine(RunErrorList.Combine).Map(_=>Unit.Default));\r\n\r\n\r\n            var finalResult = r0.Concat(rRequirements) .Concat(r1).Concat(r2).Combine(RunErrorList.Combine).Map(_ => Unit.Default);\r\n\r\n            return finalResult;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "310",
          "mutatorName": "Equality mutation",
          "replacement": "x.GetCustomAttribute<" + "StepPropertyAttribute>() == null",
          "location": {
            "start": {
              "line": 55,
              "column": 33
            },
            "end": {
              "line": 55,
              "column": 86
            }
          },
          "status": "Timeout"
        },
        {
          "id": "311",
          "mutatorName": "Equality mutation",
          "replacement": "x.step == null",
          "location": {
            "start": {
              "line": 57,
              "column": 33
            },
            "end": {
              "line": 57,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "312",
          "mutatorName": "Equality mutation",
          "replacement": "x.GetCustomAttribute<" + "StepListPropertyAttribute>() == null",
          "location": {
            "start": {
              "line": 67,
              "column": 33
            },
            "end": {
              "line": 67,
              "column": 90
            }
          },
          "status": "Timeout"
        },
        {
          "id": "313",
          "mutatorName": "Equality mutation",
          "replacement": "x.list == null",
          "location": {
            "start": {
              "line": 69,
              "column": 33
            },
            "end": {
              "line": 69,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "314",
          "mutatorName": "Equality mutation",
          "replacement": "x.GetCustomAttribute<" + "VariableNameAttribute>() == null",
          "location": {
            "start": {
              "line": 78,
              "column": 29
            },
            "end": {
              "line": 78,
              "column": 82
            }
          },
          "status": "Killed"
        },
        {
          "id": "315",
          "mutatorName": "Equality mutation",
          "replacement": "x.variableName == null",
          "location": {
            "start": {
              "line": 80,
              "column": 29
            },
            "end": {
              "line": 80,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "316",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 106,
              "column": 70
            },
            "end": {
              "line": 106,
              "column": 115
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Internal\\ConsoleMethods.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Internal.Documentation;\r\nusing Reductech.EDR.Core.Serialization;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Runs methods in the console\r\n    /// <" + "/summary>\r\n    public abstract class ConsoleMethods\r\n    {\r\n        /// <" + "summary>\r\n        /// One type for each additional connector.\r\n        /// <" + "/summary>\r\n        protected abstract IEnumerable<" + "Type> ConnectorTypes { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The logger. Most probably a console logger.\r\n        /// <" + "/summary>\r\n        protected abstract ILogger Logger { get; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Try to get step settings from the config file.\r\n        /// <" + "/summary>\r\n        /// <" + "returns><" + "/returns>\r\n        protected abstract Result<" + "ISettings> TryGetSettings();\r\n\r\n        /// <" + "summary>\r\n        /// Generates documentation\r\n        /// <" + "/summary>\r\n        protected void GenerateDocumentationAbstract(string path)\r\n        {\r\n            var documentationCategories = ConnectorTypes.Append(typeof(IStep))\r\n                .Select(type => (docCategory: new DocumentationCategory(type.Assembly.GetName().Name!), type)).ToList();\r\n\r\n            var documented = documentationCategories\r\n                .SelectMany(x =>\r\n                    DocumentationCreator.GetAllDocumented(x.docCategory, StepFactoryStore.CreateUsingReflection(x.type)))\r\n                .Distinct().ToList();\r\n\r\n            var lines = DocumentationCreator.CreateDocumentationLines(documented);\r\n\r\n\r\n            File.WriteAllLines(path, lines);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Executes yaml\r\n        /// <" + "/summary>\r\n        protected void ExecuteAbstract(string? yaml, string? path)\r\n        {\r\n            if (string.IsNullOrWhiteSpace(yaml))\r\n            {\r\n                if (string.IsNullOrWhiteSpace(path))\r\n                {\r\n                    throw new ArgumentException($\"Please provide either {nameof(yaml)} or {nameof(path)}\");\r\n                }\r\n\r\n                ExecuteYamlFromPath(path);\r\n            }\r\n\r\n            else\r\n            {\r\n                if(string.IsNullOrWhiteSpace(path))\r\n                    ExecuteYamlString(yaml);\r\n                else\r\n                    throw new ArgumentException($\"Please provide only one of {nameof(yaml)} or {nameof(path)}\");\r\n            }\r\n        }\r\n\r\n        private void ExecuteYamlFromPath(string path)\r\n        {\r\n            var text = File.ReadAllText(path);\r\n\r\n            ExecuteYamlString(text);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Runs a step defined in a yaml string\r\n        /// <" + "/summary>\r\n        private void ExecuteYamlString(string yaml)\r\n        {\r\n            var stepFactoryStore = StepFactoryStore.CreateUsingReflection(ConnectorTypes.Append(typeof(IStep)).ToArray());\r\n\r\n            var freezeResult = YamlMethods.DeserializeFromYaml(yaml, stepFactoryStore)\r\n                .Bind(x => x.TryFreeze())\r\n                .BindCast<" + "IStep, IStep<" + "Unit>>();\r\n\r\n            if (freezeResult.IsFailure)\r\n                Logger.LogError(freezeResult.Error);\r\n            else\r\n            {\r\n                var settingsResult = TryGetSettings();\r\n\r\n                if (settingsResult.IsFailure)\r\n                    Logger.LogError(settingsResult.Error);\r\n                else\r\n                {\r\n                    var stateMonad = new StateMonad(Logger, settingsResult.Value, ExternalProcessRunner.Instance);\r\n\r\n                    var runResult = freezeResult.Value.Run(stateMonad);\r\n\r\n                    if (runResult.IsFailure)\r\n                        foreach (var runError in runResult.Error.AllErrors)\r\n                            Logger.LogError(runError.Message);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "317",
          "mutatorName": "Negate expression",
          "replacement": "!(string.IsNullOrWhiteSpace(yaml))",
          "location": {
            "start": {
              "line": 59,
              "column": 17
            },
            "end": {
              "line": 59,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "318",
          "mutatorName": "Negate expression",
          "replacement": "!(string.IsNullOrWhiteSpace(path))",
          "location": {
            "start": {
              "line": 61,
              "column": 21
            },
            "end": {
              "line": 61,
              "column": 52
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "319",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 63,
              "column": 49
            },
            "end": {
              "line": 63,
              "column": 106
            }
          },
          "status": "Ignored"
        },
        {
          "id": "320",
          "mutatorName": "Negate expression",
          "replacement": "!(string.IsNullOrWhiteSpace(path))",
          "location": {
            "start": {
              "line": 71,
              "column": 20
            },
            "end": {
              "line": 71,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "321",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 74,
              "column": 49
            },
            "end": {
              "line": 74,
              "column": 111
            }
          },
          "status": "Ignored"
        },
        {
          "id": "322",
          "mutatorName": "Negate expression",
          "replacement": "!(freezeResult.IsFailure)",
          "location": {
            "start": {
              "line": 96,
              "column": 17
            },
            "end": {
              "line": 96,
              "column": 39
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "323",
          "mutatorName": "Negate expression",
          "replacement": "!(settingsResult.IsFailure)",
          "location": {
            "start": {
              "line": 102,
              "column": 21
            },
            "end": {
              "line": 102,
              "column": 45
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "324",
          "mutatorName": "Negate expression",
          "replacement": "!(runResult.IsFailure)",
          "location": {
            "start": {
              "line": 110,
              "column": 25
            },
            "end": {
              "line": 110,
              "column": 44
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\Constant.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step that returns a fixed value when run.\r\n    /// <" + "/summary>\r\n    public class Constant<" + "T> : IStep<" + "T>, IConstantStep\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new Constant.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"value\"><" + "/param>\r\n        public Constant(T value) => Value = value;\r\n\r\n        /// <" + "summary>\r\n        /// The value that this will return when run.\r\n        /// <" + "/summary>\r\n        public T Value { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "T, IRunErrors> Run(StateMonad stateMonad) => Value!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public string Name => $\"{Value}\";\r\n\r\n        /// <" + "inheritdoc />\r\n        public IFreezableStep Unfreeze() => new ConstantFreezableStep(Value!);\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "T1, IRunErrors> Run<" + "T1>(StateMonad stateMonad)\r\n        {\r\n            var r = Value!.TryConvert<" + "T1>()\r\n                .MapFailure(x => new RunError(x, Name, null, ErrorCode.InvalidCast) as IRunErrors);\r\n\r\n            return r;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "Unit, IRunErrors> Verify(ISettings settings) => Unit.Default;\r\n\r\n        /// <" + "inheritdoc />\r\n        public Configuration? Configuration { get; set; } = null;\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "IStepCombiner> StepCombiners => ArraySegment<" + "IStepCombiner>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public Type OutputType => typeof(T);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "325",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 28,
              "column": 31
            },
            "end": {
              "line": 28,
              "column": 41
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Internal\\ConstantFreezableStep.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step that returns a fixed value when run.\r\n    /// <" + "/summary>\r\n    public sealed class ConstantFreezableStep : IFreezableStep, IEquatable<" + "ConstantFreezableStep>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new ConstantFreezableStep.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"value\"><" + "/param>\r\n        public ConstantFreezableStep(object value) => Value = value;\r\n\r\n        /// <" + "summary>\r\n        /// The value that this will return when run.\r\n        /// <" + "/summary>\r\n        public object Value { get; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "IStep> TryFreeze(StepContext _)\r\n        {\r\n            Type elementType = Value.GetType();\r\n            Type stepType = typeof(Constant<" + ">).MakeGenericType(elementType);\r\n            var stepAsObject = Activator.CreateInstance(stepType, Value);\r\n\r\n            //TODO check for exceptions here?\r\n\r\n            var step = (IStep) stepAsObject!;\r\n\r\n            return Result.Success(step);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "IReadOnlyCollection<" + "(VariableName VariableName, ITypeReference type)>> TryGetVariablesSet => ImmutableList<" + "(VariableName VariableName, ITypeReference type)>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public string StepName\r\n        {\r\n            get\r\n            {\r\n                if (Value is string s)\r\n                    return $\"'{s}'\";\r\n\r\n                if (Value is Enum e)\r\n                    return e.GetDisplayName();\r\n\r\n                return $\"{Value}\";\r\n            }\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "ITypeReference> TryGetOutputTypeReference() => new ActualTypeReference(Value.GetType());\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString() => StepName;\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(ConstantFreezableStep? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n            return Value.Equals(other.Value);\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is ConstantFreezableStep other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => Value.GetHashCode();\r\n\r\n        /// <" + "summary>\r\n        /// Equals operator.\r\n        /// <" + "/summary>\r\n        public static bool operator ==(ConstantFreezableStep? left, ConstantFreezableStep? right) => Equals(left, right);\r\n\r\n        /// <" + "summary>\r\n        /// Not Equals operator\r\n        /// <" + "/summary>\r\n        public static bool operator !=(ConstantFreezableStep? left, ConstantFreezableStep? right) => !Equals(left, right);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "326",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 49,
              "column": 28
            },
            "end": {
              "line": 49,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "327",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 54,
              "column": 24
            },
            "end": {
              "line": 54,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "328",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 67,
              "column": 39
            },
            "end": {
              "line": 67,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "329",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 68,
              "column": 17
            },
            "end": {
              "line": 68,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "330",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 68,
              "column": 54
            },
            "end": {
              "line": 68,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "331",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is ConstantFreezableStep other && Equals(other)",
          "location": {
            "start": {
              "line": 73,
              "column": 53
            },
            "end": {
              "line": 73,
              "column": 134
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "332",
          "mutatorName": "Logical mutation",
          "replacement": "obj is ConstantFreezableStep other || Equals(other)",
          "location": {
            "start": {
              "line": 73,
              "column": 83
            },
            "end": {
              "line": 73,
              "column": 134
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "333",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "Equals(left, right)",
          "location": {
            "start": {
              "line": 86,
              "column": 102
            },
            "end": {
              "line": 86,
              "column": 122
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\DefaultStepNameBuilder.cs": {
      "language": "cs",
      "source": "using System.Linq;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// The default step name builder\r\n    /// <" + "/summary>\r\n    public class DefaultStepNameBuilder : IStepNameBuilder\r\n    {\r\n        /// <" + "summary>\r\n        /// The step type name.\r\n        /// <" + "/summary>\r\n        public string TypeName { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Creates a new DefaultStepNameBuilder.\r\n        /// <" + "/summary>\r\n        public DefaultStepNameBuilder(string typeName) => TypeName = typeName;\r\n\r\n        /// <" + "inheritdoc />\r\n        public string GetFromArguments(FreezableStepData freezableStepData)\r\n        {\r\n            var args = string.Join(\", \", freezableStepData\r\n                .Dictionary\r\n                .OrderBy(x=>x.Key)\r\n                .Select(x => $\"{x.Key}: {x.Value.MemberString}\"));\r\n\r\n            return $\"{TypeName}({args})\";\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "334",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 23,
              "column": 36
            },
            "end": {
              "line": 23,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "335",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "freezableStepData\r\n                .Dictionary\r\n                .OrderByDescending(x=>x.Key)\r\n                .Select(x => $\"{x.Key}: {x.Value.MemberString}\")",
          "location": {
            "start": {
              "line": 23,
              "column": 42
            },
            "end": {
              "line": 26,
              "column": 65
            }
          },
          "status": "Killed"
        },
        {
          "id": "336",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 26,
              "column": 30
            },
            "end": {
              "line": 26,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "337",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 28,
              "column": 20
            },
            "end": {
              "line": 28,
              "column": 41
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Documentation\\DocumentationCategory.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    /// <" + "summary>\r\n    /// A category of documentation.\r\n    /// <" + "/summary>\r\n    public class DocumentationCategory\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new DocumentationCategory\r\n        /// <" + "/summary>\r\n        public DocumentationCategory(string header, Type? anchor = null)\r\n        {\r\n            Header = header;\r\n            Anchor = anchor;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The header that will appear at the top of the category.\r\n        /// <" + "/summary>\r\n        public string Header { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The anchor that will appear at the top of the category.\r\n        /// <" + "/summary>\r\n        public Type? Anchor { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => obj is DocumentationCategory dc && Header == dc.Header && Anchor == dc.Anchor;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => Header.GetHashCode() + Anchor?.GetHashCode() ?? 0;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "338",
          "mutatorName": "Logical mutation",
          "replacement": "obj is DocumentationCategory dc && Header == dc.Header || Anchor == dc.Anchor",
          "location": {
            "start": {
              "line": 30,
              "column": 53
            },
            "end": {
              "line": 30,
              "column": 130
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "339",
          "mutatorName": "Logical mutation",
          "replacement": "obj is DocumentationCategory dc || Header == dc.Header ",
          "location": {
            "start": {
              "line": 30,
              "column": 53
            },
            "end": {
              "line": 30,
              "column": 107
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "340",
          "mutatorName": "Equality mutation",
          "replacement": "Header != dc.Header ",
          "location": {
            "start": {
              "line": 30,
              "column": 88
            },
            "end": {
              "line": 30,
              "column": 107
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "341",
          "mutatorName": "Equality mutation",
          "replacement": "Anchor != dc.Anchor",
          "location": {
            "start": {
              "line": 30,
              "column": 111
            },
            "end": {
              "line": 30,
              "column": 130
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "342",
          "mutatorName": "Arithmetic mutation",
          "replacement": "Header.GetHashCode() - Anchor?.GetHashCode() ",
          "location": {
            "start": {
              "line": 33,
              "column": 46
            },
            "end": {
              "line": 33,
              "column": 90
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Documentation\\DocumentationCreator.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing Namotion.Reflection;\r\n\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    internal static class DocumentationCreator\r\n    {\r\n        /// <" + "summary>\r\n        /// Dynamically Gets all steps and related entities from an assembly.\r\n        /// For use with InstantConsole.\r\n        /// <" + "/summary>\r\n        public static IEnumerable<" + "IDocumented> GetAllDocumented(DocumentationCategory documentationCategory, StepFactoryStore stepFactoryStore)\r\n        {\r\n            var wrappers = stepFactoryStore.Dictionary.Values\r\n                .Select(x => new StepWrapper(x, documentationCategory)).ToList();\r\n\r\n            return wrappers;\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Creates documentation for a list of entities\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"entities\"><" + "/param>\r\n        public static List<" + "string> CreateDocumentationLines(IEnumerable<" + "IDocumented> entities)\r\n        {\r\n            var lines = new List<" + "string>();\r\n\r\n            var enumTypes = new HashSet<" + "Type>();\r\n\r\n            var categories = entities.GroupBy(x => x.DocumentationCategory).ToList();\r\n\r\n            lines.Add($\"# Contents\");\r\n\r\n            var contentsRows = categories.SelectMany(x => x)\r\n                .Select(x => new[]\r\n                {\r\n                    $\"<" + "a name=\\\"{x.Name}\\\">{x.Name}<" + "/a>\",\r\n                    x.Summary\r\n                }).ToList();\r\n\r\n            var contentsTableLines = Prettifier.CreateMarkdownTable(contentsRows);\r\n\r\n            lines.AddRange(contentsTableLines);\r\n\r\n\r\n\r\n            foreach (var category in categories)\r\n            {\r\n                if (category.Key.Anchor != null)\r\n                    lines.Add($\"<" + "a name=\\\"{TypeNameHelper.GetHumanReadableTypeName(category.Key.Anchor)}\\\"><" + "/a>\");\r\n                lines.Add($\"# {category.Key.Header}\");\r\n\r\n                foreach (var doc in category)\r\n                {\r\n                    lines.Add($\"<" + "a name=\\\"{doc.Name}\\\"><" + "/a>\");\r\n                    lines.Add($\"## {doc.Name}\");\r\n                    lines.Add(\"\");\r\n                    if (!string.IsNullOrWhiteSpace(doc.TypeDetails))\r\n                    {\r\n                        lines.Add($\"**{doc.TypeDetails}**\");\r\n                        lines.Add(\"\");\r\n                    }\r\n\r\n                    foreach (var docRequirement in doc.Requirements)\r\n                    {\r\n                        lines.Add($\"*{docRequirement}*\");\r\n                        lines.Add(\"\");\r\n                    }\r\n\r\n                    if (!string.IsNullOrWhiteSpace(doc.Summary))\r\n                    {\r\n                        lines.Add(Escape(doc.Summary));\r\n                        lines.Add(\"\");\r\n                    }\r\n\r\n                    if (doc.Parameters.Any())\r\n                    {\r\n                        var extraColumns = doc.Parameters.SelectMany(x => x.ExtraFields.Keys).Distinct().OrderBy(x => x).ToList();\r\n\r\n                        var headers = new List<" + "string?> { \"Parameter\", \"Type\", \"Required\", \"Summary\" };\r\n                        headers.AddRange(extraColumns);\r\n                        var parameterRows = new List<" + "List<" + "string?>> { headers };\r\n\r\n                        parameterRows.AddRange(\r\n                            doc.Parameters\r\n                                .Select(rp =>\r\n\r\n                                {\r\n                                    var r = new List<" + "string?>\r\n                                    {\r\n                                        rp.Name,\r\n                                        TypeNameHelper.GetMarkupTypeName(rp.Type),\r\n                                        rp.Required ? \"☑️\" : \"\",\r\n                                        rp.Summary\r\n\r\n                                    };\r\n                                    foreach (var extraColumn in extraColumns)\r\n                                    {\r\n                                        var columnValue = rp.ExtraFields.TryGetValue(extraColumn, out var cv) ? cv : null;\r\n                                        r.Add(columnValue);\r\n                                    }\r\n                                    return r;\r\n                                }));\r\n\r\n                        var table = Prettifier.CreateMarkdownTable(parameterRows).ToList();\r\n                        lines.AddRange(table);\r\n                        lines.Add(\"\");\r\n                        enumTypes.UnionWith(doc.Parameters.Select(x => x.Type)\r\n                            .Select(x => Nullable.GetUnderlyingType(x) ?? x).Where(t => t.IsEnum));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (enumTypes.Any())\r\n            {\r\n                lines.Add($\"# Enums\");\r\n\r\n                foreach (var type in enumTypes.OrderBy(x => x.Name))\r\n                {\r\n                    lines.Add($\"<" + "a name=\\\"{type.Name}\\\"><" + "/a>\");\r\n                    lines.Add($\"## {type.Name}\");\r\n                    var summary = type.GetXmlDocsSummary();\r\n                    if (!string.IsNullOrWhiteSpace(summary))\r\n                    {\r\n                        lines.Add(Escape(summary));\r\n                        lines.Add(\"\");\r\n                    }\r\n\r\n                    var parameterRows = new List<" + "string?[]> { new[] { \"Name\", \"Summary\" } };\r\n                    parameterRows.AddRange(\r\n                        type.GetFields(BindingFlags.Public | BindingFlags.Static)\r\n                            .Select(fieldInfo => new[] { fieldInfo.Name, fieldInfo.GetXmlDocsSummary() }));\r\n\r\n                    var table = Prettifier.CreateMarkdownTable(parameterRows).ToList();\r\n                    lines.AddRange(table);\r\n                    lines.Add(\"\");\r\n                }\r\n            }\r\n\r\n\r\n\r\n            return lines;\r\n\r\n            static string Escape(string? s)\r\n            {\r\n                return (s ?? string.Empty)\r\n                    .Replace(\"|\", @\"\\|\")\r\n                    .Replace(\"\\r\\n\", \" \")\r\n                    .Replace(\"\\n\", \" \");\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "343",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 36,
              "column": 23
            },
            "end": {
              "line": 36,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "344",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 41,
              "column": 21
            },
            "end": {
              "line": 41,
              "column": 57
            }
          },
          "status": "Killed"
        },
        {
          "id": "345",
          "mutatorName": "Equality mutation",
          "replacement": "category.Key.Anchor == null",
          "location": {
            "start": {
              "line": 53,
              "column": 21
            },
            "end": {
              "line": 53,
              "column": 48
            }
          },
          "status": "Killed"
        },
        {
          "id": "346",
          "mutatorName": "Negate expression",
          "replacement": "!(category.Key.Anchor != null)",
          "location": {
            "start": {
              "line": 53,
              "column": 21
            },
            "end": {
              "line": 53,
              "column": 48
            }
          },
          "status": "Killed"
        },
        {
          "id": "347",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 54,
              "column": 31
            },
            "end": {
              "line": 54,
              "column": 113
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "348",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 55,
              "column": 27
            },
            "end": {
              "line": 55,
              "column": 53
            }
          },
          "status": "Killed"
        },
        {
          "id": "349",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 59,
              "column": 31
            },
            "end": {
              "line": 59,
              "column": 61
            }
          },
          "status": "Killed"
        },
        {
          "id": "350",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 60,
              "column": 31
            },
            "end": {
              "line": 60,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "351",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 61,
              "column": 31
            },
            "end": {
              "line": 61,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "352",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "string.IsNullOrWhiteSpace(doc.TypeDetails)",
          "location": {
            "start": {
              "line": 62,
              "column": 25
            },
            "end": {
              "line": 62,
              "column": 68
            }
          },
          "status": "Killed"
        },
        {
          "id": "353",
          "mutatorName": "Negate expression",
          "replacement": "!(!string.IsNullOrWhiteSpace(doc.TypeDetails))",
          "location": {
            "start": {
              "line": 62,
              "column": 25
            },
            "end": {
              "line": 62,
              "column": 68
            }
          },
          "status": "Killed"
        },
        {
          "id": "354",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 64,
              "column": 35
            },
            "end": {
              "line": 64,
              "column": 59
            }
          },
          "status": "Killed"
        },
        {
          "id": "355",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 65,
              "column": 35
            },
            "end": {
              "line": 65,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "356",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 70,
              "column": 35
            },
            "end": {
              "line": 70,
              "column": 56
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "357",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 71,
              "column": 35
            },
            "end": {
              "line": 71,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "358",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "string.IsNullOrWhiteSpace(doc.Summary)",
          "location": {
            "start": {
              "line": 74,
              "column": 25
            },
            "end": {
              "line": 74,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "359",
          "mutatorName": "Negate expression",
          "replacement": "!(!string.IsNullOrWhiteSpace(doc.Summary))",
          "location": {
            "start": {
              "line": 74,
              "column": 25
            },
            "end": {
              "line": 74,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "360",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 77,
              "column": 35
            },
            "end": {
              "line": 77,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "361",
          "mutatorName": "Negate expression",
          "replacement": "!(doc.Parameters.Any())",
          "location": {
            "start": {
              "line": 80,
              "column": 25
            },
            "end": {
              "line": 80,
              "column": 45
            }
          },
          "status": "Killed"
        },
        {
          "id": "362",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "doc.Parameters.SelectMany(x => x.ExtraFields.Keys).Distinct().OrderByDescending(x => x).ToList()",
          "location": {
            "start": {
              "line": 82,
              "column": 44
            },
            "end": {
              "line": 82,
              "column": 130
            }
          },
          "status": "Survived"
        },
        {
          "id": "363",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new List<" + "string?> {}",
          "location": {
            "start": {
              "line": 84,
              "column": 39
            },
            "end": {
              "line": 84,
              "column": 103
            }
          },
          "status": "Killed"
        },
        {
          "id": "364",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 84,
              "column": 59
            },
            "end": {
              "line": 84,
              "column": 70
            }
          },
          "status": "Killed"
        },
        {
          "id": "365",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 84,
              "column": 72
            },
            "end": {
              "line": 84,
              "column": 78
            }
          },
          "status": "Killed"
        },
        {
          "id": "366",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 84,
              "column": 80
            },
            "end": {
              "line": 84,
              "column": 90
            }
          },
          "status": "Killed"
        },
        {
          "id": "367",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 84,
              "column": 92
            },
            "end": {
              "line": 84,
              "column": 101
            }
          },
          "status": "Killed"
        },
        {
          "id": "368",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new List<" + "List<" + "string?>> {}",
          "location": {
            "start": {
              "line": 86,
              "column": 45
            },
            "end": {
              "line": 86,
              "column": 80
            }
          },
          "status": "Killed"
        },
        {
          "id": "369",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new List<" + "string?>\r\n{}",
          "location": {
            "start": {
              "line": 93,
              "column": 45
            },
            "end": {
              "line": 100,
              "column": 38
            }
          },
          "status": "Killed"
        },
        {
          "id": "370",
          "mutatorName": "Negate expression",
          "replacement": "!(                                        rp.Required )",
          "location": {
            "start": {
              "line": 97,
              "column": 41
            },
            "end": {
              "line": 97,
              "column": 52
            }
          },
          "status": "Killed"
        },
        {
          "id": "371",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 97,
              "column": 55
            },
            "end": {
              "line": 97,
              "column": 59
            }
          },
          "status": "Killed"
        },
        {
          "id": "372",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 97,
              "column": 62
            },
            "end": {
              "line": 97,
              "column": 64
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "373",
          "mutatorName": "Negate expression",
          "replacement": "!(rp.ExtraFields.TryGetValue(extraColumn, out var cv) )",
          "location": {
            "start": {
              "line": 103,
              "column": 59
            },
            "end": {
              "line": 103,
              "column": 110
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "374",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 111,
              "column": 35
            },
            "end": {
              "line": 111,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "375",
          "mutatorName": "Negate expression",
          "replacement": "!(enumTypes.Any())",
          "location": {
            "start": {
              "line": 118,
              "column": 17
            },
            "end": {
              "line": 118,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "376",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 120,
              "column": 27
            },
            "end": {
              "line": 120,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "377",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "enumTypes.OrderByDescending(x => x.Name)",
          "location": {
            "start": {
              "line": 122,
              "column": 38
            },
            "end": {
              "line": 122,
              "column": 68
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "378",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 124,
              "column": 31
            },
            "end": {
              "line": 124,
              "column": 62
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "379",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 125,
              "column": 31
            },
            "end": {
              "line": 125,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "380",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "string.IsNullOrWhiteSpace(summary)",
          "location": {
            "start": {
              "line": 127,
              "column": 25
            },
            "end": {
              "line": 127,
              "column": 60
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "381",
          "mutatorName": "Negate expression",
          "replacement": "!(!string.IsNullOrWhiteSpace(summary))",
          "location": {
            "start": {
              "line": 127,
              "column": 25
            },
            "end": {
              "line": 127,
              "column": 60
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "382",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 130,
              "column": 35
            },
            "end": {
              "line": 130,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "383",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new List<" + "string?[]> {}",
          "location": {
            "start": {
              "line": 133,
              "column": 41
            },
            "end": {
              "line": 133,
              "column": 92
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "384",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 133,
              "column": 71
            },
            "end": {
              "line": 133,
              "column": 77
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "385",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 133,
              "column": 79
            },
            "end": {
              "line": 133,
              "column": 88
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "386",
          "mutatorName": "Bitwise mutation",
          "replacement": "BindingFlags.Public & BindingFlags.Static",
          "location": {
            "start": {
              "line": 135,
              "column": 40
            },
            "end": {
              "line": 135,
              "column": 81
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "387",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 140,
              "column": 31
            },
            "end": {
              "line": 140,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "388",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 150,
              "column": 30
            },
            "end": {
              "line": 150,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "389",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 151,
              "column": 30
            },
            "end": {
              "line": 151,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "390",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 151,
              "column": 35
            },
            "end": {
              "line": 151,
              "column": 40
            }
          },
          "status": "Survived"
        },
        {
          "id": "391",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 152,
              "column": 30
            },
            "end": {
              "line": 152,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "392",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 152,
              "column": 38
            },
            "end": {
              "line": 152,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "393",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 153,
              "column": 30
            },
            "end": {
              "line": 153,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "394",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 153,
              "column": 36
            },
            "end": {
              "line": 153,
              "column": 39
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Documentation\\IDocumented.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\n\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    /// <" + "summary>\r\n    /// Something that will be shown in the documentation\r\n    /// <" + "/summary>\r\n    public interface IDocumented\r\n    {\r\n        /// <" + "summary>\r\n        /// What category this item will belong in.\r\n        /// <" + "/summary>\r\n        DocumentationCategory DocumentationCategory { get; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The name of the method.\r\n        /// <" + "/summary>\r\n        string Name { get; }\r\n\r\n        /// <" + "summary>\r\n        /// A summary of what the method does.\r\n        /// <" + "/summary>\r\n        string Summary { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Information about the return type\r\n        /// <" + "/summary>\r\n        string? TypeDetails { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Requirements for using this method.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "string> Requirements { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The parameters to the method.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "IParameter> Parameters { get; }\r\n    }\r\n}\r\n",
      "mutants": []
    },
    "Core\\Documentation\\IParameter.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\n\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    /// <" + "summary>\r\n    /// The parameter to a runnable method.\r\n    /// <" + "/summary>\r\n    public interface IParameter\r\n    {\r\n        /// <" + "summary>\r\n        /// The name of the parameter.\r\n        /// <" + "/summary>\r\n        string Name { get; }\r\n\r\n        /// <" + "summary>\r\n        /// /// A summary of what this parameter does.\r\n        /// <" + "/summary>\r\n        string Summary { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The type of the parameter.\r\n        /// <" + "/summary>\r\n        Type Type { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Is this parameter required.\r\n        /// <" + "/summary>\r\n        bool Required { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Extra fields e.g. Examples, Default Values, Requirements\r\n        /// <" + "/summary>\r\n        IReadOnlyDictionary<" + "string, string> ExtraFields { get; }\r\n\r\n        ///// <" + "summary>\r\n        ///// An example of a valid value for this parameter.\r\n        ///// <" + "/summary>\r\n        //string? Example { get; }\r\n\r\n        ///// <" + "summary>\r\n        ///// The default value of this parameter, as a human readable string, if applicable.\r\n        ///// <" + "/summary>\r\n        //string? DefaultValueString { get; }\r\n\r\n        ///// <" + "summary>\r\n        ///// Requirements for using this parameter.\r\n        ///// <" + "/summary>\r\n        //string? Requirements { get; }\r\n    }\r\n}\r\n",
      "mutants": []
    },
    "Core\\Documentation\\Prettifier.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    internal static class Prettifier\r\n    {\r\n        internal static IEnumerable<" + "string> CreateMarkdownTable(IEnumerable<" + "IReadOnlyCollection<" + "string?>> rows)\r\n        {\r\n            var data = rows.SelectMany((row, rowNumber) =>\r\n                row.Select((text, columnNumber) =>\r\n                    (rowNumber, columnNumber, text: Escape(text)))\r\n                ).ToList();\r\n\r\n            var columnWidthDictionary = data.GroupBy(x => x.columnNumber)\r\n                .ToDictionary(x => x.Key,\r\n                    x => x.Max(c => c.text.EnumerateRunes().Count()));\r\n\r\n\r\n            foreach (var grouping in\r\n                data.GroupBy(d => d.rowNumber).OrderBy(x => x.Key))\r\n            {\r\n                var terms = new List<" + "string>();\r\n                var i = 0;\r\n                foreach (var (_, columnNumber, text) in grouping.OrderBy(r => r.columnNumber))\r\n                {\r\n                    while (i <" + " columnNumber)\r\n                    {\r\n                        terms.Add(new string(' ', columnWidthDictionary[i]));\r\n                        i++;\r\n                    }\r\n\r\n                    terms.Add(text.PadRight(columnWidthDictionary[columnNumber]));\r\n                    i++;\r\n                }\r\n\r\n                while (i <" + " columnWidthDictionary.Count)\r\n                {\r\n                    terms.Add(new string(' ', columnWidthDictionary[i]));\r\n                    i++;\r\n                }\r\n\r\n                var s = $\"|{string.Join('|', terms)}|\";\r\n                yield return s;\r\n\r\n                if (grouping.Key == 0) //create dashes row\r\n                {\r\n                    yield return @$\"|{\r\n                            string.Join('|', columnWidthDictionary\r\n                                .OrderBy(x => x.Key)\r\n                                .Select(x => \":\" + new string('-', Math.Max(x.Value - 2, 1)) + \":\"))\r\n                        }|\";\r\n                }\r\n            }\r\n\r\n            static string Escape(string? s)\r\n            {\r\n                return (s ?? string.Empty)\r\n                    .Replace(@\"\\\", @\"\\\\\")\r\n                    .Replace(@\"*\", @\"\\*\")\r\n                    .Replace(\"|\", @\"\\|\")\r\n                    .Replace(\"\\r\\n\", \"<" + "br>\")\r\n                    .Replace(\"\\n\", \" \");\r\n            }\r\n        }\r\n\r\n        internal static IEnumerable<" + "string> ArrangeIntoColumns(IEnumerable<" + "IReadOnlyCollection<" + "string?>> rows)\r\n        {\r\n            var data = rows.SelectMany((row, rowNumber) =>\r\n                row.SelectMany((text, columnNumber) =>\r\n                    (text ?? string.Empty).Split(\"\\n\")\r\n                    .Select((line, lineNumber) => (rowNumber, lineNumber, columnNumber, line))\r\n                )).ToList();\r\n\r\n            var columnWidthDictionary = data.GroupBy(x => x.columnNumber)\r\n                .ToDictionary(x => x.Key, x => x.Max(y => y.line.EnumerateRunes().Count()));\r\n\r\n\r\n            foreach (var grouping in\r\n                data.GroupBy(d => (d.rowNumber, d.lineNumber))\r\n\r\n                    .OrderBy(x => x.Key.rowNumber)\r\n                    .ThenBy(x => x.Key.lineNumber)\r\n                )\r\n            {\r\n\r\n                var terms = new List<" + "string>();\r\n                var i = 0;\r\n                foreach (var (_, _, columnNumber, line) in grouping.OrderBy(r => r.columnNumber))\r\n                {\r\n                    while (i <" + " columnNumber)\r\n                    {\r\n                        terms.Add(new string(' ', columnWidthDictionary[i]));\r\n                        i++;\r\n                    }\r\n\r\n                    terms.Add(line.PadRight(columnWidthDictionary[columnNumber]));\r\n                    i++;\r\n                }\r\n\r\n                var s = string.Join(' ', terms).TrimEnd();\r\n                yield return s;\r\n            }\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "395",
          "mutatorName": "Linq method mutation (Max() to Min())",
          "replacement": "x.Min(c => c.text.EnumerateRunes().Count())",
          "location": {
            "start": {
              "line": 18,
              "column": 26
            },
            "end": {
              "line": 18,
              "column": 69
            }
          },
          "status": "Killed"
        },
        {
          "id": "396",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "c.text.EnumerateRunes().Sum()",
          "location": {
            "start": {
              "line": 18,
              "column": 37
            },
            "end": {
              "line": 18,
              "column": 68
            }
          },
          "status": "CompileError"
        },
        {
          "id": "397",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "                data.GroupBy(d => d.rowNumber).OrderByDescending(x => x.Key)",
          "location": {
            "start": {
              "line": 22,
              "column": 17
            },
            "end": {
              "line": 22,
              "column": 67
            }
          },
          "status": "Survived"
        },
        {
          "id": "398",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "grouping.OrderByDescending(r => r.columnNumber)",
          "location": {
            "start": {
              "line": 26,
              "column": 57
            },
            "end": {
              "line": 26,
              "column": 94
            }
          },
          "status": "Killed"
        },
        {
          "id": "399",
          "mutatorName": "Equality mutation",
          "replacement": "i > columnNumber",
          "location": {
            "start": {
              "line": 28,
              "column": 28
            },
            "end": {
              "line": 28,
              "column": 44
            }
          },
          "status": "Survived"
        },
        {
          "id": "400",
          "mutatorName": "Equality mutation",
          "replacement": "i <" + "= columnNumber",
          "location": {
            "start": {
              "line": 28,
              "column": 28
            },
            "end": {
              "line": 28,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "401",
          "mutatorName": "Negate expression",
          "replacement": "!(i <" + " columnNumber)",
          "location": {
            "start": {
              "line": 28,
              "column": 28
            },
            "end": {
              "line": 28,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "402",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "                        i--",
          "location": {
            "start": {
              "line": 31,
              "column": 25
            },
            "end": {
              "line": 31,
              "column": 28
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "403",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "                    i--",
          "location": {
            "start": {
              "line": 35,
              "column": 21
            },
            "end": {
              "line": 35,
              "column": 24
            }
          },
          "status": "Killed"
        },
        {
          "id": "404",
          "mutatorName": "Equality mutation",
          "replacement": "i > columnWidthDictionary.Count",
          "location": {
            "start": {
              "line": 38,
              "column": 24
            },
            "end": {
              "line": 38,
              "column": 55
            }
          },
          "status": "CompileError"
        },
        {
          "id": "405",
          "mutatorName": "Equality mutation",
          "replacement": "i <" + "= columnWidthDictionary.Count",
          "location": {
            "start": {
              "line": 38,
              "column": 24
            },
            "end": {
              "line": 38,
              "column": 55
            }
          },
          "status": "CompileError"
        },
        {
          "id": "406",
          "mutatorName": "Negate expression",
          "replacement": "!(i <" + " columnWidthDictionary.Count)",
          "location": {
            "start": {
              "line": 38,
              "column": 24
            },
            "end": {
              "line": 38,
              "column": 55
            }
          },
          "status": "CompileError"
        },
        {
          "id": "407",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "                    i--",
          "location": {
            "start": {
              "line": 41,
              "column": 21
            },
            "end": {
              "line": 41,
              "column": 24
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "408",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 44,
              "column": 25
            },
            "end": {
              "line": 44,
              "column": 55
            }
          },
          "status": "Killed"
        },
        {
          "id": "409",
          "mutatorName": "Equality mutation",
          "replacement": "grouping.Key != 0",
          "location": {
            "start": {
              "line": 47,
              "column": 21
            },
            "end": {
              "line": 47,
              "column": 38
            }
          },
          "status": "Killed"
        },
        {
          "id": "410",
          "mutatorName": "Negate expression",
          "replacement": "!(grouping.Key == 0)",
          "location": {
            "start": {
              "line": 47,
              "column": 21
            },
            "end": {
              "line": 47,
              "column": 38
            }
          },
          "status": "Killed"
        },
        {
          "id": "411",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 49,
              "column": 34
            },
            "end": {
              "line": 53,
              "column": 28
            }
          },
          "status": "Killed"
        },
        {
          "id": "412",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "columnWidthDictionary\r\n                                .OrderByDescending(x => x.Key)\r\n                                .Select(x => \":\" + new string('-', Math.Max(x.Value - 2, 1)) + \":\")",
          "location": {
            "start": {
              "line": 50,
              "column": 46
            },
            "end": {
              "line": 52,
              "column": 100
            }
          },
          "status": "Killed"
        },
        {
          "id": "413",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 52,
              "column": 46
            },
            "end": {
              "line": 52,
              "column": 49
            }
          },
          "status": "Killed"
        },
        {
          "id": "414",
          "mutatorName": "Linq method mutation (Max() to Min())",
          "replacement": "Math.Min(x.Value - 2, 1)",
          "location": {
            "start": {
              "line": 52,
              "column": 68
            },
            "end": {
              "line": 52,
              "column": 92
            }
          },
          "status": "Killed"
        },
        {
          "id": "415",
          "mutatorName": "Arithmetic mutation",
          "replacement": "x.Value + 2",
          "location": {
            "start": {
              "line": 52,
              "column": 77
            },
            "end": {
              "line": 52,
              "column": 88
            }
          },
          "status": "Killed"
        },
        {
          "id": "416",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 52,
              "column": 96
            },
            "end": {
              "line": 52,
              "column": 99
            }
          },
          "status": "Killed"
        },
        {
          "id": "417",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 59,
              "column": 30
            },
            "end": {
              "line": 59,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "418",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 60,
              "column": 30
            },
            "end": {
              "line": 60,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "419",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 60,
              "column": 36
            },
            "end": {
              "line": 60,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "420",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 61,
              "column": 30
            },
            "end": {
              "line": 61,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "421",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 61,
              "column": 36
            },
            "end": {
              "line": 61,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "422",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 62,
              "column": 30
            },
            "end": {
              "line": 62,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "423",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 62,
              "column": 35
            },
            "end": {
              "line": 62,
              "column": 40
            }
          },
          "status": "Survived"
        },
        {
          "id": "424",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 63,
              "column": 30
            },
            "end": {
              "line": 63,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "425",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 63,
              "column": 38
            },
            "end": {
              "line": 63,
              "column": 44
            }
          },
          "status": "Survived"
        },
        {
          "id": "426",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 64,
              "column": 30
            },
            "end": {
              "line": 64,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "427",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 64,
              "column": 36
            },
            "end": {
              "line": 64,
              "column": 39
            }
          },
          "status": "Survived"
        },
        {
          "id": "428",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 72,
              "column": 30
            },
            "end": {
              "line": 72,
              "column": 42
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "429",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 72,
              "column": 50
            },
            "end": {
              "line": 72,
              "column": 54
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "430",
          "mutatorName": "Linq method mutation (Max() to Min())",
          "replacement": "x.Min(y => y.line.EnumerateRunes().Count())",
          "location": {
            "start": {
              "line": 77,
              "column": 48
            },
            "end": {
              "line": 77,
              "column": 91
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "431",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "y.line.EnumerateRunes().Sum()",
          "location": {
            "start": {
              "line": 77,
              "column": 59
            },
            "end": {
              "line": 77,
              "column": 90
            }
          },
          "status": "CompileError"
        },
        {
          "id": "432",
          "mutatorName": "Linq method mutation (ThenBy() to ThenByDescending())",
          "replacement": "                data.GroupBy(d => (d.rowNumber, d.lineNumber))\r\n\r\n                    .OrderBy(x => x.Key.rowNumber)\r\n                    .ThenByDescending(x => x.Key.lineNumber)\r\n",
          "location": {
            "start": {
              "line": 81,
              "column": 17
            },
            "end": {
              "line": 84,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "433",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "                data.GroupBy(d => (d.rowNumber, d.lineNumber))\r\n\r\n                    .OrderByDescending(x => x.Key.rowNumber)\r\n                    .ThenBy(x => x.Key.lineNumber)\r\n",
          "location": {
            "start": {
              "line": 81,
              "column": 17
            },
            "end": {
              "line": 84,
              "column": 51
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "434",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "grouping.OrderByDescending(r => r.columnNumber)",
          "location": {
            "start": {
              "line": 90,
              "column": 60
            },
            "end": {
              "line": 90,
              "column": 97
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "435",
          "mutatorName": "Equality mutation",
          "replacement": "i > columnNumber",
          "location": {
            "start": {
              "line": 92,
              "column": 28
            },
            "end": {
              "line": 92,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "436",
          "mutatorName": "Equality mutation",
          "replacement": "i <" + "= columnNumber",
          "location": {
            "start": {
              "line": 92,
              "column": 28
            },
            "end": {
              "line": 92,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "437",
          "mutatorName": "Negate expression",
          "replacement": "!(i <" + " columnNumber)",
          "location": {
            "start": {
              "line": 92,
              "column": 28
            },
            "end": {
              "line": 92,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "438",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "                        i--",
          "location": {
            "start": {
              "line": 95,
              "column": 25
            },
            "end": {
              "line": 95,
              "column": 28
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "439",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "                    i--",
          "location": {
            "start": {
              "line": 99,
              "column": 21
            },
            "end": {
              "line": 99,
              "column": 24
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Documentation\\StepWrapper.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing Namotion.Reflection;\r\nusing Reductech.EDR.Core.Attributes;\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    /// <" + "summary>\r\n    /// A wrapper for this documented object.\r\n    /// <" + "/summary>\r\n    public class StepWrapper : IDocumented\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new StepWrapper.\r\n        /// <" + "/summary>\r\n        public StepWrapper(IStepFactory factory, DocumentationCategory category)\r\n        {\r\n            Factory = factory;\r\n            DocumentationCategory = category;\r\n\r\n            RelevantProperties = factory.StepType.GetProperties()\r\n                .Select(property=> (property, attribute: property.GetCustomAttribute<" + "StepPropertyBaseAttribute>()))\r\n                .Where(x=>x.attribute != null)\r\n                // ReSharper disable once ConstantConditionalAccessQualifier\r\n                .OrderBy(x=>x.attribute!.Order)\r\n                .ThenBy(x=>x.property.Name)\r\n\r\n                .Select(x=>x.property).ToList();\r\n\r\n\r\n\r\n            Parameters = RelevantProperties.Select(GetPropertyWrapper).ToList();//TODO get default values\r\n\r\n\r\n            Requirements = factory.Requirements.Select(x => $\"Requires {x}\").ToList();\r\n\r\n            TypeDetails = factory.OutputTypeExplanation;\r\n        }\r\n\r\n        private static PropertyWrapper GetPropertyWrapper(PropertyInfo propertyInfo)\r\n        {\r\n            return new PropertyWrapper(propertyInfo, null);\r\n        }\r\n\r\n        private IStepFactory Factory { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public DocumentationCategory DocumentationCategory { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public string Name => Factory.StepType.Name;\r\n\r\n        /// <" + "inheritdoc />\r\n        public string Summary => Factory.StepType.GetXmlDocsSummary();\r\n\r\n        /// <" + "inheritdoc />\r\n        public string? TypeDetails { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "string> Requirements { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Properties of this step.\r\n        /// <" + "/summary>\r\n        protected IEnumerable<" + "PropertyInfo> RelevantProperties { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "IParameter> Parameters { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The wrapper for a property.\r\n        /// <" + "/summary>\r\n        protected class PropertyWrapper : IParameter\r\n        {\r\n            private readonly PropertyInfo _propertyInfo;\r\n\r\n            /// <" + "summary>\r\n            /// Creates a new PropertyWrapper.\r\n            /// <" + "/summary>\r\n            /// <" + "param name=\"propertyInfo\"><" + "/param>\r\n            /// <" + "param name=\"defaultValueString\"><" + "/param>\r\n            public PropertyWrapper(PropertyInfo propertyInfo, string? defaultValueString)\r\n            {\r\n                _propertyInfo = propertyInfo;\r\n                Required = _propertyInfo.GetCustomAttributes<" + "RequiredAttribute>().Any() && defaultValueString == null;\r\n\r\n                var explanation = propertyInfo.GetCustomAttribute<" + "DefaultValueExplanationAttribute>()?.Explanation;\r\n\r\n                var extraFields = new Dictionary<" + "string, string>();\r\n\r\n\r\n                var dvs = explanation == null ? defaultValueString : $\"{explanation}\"; //TODO make italic somehow\r\n\r\n                if(!string.IsNullOrWhiteSpace(dvs))\r\n                    extraFields.Add(\"Default Value\", dvs);\r\n\r\n                AddFieldFromAttribute<" + "ExampleAttribute>(\"Example\", extraFields, propertyInfo, x =>\r\n                {\r\n                    var equalsIndex = x.Example.IndexOf('=');\r\n\r\n                    if (equalsIndex >= 0 && equalsIndex != x.Example.Length)\r\n                    {\r\n                        var angleIndex = x.Example.IndexOf('<" + "');\r\n                        if (angleIndex <" + " 0 || angleIndex >= equalsIndex)\r\n                            return x.Example.Substring(equalsIndex + 1);\r\n                    }\r\n\r\n                    return x.Example;\r\n                });\r\n                AddFieldFromAttribute<" + "RequiredVersionAttribute>(\"Requirements\", extraFields, propertyInfo, x=>x.Text);\r\n                AddFieldFromAttribute<" + "DocumentationURLAttribute>(\"URL\", extraFields, propertyInfo, x=>$\"[{propertyInfo.Name}]({ x.DocumentationURL})\");\r\n                AddFieldFromAttribute<" + "RecommendedRangeAttribute>(\"Recommended Range\", extraFields, propertyInfo, x=>x.RecommendedRange);\r\n                AddFieldFromAttribute<" + "RecommendedValueAttribute>(\"Recommended Value\", extraFields, propertyInfo, x=>x.RecommendedValue);\r\n                AddFieldFromAttribute<" + "AllowedRangeAttribute>(\"Allowed Range\", extraFields, propertyInfo, x=>x.AllowedRangeValue);\r\n                AddFieldFromAttribute<" + "SeeAlsoAttribute>(\"See Also\", extraFields, propertyInfo, x=>x.SeeAlso);\r\n                AddFieldFromAttribute<" + "ValueDelimiterAttribute>(\"Value Delimiter\", extraFields, propertyInfo, x=>x.Delimiter);\r\n\r\n                ExtraFields = extraFields;\r\n\r\n                Type = _propertyInfo.PropertyType.IsGenericType?\r\n                    _propertyInfo.PropertyType.GetGenericArguments()[0] : _propertyInfo.PropertyType;\r\n            }\r\n\r\n            private static void AddFieldFromAttribute<" + "T>(\r\n                string name,\r\n                IDictionary<" + "string, string> dictionary, MemberInfo propertyInfo, Func<" + "T, string> getAttributeText) where T : Attribute\r\n            {\r\n                var s = string.Join(\"\\r\\n\", propertyInfo.GetCustomAttributes<" + "T>().Select(getAttributeText));\r\n\r\n                if (!string.IsNullOrWhiteSpace(s))\r\n                {\r\n                    dictionary.Add(name, s);\r\n                }\r\n            }\r\n\r\n            /// <" + "summary>\r\n            /// The name of the property.\r\n            /// <" + "/summary>\r\n            public string Name => _propertyInfo.Name;\r\n\r\n            /// <" + "summary>\r\n            /// A summary of the property.\r\n            /// <" + "/summary>\r\n            public string Summary => _propertyInfo.GetXmlDocsSummary();\r\n\r\n            /// <" + "summary>\r\n            /// The type of this property.\r\n            /// <" + "/summary>\r\n            public Type Type { get; }\r\n\r\n            /// <" + "summary>\r\n            /// Whether this property must be set.\r\n            /// <" + "/summary>\r\n            public bool Required { get; }\r\n\r\n            /// <" + "inheritdoc />\r\n            public IReadOnlyDictionary<" + "string, string> ExtraFields { get; }\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "440",
          "mutatorName": "Linq method mutation (ThenBy() to ThenByDescending())",
          "replacement": "factory.StepType.GetProperties()\r\n                .Select(property=> (property, attribute: property.GetCustomAttribute<" + "StepPropertyBaseAttribute>()))\r\n                .Where(x=>x.attribute != null)\r\n                // ReSharper disable once ConstantConditionalAccessQualifier\r\n                .OrderBy(x=>x.attribute!.Order)\r\n                .ThenByDescending(x=>x.property.Name)\r\n\r\n                .Select(x=>x.property).ToList()",
          "location": {
            "start": {
              "line": 23,
              "column": 34
            },
            "end": {
              "line": 30,
              "column": 48
            }
          },
          "status": "Survived"
        },
        {
          "id": "441",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "factory.StepType.GetProperties()\r\n                .Select(property=> (property, attribute: property.GetCustomAttribute<" + "StepPropertyBaseAttribute>()))\r\n                .Where(x=>x.attribute != null)\r\n                // ReSharper disable once ConstantConditionalAccessQualifier\r\n                .OrderByDescending(x=>x.attribute!.Order)\r\n                .ThenBy(x=>x.property.Name)\r\n\r\n                .Select(x=>x.property).ToList()",
          "location": {
            "start": {
              "line": 23,
              "column": 34
            },
            "end": {
              "line": 30,
              "column": 48
            }
          },
          "status": "Survived"
        },
        {
          "id": "442",
          "mutatorName": "Equality mutation",
          "replacement": "x.attribute == null",
          "location": {
            "start": {
              "line": 25,
              "column": 27
            },
            "end": {
              "line": 25,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "443",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 37,
              "column": 61
            },
            "end": {
              "line": 37,
              "column": 76
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "444",
          "mutatorName": "Logical mutation",
          "replacement": "_propertyInfo.GetCustomAttributes<" + "RequiredAttribute>().Any() || defaultValueString == null",
          "location": {
            "start": {
              "line": 87,
              "column": 28
            },
            "end": {
              "line": 87,
              "column": 118
            }
          },
          "status": "Survived"
        },
        {
          "id": "445",
          "mutatorName": "Equality mutation",
          "replacement": "defaultValueString != null",
          "location": {
            "start": {
              "line": 87,
              "column": 92
            },
            "end": {
              "line": 87,
              "column": 118
            }
          },
          "status": "Killed"
        },
        {
          "id": "446",
          "mutatorName": "Equality mutation",
          "replacement": "explanation != null ",
          "location": {
            "start": {
              "line": 94,
              "column": 27
            },
            "end": {
              "line": 94,
              "column": 46
            }
          },
          "status": "Survived"
        },
        {
          "id": "447",
          "mutatorName": "Negate expression",
          "replacement": "!(explanation == null )",
          "location": {
            "start": {
              "line": 94,
              "column": 27
            },
            "end": {
              "line": 94,
              "column": 46
            }
          },
          "status": "Survived"
        },
        {
          "id": "448",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 94,
              "column": 70
            },
            "end": {
              "line": 94,
              "column": 86
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "449",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "string.IsNullOrWhiteSpace(dvs)",
          "location": {
            "start": {
              "line": 96,
              "column": 20
            },
            "end": {
              "line": 96,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "450",
          "mutatorName": "Negate expression",
          "replacement": "!(!string.IsNullOrWhiteSpace(dvs))",
          "location": {
            "start": {
              "line": 96,
              "column": 20
            },
            "end": {
              "line": 96,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "451",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 97,
              "column": 37
            },
            "end": {
              "line": 97,
              "column": 52
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "452",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 99,
              "column": 57
            },
            "end": {
              "line": 99,
              "column": 66
            }
          },
          "status": "Survived"
        },
        {
          "id": "453",
          "mutatorName": "Logical mutation",
          "replacement": "equalsIndex >= 0 || equalsIndex != x.Example.Length",
          "location": {
            "start": {
              "line": 103,
              "column": 25
            },
            "end": {
              "line": 103,
              "column": 76
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "454",
          "mutatorName": "Negate expression",
          "replacement": "!(equalsIndex >= 0 && equalsIndex != x.Example.Length)",
          "location": {
            "start": {
              "line": 103,
              "column": 25
            },
            "end": {
              "line": 103,
              "column": 76
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "455",
          "mutatorName": "Equality mutation",
          "replacement": "equalsIndex <" + " 0 ",
          "location": {
            "start": {
              "line": 103,
              "column": 25
            },
            "end": {
              "line": 103,
              "column": 41
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "456",
          "mutatorName": "Equality mutation",
          "replacement": "equalsIndex > 0 ",
          "location": {
            "start": {
              "line": 103,
              "column": 25
            },
            "end": {
              "line": 103,
              "column": 41
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "457",
          "mutatorName": "Equality mutation",
          "replacement": "equalsIndex == x.Example.Length",
          "location": {
            "start": {
              "line": 103,
              "column": 45
            },
            "end": {
              "line": 103,
              "column": 76
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "458",
          "mutatorName": "Logical mutation",
          "replacement": "angleIndex <" + " 0 && angleIndex >= equalsIndex",
          "location": {
            "start": {
              "line": 106,
              "column": 29
            },
            "end": {
              "line": 106,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "459",
          "mutatorName": "Negate expression",
          "replacement": "!(angleIndex <" + " 0 || angleIndex >= equalsIndex)",
          "location": {
            "start": {
              "line": 106,
              "column": 29
            },
            "end": {
              "line": 106,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "460",
          "mutatorName": "Equality mutation",
          "replacement": "angleIndex > 0 ",
          "location": {
            "start": {
              "line": 106,
              "column": 29
            },
            "end": {
              "line": 106,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "461",
          "mutatorName": "Equality mutation",
          "replacement": "angleIndex <" + "= 0 ",
          "location": {
            "start": {
              "line": 106,
              "column": 29
            },
            "end": {
              "line": 106,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "462",
          "mutatorName": "Equality mutation",
          "replacement": "angleIndex <" + " equalsIndex",
          "location": {
            "start": {
              "line": 106,
              "column": 47
            },
            "end": {
              "line": 106,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "463",
          "mutatorName": "Equality mutation",
          "replacement": "angleIndex > equalsIndex",
          "location": {
            "start": {
              "line": 106,
              "column": 47
            },
            "end": {
              "line": 106,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "464",
          "mutatorName": "Arithmetic mutation",
          "replacement": "equalsIndex - 1",
          "location": {
            "start": {
              "line": 107,
              "column": 56
            },
            "end": {
              "line": 107,
              "column": 71
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "465",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 112,
              "column": 65
            },
            "end": {
              "line": 112,
              "column": 79
            }
          },
          "status": "Survived"
        },
        {
          "id": "466",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 113,
              "column": 66
            },
            "end": {
              "line": 113,
              "column": 71
            }
          },
          "status": "Survived"
        },
        {
          "id": "467",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 113,
              "column": 103
            },
            "end": {
              "line": 113,
              "column": 150
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "468",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 114,
              "column": 66
            },
            "end": {
              "line": 114,
              "column": 85
            }
          },
          "status": "Survived"
        },
        {
          "id": "469",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 115,
              "column": 66
            },
            "end": {
              "line": 115,
              "column": 85
            }
          },
          "status": "Survived"
        },
        {
          "id": "470",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 116,
              "column": 62
            },
            "end": {
              "line": 116,
              "column": 77
            }
          },
          "status": "Survived"
        },
        {
          "id": "471",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 117,
              "column": 57
            },
            "end": {
              "line": 117,
              "column": 67
            }
          },
          "status": "Survived"
        },
        {
          "id": "472",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 118,
              "column": 64
            },
            "end": {
              "line": 118,
              "column": 81
            }
          },
          "status": "Survived"
        },
        {
          "id": "473",
          "mutatorName": "Negate expression",
          "replacement": "!(_propertyInfo.PropertyType.IsGenericType)",
          "location": {
            "start": {
              "line": 122,
              "column": 24
            },
            "end": {
              "line": 122,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "474",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 130,
              "column": 37
            },
            "end": {
              "line": 130,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "475",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "string.IsNullOrWhiteSpace(s)",
          "location": {
            "start": {
              "line": 132,
              "column": 21
            },
            "end": {
              "line": 132,
              "column": 50
            }
          },
          "status": "Killed"
        },
        {
          "id": "476",
          "mutatorName": "Negate expression",
          "replacement": "!(!string.IsNullOrWhiteSpace(s))",
          "location": {
            "start": {
              "line": 132,
              "column": 21
            },
            "end": {
              "line": 132,
              "column": 50
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Documentation\\TypeNameHelper.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Reductech.EDR.Core.Internal.Documentation\r\n{\r\n    internal static class TypeNameHelper\r\n    {\r\n\r\n        public static string GetMarkupTypeName(Type t)\r\n        {\r\n            if (TypeAliases.TryGetValue(t, out var name))\r\n                return $\"`{name}`\";\r\n\r\n            if (t.IsEnum)\r\n                return $\"[{t.Name}](#{t.Name})\";\r\n\r\n            if (!t.IsGenericType)\r\n                return $\"[{t.Name}](#{t.Name})\";\r\n\r\n            if (t.GetGenericTypeDefinition() == typeof(Nullable<" + ">))\r\n            {\r\n                var underlyingType = Nullable.GetUnderlyingType(t);\r\n                if (underlyingType == null) return t.Name;\r\n                return GetMarkupTypeName(underlyingType) + \"?\";\r\n            }\r\n\r\n            var typeName = t.Name.Split(\"`\")[0];\r\n\r\n            var arguments = $\"<" + "{string.Join(\",\", t.GetGenericArguments().Select(GetMarkupTypeName))}>\";\r\n\r\n            return typeName + arguments;\r\n        }\r\n\r\n        public static string GetHumanReadableTypeName(Type t)\r\n        {\r\n            if (TypeAliases.TryGetValue(t, out var name))\r\n                return name;\r\n\r\n            if (!t.IsGenericType)\r\n                return t.Name;\r\n\r\n            if (t.GetGenericTypeDefinition() == typeof(Nullable<" + ">))\r\n            {\r\n                var underlyingType = Nullable.GetUnderlyingType(t);\r\n                if (underlyingType == null) return t.Name;\r\n                return GetHumanReadableTypeName(underlyingType) + \"?\";\r\n            }\r\n\r\n            var typeName = t.Name.Split(\"`\")[0];\r\n\r\n            var arguments = $\"<" + "{string.Join(\",\", t.GetGenericArguments().Select(GetHumanReadableTypeName))}>\";\r\n\r\n            return typeName + arguments;\r\n        }\r\n\r\n        private static readonly Dictionary<" + "Type, string> TypeAliases =\r\n            new Dictionary<" + "Type, string>()\r\n            {\r\n                { typeof(byte), \"byte\" },\r\n                { typeof(sbyte), \"sbyte\" },\r\n                { typeof(short), \"short\" },\r\n                { typeof(ushort), \"ushort\" },\r\n                { typeof(int), \"int\" },\r\n                { typeof(uint), \"uint\" },\r\n                { typeof(long), \"long\" },\r\n                { typeof(ulong), \"ulong\" },\r\n                { typeof(float), \"float\" },\r\n                { typeof(double), \"double\" },\r\n                { typeof(decimal), \"decimal\" },\r\n                { typeof(object), \"object\" },\r\n                { typeof(bool), \"bool\" },\r\n                { typeof(char), \"char\" },\r\n                { typeof(string), \"string\" },\r\n                { typeof(void), \"void\" }\r\n            };\r\n\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "477",
          "mutatorName": "Negate expression",
          "replacement": "!(TypeAliases.TryGetValue(t, out var name))",
          "location": {
            "start": {
              "line": 12,
              "column": 17
            },
            "end": {
              "line": 12,
              "column": 57
            }
          },
          "status": "Killed"
        },
        {
          "id": "478",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 13,
              "column": 24
            },
            "end": {
              "line": 13,
              "column": 35
            }
          },
          "status": "Killed"
        },
        {
          "id": "479",
          "mutatorName": "Negate expression",
          "replacement": "!(t.IsEnum)",
          "location": {
            "start": {
              "line": 15,
              "column": 17
            },
            "end": {
              "line": 15,
              "column": 25
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "480",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 16,
              "column": 24
            },
            "end": {
              "line": 16,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "481",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "t.IsGenericType",
          "location": {
            "start": {
              "line": 18,
              "column": 17
            },
            "end": {
              "line": 18,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "482",
          "mutatorName": "Negate expression",
          "replacement": "!(!t.IsGenericType)",
          "location": {
            "start": {
              "line": 18,
              "column": 17
            },
            "end": {
              "line": 18,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "483",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 19,
              "column": 24
            },
            "end": {
              "line": 19,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "484",
          "mutatorName": "Equality mutation",
          "replacement": "t.GetGenericTypeDefinition() != typeof(Nullable<" + ">)",
          "location": {
            "start": {
              "line": 21,
              "column": 17
            },
            "end": {
              "line": 21,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "485",
          "mutatorName": "Negate expression",
          "replacement": "!(t.GetGenericTypeDefinition() == typeof(Nullable<" + ">))",
          "location": {
            "start": {
              "line": 21,
              "column": 17
            },
            "end": {
              "line": 21,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "486",
          "mutatorName": "Equality mutation",
          "replacement": "underlyingType != null",
          "location": {
            "start": {
              "line": 24,
              "column": 21
            },
            "end": {
              "line": 24,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "487",
          "mutatorName": "Negate expression",
          "replacement": "!(underlyingType == null)",
          "location": {
            "start": {
              "line": 24,
              "column": 21
            },
            "end": {
              "line": 24,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "488",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 25,
              "column": 60
            },
            "end": {
              "line": 25,
              "column": 63
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "489",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 28,
              "column": 41
            },
            "end": {
              "line": 28,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "490",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 30,
              "column": 29
            },
            "end": {
              "line": 30,
              "column": 103
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "491",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 30,
              "column": 45
            },
            "end": {
              "line": 30,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "492",
          "mutatorName": "Arithmetic mutation",
          "replacement": "typeName - arguments",
          "location": {
            "start": {
              "line": 32,
              "column": 20
            },
            "end": {
              "line": 32,
              "column": 40
            }
          },
          "status": "CompileError"
        },
        {
          "id": "493",
          "mutatorName": "Negate expression",
          "replacement": "!(TypeAliases.TryGetValue(t, out var name))",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 57
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "494",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "t.IsGenericType",
          "location": {
            "start": {
              "line": 40,
              "column": 17
            },
            "end": {
              "line": 40,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "495",
          "mutatorName": "Negate expression",
          "replacement": "!(!t.IsGenericType)",
          "location": {
            "start": {
              "line": 40,
              "column": 17
            },
            "end": {
              "line": 40,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "496",
          "mutatorName": "Equality mutation",
          "replacement": "t.GetGenericTypeDefinition() != typeof(Nullable<" + ">)",
          "location": {
            "start": {
              "line": 43,
              "column": 17
            },
            "end": {
              "line": 43,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "497",
          "mutatorName": "Negate expression",
          "replacement": "!(t.GetGenericTypeDefinition() == typeof(Nullable<" + ">))",
          "location": {
            "start": {
              "line": 43,
              "column": 17
            },
            "end": {
              "line": 43,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "498",
          "mutatorName": "Equality mutation",
          "replacement": "underlyingType != null",
          "location": {
            "start": {
              "line": 46,
              "column": 21
            },
            "end": {
              "line": 46,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "499",
          "mutatorName": "Negate expression",
          "replacement": "!(underlyingType == null)",
          "location": {
            "start": {
              "line": 46,
              "column": 21
            },
            "end": {
              "line": 46,
              "column": 43
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "500",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 47,
              "column": 67
            },
            "end": {
              "line": 47,
              "column": 70
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "501",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 50,
              "column": 41
            },
            "end": {
              "line": 50,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "502",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 52,
              "column": 29
            },
            "end": {
              "line": 52,
              "column": 110
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "503",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 52,
              "column": 45
            },
            "end": {
              "line": 52,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "504",
          "mutatorName": "Arithmetic mutation",
          "replacement": "typeName - arguments",
          "location": {
            "start": {
              "line": 54,
              "column": 20
            },
            "end": {
              "line": 54,
              "column": 40
            }
          },
          "status": "CompileError"
        },
        {
          "id": "505",
          "mutatorName": "Collection initializer mutation",
          "replacement": "            new Dictionary<" + "Type, string>()\r\n{}",
          "location": {
            "start": {
              "line": 58,
              "column": 13
            },
            "end": {
              "line": 76,
              "column": 14
            }
          },
          "status": "Killed"
        },
        {
          "id": "506",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 60,
              "column": 33
            },
            "end": {
              "line": 60,
              "column": 39
            }
          },
          "status": "Survived"
        },
        {
          "id": "507",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 61,
              "column": 34
            },
            "end": {
              "line": 61,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "508",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 62,
              "column": 34
            },
            "end": {
              "line": 62,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "509",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 63,
              "column": 35
            },
            "end": {
              "line": 63,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "510",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 64,
              "column": 32
            },
            "end": {
              "line": 64,
              "column": 37
            }
          },
          "status": "Survived"
        },
        {
          "id": "511",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 65,
              "column": 33
            },
            "end": {
              "line": 65,
              "column": 39
            }
          },
          "status": "Survived"
        },
        {
          "id": "512",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 66,
              "column": 33
            },
            "end": {
              "line": 66,
              "column": 39
            }
          },
          "status": "Survived"
        },
        {
          "id": "513",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 67,
              "column": 34
            },
            "end": {
              "line": 67,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "514",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 68,
              "column": 34
            },
            "end": {
              "line": 68,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "515",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 69,
              "column": 35
            },
            "end": {
              "line": 69,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "516",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 70,
              "column": 36
            },
            "end": {
              "line": 70,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "517",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 71,
              "column": 35
            },
            "end": {
              "line": 71,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "518",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 72,
              "column": 33
            },
            "end": {
              "line": 72,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "519",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 73,
              "column": 33
            },
            "end": {
              "line": 73,
              "column": 39
            }
          },
          "status": "Survived"
        },
        {
          "id": "520",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 74,
              "column": 35
            },
            "end": {
              "line": 74,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "521",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 75,
              "column": 33
            },
            "end": {
              "line": 75,
              "column": 39
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Internal\\ErrorCode.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Identifying code for an error message.\r\n    /// <" + "/summary>\r\n    public enum ErrorCode\r\n    {\r\n        /// <" + "summary>\r\n        /// Variable does not exist.\r\n        /// <" + "/summary>\r\n        MissingVariable,\r\n\r\n        /// <" + "summary>\r\n        /// Variable has the wrong type.\r\n        /// <" + "/summary>\r\n        WrongVariableType,\r\n\r\n        /// <" + "summary>\r\n        /// Index was out of the range of an array or string.\r\n        /// <" + "/summary>\r\n        IndexOutOfBounds,\r\n\r\n        /// <" + "summary>\r\n        /// An error in an external step.\r\n        /// <" + "/summary>\r\n        ExternalProcessError,\r\n\r\n        /// <" + "summary>\r\n        /// The external step did not return an output of the expected form.\r\n        /// <" + "/summary>\r\n        ExternalProcessMissingOutput,\r\n\r\n        /// <" + "summary>\r\n        /// The external step was not found.\r\n        /// <" + "/summary>\r\n        ExternalProcessNotFound,\r\n\r\n        /// <" + "summary>\r\n        /// The requirements for a step were not met.\r\n        /// <" + "/summary>\r\n        RequirementsNotMet,\r\n\r\n        /// <" + "summary>\r\n        /// Cast failed.\r\n        /// <" + "/summary>\r\n        InvalidCast,\r\n\r\n        /// <" + "summary>\r\n        /// Step settings are missing\r\n        /// <" + "/summary>\r\n        MissingStepSettings,\r\n\r\n        /// <" + "summary>\r\n        /// A required parameter was not set.\r\n        /// <" + "/summary>\r\n        MissingParameter,\r\n\r\n        /// <" + "summary>\r\n        /// Parameters conflict.\r\n        /// <" + "/summary>\r\n        ConflictingParameters,\r\n\r\n        /// <" + "summary>\r\n        /// An assertion failed\r\n        /// <" + "/summary>\r\n        AssertionFailed,\r\n\r\n        /// <" + "summary>\r\n        /// An error reading a CSV file\r\n        /// <" + "/summary>\r\n        CSVError\r\n\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\ErrorHelper.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Easy access to common errors.\r\n    /// <" + "/summary>\r\n    public static class ErrorHelper\r\n    {\r\n        /// <" + "summary>\r\n        /// The error that should be returned when a parameter is missing.\r\n        /// <" + "/summary>\r\n        public static IRunErrors MissingParameterError(string parameterName, string stepName)\r\n            => new RunError($\"Missing Parameter '{parameterName}'\", stepName, null , ErrorCode.MissingParameter);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "522",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 12,
              "column": 29
            },
            "end": {
              "line": 12,
              "column": 67
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\FreezableStepData.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// The data used by a Freezable Step.\r\n    /// <" + "/summary>\r\n    public sealed class FreezableStepData : IEquatable<" + "FreezableStepData>\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new FreezableStepData\r\n        /// <" + "/summary>\r\n        public FreezableStepData(IReadOnlyDictionary<" + "string, StepMember> dictionary) => Dictionary =\r\n            dictionary.ToDictionary(x=>x.Key, x=>x.Value, StringComparer.OrdinalIgnoreCase)!;\r\n\r\n        /// <" + "summary>\r\n        /// Dictionary mapping property names to step members.\r\n        /// <" + "/summary>\r\n        public IReadOnlyDictionary<" + "string, StepMember> Dictionary { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Gets a variable name.\r\n        /// <" + "/summary>\r\n        public Result<" + "VariableName> GetVariableName(string name) =>\r\n            Dictionary.TryFindOrFail(name, null).Bind(x => x.AsVariableName(name));\r\n\r\n        /// <" + "summary>\r\n        /// Gets an argument.\r\n        /// <" + "/summary>\r\n        public Result<" + "IFreezableStep> GetArgument(string name) =>\r\n            Dictionary.TryFindOrFail(name, null).Bind(x => x.AsArgument(name));\r\n\r\n        /// <" + "summary>\r\n        /// Gets a list argument.\r\n        /// <" + "/summary>\r\n        public Result<" + "IReadOnlyList<" + "IFreezableStep>> GetListArgument(string name) =>\r\n            Dictionary.TryFindOrFail(name, null).Bind(x => x.AsListArgument(name));\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString()\r\n        {\r\n            return new\r\n            {\r\n                Variables = Dictionary.Count(x => x.Value.MemberType == MemberType.VariableName),\r\n                Steps = Dictionary.Count(x => x.Value.MemberType == MemberType.Step),\r\n                StepLists = Dictionary.Count(x => x.Value.MemberType == MemberType.StepList)\r\n            }.ToString()!;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(FreezableStepData? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n            return DictionariesEqual(Dictionary, other.Dictionary);\r\n\r\n            static bool DictionariesEqual(IReadOnlyDictionary<" + "string, StepMember> dict1, IReadOnlyDictionary<" + "string, StepMember> dict2) =>\r\n                dict1.Count == dict2.Count &&\r\n                dict1.Keys.All(key => dict2.ContainsKey(key) && dict1[key].Equals(dict2[key]));\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is FreezableStepData other && Equals(this, other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => Dictionary.GetHashCode();\r\n\r\n        /// <" + "summary>\r\n        /// Equals Operator\r\n        /// <" + "/summary>\r\n        public static bool operator ==(FreezableStepData? left, FreezableStepData? right) => Equals(left, right);\r\n\r\n        /// <" + "summary>\r\n        /// Not Equals Operator\r\n        /// <" + "/summary>\r\n        public static bool operator !=(FreezableStepData? left, FreezableStepData? right) => !Equals(left, right);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "523",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "Dictionary.Sum(x => x.Value.MemberType == MemberType.VariableName)",
          "location": {
            "start": {
              "line": 48,
              "column": 29
            },
            "end": {
              "line": 48,
              "column": 97
            }
          },
          "status": "CompileError"
        },
        {
          "id": "524",
          "mutatorName": "Equality mutation",
          "replacement": "x.Value.MemberType != MemberType.VariableName",
          "location": {
            "start": {
              "line": 48,
              "column": 51
            },
            "end": {
              "line": 48,
              "column": 96
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "525",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "Dictionary.Sum(x => x.Value.MemberType == MemberType.Step)",
          "location": {
            "start": {
              "line": 49,
              "column": 25
            },
            "end": {
              "line": 49,
              "column": 85
            }
          },
          "status": "CompileError"
        },
        {
          "id": "526",
          "mutatorName": "Equality mutation",
          "replacement": "x.Value.MemberType != MemberType.Step",
          "location": {
            "start": {
              "line": 49,
              "column": 47
            },
            "end": {
              "line": 49,
              "column": 84
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "527",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "Dictionary.Sum(x => x.Value.MemberType == MemberType.StepList)\r\n",
          "location": {
            "start": {
              "line": 50,
              "column": 29
            },
            "end": {
              "line": 50,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "528",
          "mutatorName": "Equality mutation",
          "replacement": "x.Value.MemberType != MemberType.StepList",
          "location": {
            "start": {
              "line": 50,
              "column": 51
            },
            "end": {
              "line": 50,
              "column": 92
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "529",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 57,
              "column": 39
            },
            "end": {
              "line": 57,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "530",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 58,
              "column": 17
            },
            "end": {
              "line": 58,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "531",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 58,
              "column": 54
            },
            "end": {
              "line": 58,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "532",
          "mutatorName": "Logical mutation",
          "replacement": "                dict1.Count == dict2.Count ||\r\n                dict1.Keys.All(key => dict2.ContainsKey(key) && dict1[key].Equals(dict2[key]))",
          "location": {
            "start": {
              "line": 62,
              "column": 17
            },
            "end": {
              "line": 63,
              "column": 95
            }
          },
          "status": "Survived"
        },
        {
          "id": "533",
          "mutatorName": "Equality mutation",
          "replacement": "                dict1.Count != dict2.Count ",
          "location": {
            "start": {
              "line": 62,
              "column": 17
            },
            "end": {
              "line": 62,
              "column": 43
            }
          },
          "status": "Killed"
        },
        {
          "id": "534",
          "mutatorName": "Linq method mutation (All() to Any())",
          "replacement": "                dict1.Keys.Any(key => dict2.ContainsKey(key) && dict1[key].Equals(dict2[key]))",
          "location": {
            "start": {
              "line": 63,
              "column": 17
            },
            "end": {
              "line": 63,
              "column": 95
            }
          },
          "status": "Survived"
        },
        {
          "id": "535",
          "mutatorName": "Logical mutation",
          "replacement": "dict2.ContainsKey(key) || dict1[key].Equals(dict2[key])",
          "location": {
            "start": {
              "line": 63,
              "column": 39
            },
            "end": {
              "line": 63,
              "column": 94
            }
          },
          "status": "Survived"
        },
        {
          "id": "536",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is FreezableStepData other && Equals(this, other)",
          "location": {
            "start": {
              "line": 67,
              "column": 53
            },
            "end": {
              "line": 67,
              "column": 136
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "537",
          "mutatorName": "Logical mutation",
          "replacement": "obj is FreezableStepData other || Equals(this, other)",
          "location": {
            "start": {
              "line": 67,
              "column": 83
            },
            "end": {
              "line": 67,
              "column": 136
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "538",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "Equals(left, right)",
          "location": {
            "start": {
              "line": 80,
              "column": 94
            },
            "end": {
              "line": 80,
              "column": 114
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\FreezableStepExtensions.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// SerializationMethods methods for steps.\r\n    /// <" + "/summary>\r\n    public static class FreezableStepExtensions\r\n    {\r\n        /// <" + "summary>\r\n        /// Tries to freeze this step.\r\n        /// <" + "/summary>\r\n        public static Result<" + "IStep> TryFreeze(this IFreezableStep step) =>\r\n            StepContext.TryCreate(step)\r\n                .Bind(step.TryFreeze);\r\n\r\n\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\GenericStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Step factory for generic types.\r\n    /// <" + "/summary>\r\n    public abstract class GenericStepFactory : StepFactory\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "ITypeReference> TryGetOutputTypeReference(FreezableStepData freezableStepData) => GetMemberType(freezableStepData).Map(GetOutputTypeReference);\r\n\r\n        /// <" + "summary>\r\n        /// Gets the output type from the member type.\r\n        /// <" + "/summary>\r\n        protected abstract ITypeReference GetOutputTypeReference(ITypeReference memberTypeReference);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new DefaultStepNameBuilder(TypeName);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => ImmutableList<" + "Type>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ICompoundStep> TryCreateInstance(StepContext stepContext, FreezableStepData freezableStepData) =>\r\n            GetMemberType(freezableStepData)\r\n                .Bind(stepContext.TryGetTypeFromReference)\r\n                .Bind(x => TryCreateGeneric(StepType, x));\r\n\r\n        /// <" + "summary>\r\n        /// Gets the type\r\n        /// <" + "/summary>\r\n        protected abstract Result<" + "ITypeReference> GetMemberType(FreezableStepData freezableStepData);\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\GenericTypeReference.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.Linq;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// An instance of a generic type.\r\n    /// <" + "/summary>\r\n    public sealed class GenericTypeReference : ITypeReference, IEquatable<" + "ITypeReference>\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new GenericTypeReference.\r\n        /// <" + "/summary>\r\n        public GenericTypeReference(Type genericType, IReadOnlyList<" + "ITypeReference> childTypes)\r\n        {\r\n            GenericType = genericType;\r\n            ChildTypes = childTypes;\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "VariableTypeReference> VariableTypeReferences => ImmutableList<" + "VariableTypeReference>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "ActualTypeReference> ActualTypeReferences => ImmutableList<" + "ActualTypeReference>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "ITypeReference> TypeArgumentReferences => ChildTypes;\r\n\r\n        /// <" + "summary>\r\n        /// The generic type.\r\n        /// <" + "/summary>\r\n        public Type GenericType { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The generic type members.\r\n        /// <" + "/summary>\r\n        public IReadOnlyList<" + "ITypeReference> ChildTypes { get; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(ITypeReference? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n\r\n            return other is GenericTypeReference gtr && GenericType == gtr.GenericType &&\r\n                   ChildTypes.SequenceEqual(gtr.ChildTypes);\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "539",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 45,
              "column": 39
            },
            "end": {
              "line": 45,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "540",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 46,
              "column": 17
            },
            "end": {
              "line": 46,
              "column": 45
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "541",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 46,
              "column": 54
            },
            "end": {
              "line": 46,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "542",
          "mutatorName": "Logical mutation",
          "replacement": "other is GenericTypeReference gtr && GenericType == gtr.GenericType ||\r\n                   ChildTypes.SequenceEqual(gtr.ChildTypes)",
          "location": {
            "start": {
              "line": 48,
              "column": 20
            },
            "end": {
              "line": 49,
              "column": 60
            }
          },
          "status": "CompileError"
        },
        {
          "id": "543",
          "mutatorName": "Logical mutation",
          "replacement": "other is GenericTypeReference gtr || GenericType == gtr.GenericType ",
          "location": {
            "start": {
              "line": 48,
              "column": 20
            },
            "end": {
              "line": 48,
              "column": 87
            }
          },
          "status": "CompileError"
        },
        {
          "id": "544",
          "mutatorName": "Equality mutation",
          "replacement": "GenericType != gtr.GenericType ",
          "location": {
            "start": {
              "line": 48,
              "column": 57
            },
            "end": {
              "line": 48,
              "column": 87
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\ICompoundStep.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A runnable step that is not a constant.\r\n    /// <" + "/summary>\r\n    public interface ICompoundStep : IStep\r\n    {\r\n        /// <" + "summary>\r\n        /// The factory used to create steps of this type.\r\n        /// <" + "/summary>\r\n        IStepFactory StepFactory { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Requirements for this step that can only be determined at runtime.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "Requirement> RuntimeRequirements { get; }\r\n\r\n\r\n    }\r\n\r\n    /// <" + "summary>\r\n    /// A runnable step that is not a constant.\r\n    /// <" + "/summary>\r\n    public interface ICompoundStep<" + "T> : IStep<" + "T>, ICompoundStep\r\n    {\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IConstantStep.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step that returns a fixed value when run.\r\n    /// <" + "/summary>\r\n    public interface IConstantStep : IStep\r\n    {\r\n        /// <" + "summary>\r\n        /// The output type.\r\n        /// <" + "/summary>\r\n        Type OutputType { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IFreezableStep.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step which can be Runnable.\r\n    /// <" + "/summary>\r\n    public interface IFreezableStep\r\n    {\r\n        /// <" + "summary>\r\n        /// Try to freeze this step.\r\n        /// <" + "/summary>\r\n        Result<" + "IStep> TryFreeze(StepContext stepContext);\r\n\r\n        /// <" + "summary>\r\n        /// Gets the variables which may be set by this step and their types.\r\n        /// <" + "/summary>\r\n        Result<" + "IReadOnlyCollection<" + "(VariableName VariableName, ITypeReference type)>> TryGetVariablesSet { get; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The human-readable name of this step.\r\n        /// <" + "/summary>\r\n        string StepName { get; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The output type of this step. Will be unit if the step does not have an output.\r\n        /// <" + "/summary>\r\n        Result<" + "ITypeReference> TryGetOutputTypeReference();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IRunError.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// An error thrown by a running step.\r\n    /// <" + "/summary>\r\n    public interface IRunError : IRunErrorBase\r\n    {\r\n        /// <" + "summary>\r\n        /// Error Message Text.\r\n        /// <" + "/summary>\r\n        public string Message { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The name of the step that threw this error.\r\n        /// <" + "/summary>\r\n        public string StepName { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The error that caused this error.\r\n        /// <" + "/summary>\r\n        public RunError? InnerError { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The error code.\r\n        /// <" + "/summary>\r\n        public ErrorCode ErrorCode { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IRunErrorBase.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// The base of run errors.\r\n    /// <" + "/summary>\r\n    public interface IRunErrorBase\r\n    {\r\n        /// <" + "summary>\r\n        /// The error as a string.\r\n        /// <" + "/summary>\r\n        string AsString { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IRunErrors.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// One or more errors thrown by a running step.\r\n    /// <" + "/summary>\r\n    public interface IRunErrors : IRunErrorBase\r\n    {\r\n        /// <" + "summary>\r\n        /// The errors.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "IRunError> AllErrors { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IStep.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step that can be run.\r\n    /// <" + "/summary>\r\n    public interface IStep\r\n    {\r\n        /// <" + "summary>\r\n        /// The name of this step.\r\n        /// <" + "/summary>\r\n        string Name { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Convert this Step into a FreezableStep.\r\n        /// <" + "/summary>\r\n        IFreezableStep Unfreeze();\r\n\r\n        /// <" + "summary>\r\n        /// Run this step and return the result untyped.\r\n        /// <" + "/summary>\r\n        Result<" + "T, IRunErrors> Run<" + "T>(StateMonad stateMonad);\r\n\r\n        /// <" + "summary>\r\n        /// Verify that this step can be run with the current settings.\r\n        /// <" + "/summary>\r\n        public Result<" + "Unit, IRunErrors> Verify(ISettings settings);\r\n\r\n        /// <" + "summary>\r\n        /// Configuration for this step.\r\n        /// <" + "/summary>\r\n        Configuration? Configuration { get; set; }\r\n\r\n        /// <" + "summary>\r\n        /// Step combiners that could be used for this step.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "IStepCombiner> StepCombiners { get; }\r\n\r\n    }\r\n\r\n    /// <" + "summary>\r\n    /// A step that can be run.\r\n    /// <" + "/summary>\r\n    public interface IStep<" + "T> : IStep\r\n    {\r\n        /// <" + "summary>\r\n        /// Run this step and return the result.\r\n        /// <" + "/summary>\r\n        Result<" + "T, IRunErrors> Run(StateMonad stateMonad); //TODO async\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IStepCombiner.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// An object which can combine a step with the next step in the sequence.\r\n    /// <" + "/summary>\r\n    public interface IStepCombiner\r\n    {\r\n        /// <" + "summary>\r\n        /// Tries to combine this step with the next step in the sequence.\r\n        /// <" + "/summary>\r\n        public Result<" + "IStep<" + "Unit>> TryCombine(IStep<" + "Unit> p1, IStep<" + "Unit> p2);\r\n\r\n    }\r\n}\r\n",
      "mutants": []
    },
    "Core\\Internal\\IStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A factory for creating steps.\r\n    /// <" + "/summary>\r\n    public interface IStepFactory\r\n    {\r\n        /// <" + "summary>\r\n        /// Unique name for this type of step.\r\n        /// <" + "/summary>\r\n        public string TypeName { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The type of the step to create.\r\n        /// <" + "/summary>\r\n        public Type StepType { get; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Builds the name for a particular instance of a step.\r\n        /// <" + "/summary>\r\n        IStepNameBuilder StepNameBuilder { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Tries to get a reference to the output type of this step.\r\n        /// <" + "/summary>\r\n        Result<" + "ITypeReference> TryGetOutputTypeReference(FreezableStepData freezableStepData);\r\n\r\n        /// <" + "summary>\r\n        /// If this variable is being set. Get the type reference it is being set to.\r\n        /// <" + "/summary>\r\n        Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData) =>\r\n            Maybe<" + "ITypeReference>.None;\r\n\r\n        /// <" + "summary>\r\n        /// Serializer to use for yaml serialization.\r\n        /// <" + "/summary>\r\n        IStepSerializer Serializer { get; }\r\n\r\n        /// <" + "summary>\r\n        /// An object which can combine a step with the next step in the sequence.\r\n        /// <" + "/summary>\r\n        Maybe<" + "IStepCombiner> StepCombiner { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Special requirements for this step.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "Requirement> Requirements { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Try to create the instance of this type and set all arguments.\r\n        /// <" + "/summary>\r\n        Result<" + "IStep> TryFreeze(StepContext stepContext, FreezableStepData freezableStepData,\r\n            Configuration? configuration);\r\n\r\n        /// <" + "summary>\r\n        /// Human readable explanation of the output type.\r\n        /// <" + "/summary>\r\n        string OutputTypeExplanation { get; }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IStepNameBuilder.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Builds step names.\r\n    /// <" + "/summary>\r\n    public interface IStepNameBuilder\r\n    {\r\n        /// <" + "summary>\r\n        /// Gets the name of the step from the step arguments\r\n        /// <" + "/summary>\r\n        string GetFromArguments(FreezableStepData freezableStepData);\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\IStreamReader.cs": {
      "language": "cs",
      "source": "using System.Threading.Tasks;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Anything that implements ReadLineAsync\r\n    /// <" + "/summary>\r\n    internal interface IStreamReader<" + "T> where T : struct\r\n    {\r\n        /// <" + "summary>\r\n        /// Reads a line of characters asynchronously and returns the data as a string and the source.\r\n        /// <" + "/summary>\r\n        /// <" + "returns><" + "/returns>\r\n        Task<" + "T?> ReadLineAsync();\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\ITypeReference.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Either a type itself, or the name of a variable with the same type.\r\n    /// <" + "/summary>\r\n    public interface ITypeReference\r\n    {\r\n        /// <" + "summary>\r\n        /// Gets the variable type references.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "VariableTypeReference> VariableTypeReferences { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Gets the actual type references.\r\n        /// <" + "/summary>\r\n        IEnumerable<" + "ActualTypeReference> ActualTypeReferences { get; }\r\n\r\n        IEnumerable<" + "ITypeReference> TypeArgumentReferences { get; }\r\n\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\MemberType.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// The type of a step member.\r\n    /// <" + "/summary>\r\n    public enum MemberType\r\n    {\r\n        /// <" + "summary>\r\n        /// This is not a member - some error has occured.\r\n        /// <" + "/summary>\r\n        NotAMember,\r\n        /// <" + "summary>\r\n        /// The name of a variable\r\n        /// <" + "/summary>\r\n        VariableName,\r\n        /// <" + "summary>\r\n        /// A step\r\n        /// <" + "/summary>\r\n        Step,\r\n        /// <" + "summary>\r\n        /// A list of steps\r\n        /// <" + "/summary>\r\n        StepList\r\n\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\MultipleTypeReference.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A type that is the same a multiple different references.\r\n    /// <" + "/summary>\r\n    public sealed class MultipleTypeReference : ITypeReference, IEquatable<" + "ITypeReference>\r\n    {\r\n        /// <" + "summary>\r\n        /// Tries to create a new MultipleTypeReference.\r\n        /// <" + "/summary>\r\n        public static Result<" + "ITypeReference> TryCreate(IEnumerable<" + "ITypeReference> references, string parentStep)\r\n        {\r\n            var set = references.ToImmutableHashSet();\r\n\r\n            switch (set.Count)\r\n            {\r\n                case 0:\r\n                    return new ActualTypeReference(typeof(object)); //TODO type reference any???\r\n                    //return Result.Failure<" + "ITypeReference>($\"Could not infer type for {parentStep} as it has no children.\");\r\n                case 1:\r\n                    return Result.Success(set.Single());\r\n                default:\r\n                {\r\n                    if (set.OfType<" + "ActualTypeReference>().Count() > 1)\r\n                        return Result.Failure<" + "ITypeReference>(\r\n                            $\"Could not infer type for {parentStep} as it's children have different types ({string.Join(\", \", set.OfType<" + "ActualTypeReference>().Select(x=>x.Type.Name))}).\");\r\n                    return new MultipleTypeReference(set);\r\n                }\r\n            }\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Creates a new MultipleTypeReference.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"allReferences\"><" + "/param>\r\n        private MultipleTypeReference(ImmutableHashSet<" + "ITypeReference> allReferences)\r\n        {\r\n            AllReferences = allReferences.ToImmutableHashSet();\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The type references.\r\n        /// <" + "/summary>\r\n        public ImmutableHashSet<" + "ITypeReference> AllReferences { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(ITypeReference? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n\r\n            return other switch\r\n            {\r\n                ActualTypeReference actualType => AllReferences.Count == 1 && AllReferences.Contains(actualType),\r\n                MultipleTypeReference multipleTypeReference => AllReferences.SetEquals(multipleTypeReference\r\n                    .AllReferences),\r\n                VariableTypeReference variableTypeReference => AllReferences.Count == 1 && AllReferences.Contains(variableTypeReference),\r\n                GenericTypeReference genericTypeReference => AllReferences.Count == 1 && AllReferences.Contains(genericTypeReference),\r\n                _ => throw new ArgumentOutOfRangeException(nameof(other))\r\n            };\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is ITypeReference other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => AllReferences.FirstOrDefault().GetHashCode();\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "VariableTypeReference> VariableTypeReferences => AllReferences.SelectMany(x=>x.VariableTypeReferences);\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "ActualTypeReference> ActualTypeReferences => AllReferences.SelectMany(x=>x.ActualTypeReferences);\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "ITypeReference> TypeArgumentReferences => ImmutableList<" + "ITypeReference>.Empty;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "545",
          "mutatorName": "Linq method mutation (Single() to SingleOrDefault())",
          "replacement": "set.SingleOrDefault()",
          "location": {
            "start": {
              "line": 27,
              "column": 43
            },
            "end": {
              "line": 27,
              "column": 55
            }
          },
          "status": "Survived"
        },
        {
          "id": "546",
          "mutatorName": "Equality mutation",
          "replacement": "set.OfType<" + "ActualTypeReference>().Count() <" + " 1",
          "location": {
            "start": {
              "line": 30,
              "column": 25
            },
            "end": {
              "line": 30,
              "column": 70
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "547",
          "mutatorName": "Equality mutation",
          "replacement": "set.OfType<" + "ActualTypeReference>().Count() >= 1",
          "location": {
            "start": {
              "line": 30,
              "column": 25
            },
            "end": {
              "line": 30,
              "column": 70
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "548",
          "mutatorName": "Negate expression",
          "replacement": "!(set.OfType<" + "ActualTypeReference>().Count() > 1)",
          "location": {
            "start": {
              "line": 30,
              "column": 25
            },
            "end": {
              "line": 30,
              "column": 70
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "549",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "set.OfType<" + "ActualTypeReference>().Sum() ",
          "location": {
            "start": {
              "line": 30,
              "column": 25
            },
            "end": {
              "line": 30,
              "column": 66
            }
          },
          "status": "CompileError"
        },
        {
          "id": "550",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 32,
              "column": 29
            },
            "end": {
              "line": 32,
              "column": 188
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "551",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 32,
              "column": 121
            },
            "end": {
              "line": 32,
              "column": 125
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "552",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 55,
              "column": 39
            },
            "end": {
              "line": 55,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "553",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 56,
              "column": 17
            },
            "end": {
              "line": 56,
              "column": 45
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "554",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 56,
              "column": 54
            },
            "end": {
              "line": 56,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "555",
          "mutatorName": "Logical mutation",
          "replacement": "AllReferences.Count == 1 || AllReferences.Contains(actualType)",
          "location": {
            "start": {
              "line": 60,
              "column": 51
            },
            "end": {
              "line": 60,
              "column": 113
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "556",
          "mutatorName": "Equality mutation",
          "replacement": "AllReferences.Count != 1 ",
          "location": {
            "start": {
              "line": 60,
              "column": 51
            },
            "end": {
              "line": 60,
              "column": 75
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "557",
          "mutatorName": "Logical mutation",
          "replacement": "AllReferences.Count == 1 || AllReferences.Contains(variableTypeReference)",
          "location": {
            "start": {
              "line": 63,
              "column": 64
            },
            "end": {
              "line": 63,
              "column": 137
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "558",
          "mutatorName": "Equality mutation",
          "replacement": "AllReferences.Count != 1 ",
          "location": {
            "start": {
              "line": 63,
              "column": 64
            },
            "end": {
              "line": 63,
              "column": 88
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "559",
          "mutatorName": "Logical mutation",
          "replacement": "AllReferences.Count == 1 || AllReferences.Contains(genericTypeReference)",
          "location": {
            "start": {
              "line": 64,
              "column": 62
            },
            "end": {
              "line": 64,
              "column": 134
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "560",
          "mutatorName": "Equality mutation",
          "replacement": "AllReferences.Count != 1 ",
          "location": {
            "start": {
              "line": 64,
              "column": 62
            },
            "end": {
              "line": 64,
              "column": 86
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "561",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is ITypeReference other && Equals(other)",
          "location": {
            "start": {
              "line": 70,
              "column": 53
            },
            "end": {
              "line": 70,
              "column": 127
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "562",
          "mutatorName": "Logical mutation",
          "replacement": "obj is ITypeReference other || Equals(other)",
          "location": {
            "start": {
              "line": 70,
              "column": 83
            },
            "end": {
              "line": 70,
              "column": 127
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "563",
          "mutatorName": "Linq method mutation (FirstOrDefault() to First())",
          "replacement": "AllReferences.First().GetHashCode()",
          "location": {
            "start": {
              "line": 73,
              "column": 46
            },
            "end": {
              "line": 73,
              "column": 90
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\MultistreamReader.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Reads lines from several StreamReaders in the order that they arrive\r\n    /// <" + "/summary>\r\n    internal class MultiStreamReader<" + "T> : IStreamReader<" + "T>\r\n    where T : struct\r\n    {\r\n        private readonly List<" + "(IStreamReader<" + "T> streamReader, Task<" + "T?>? task)> _streamReaderTaskPairs;\r\n\r\n        /// <" + "summary>\r\n        /// Create a new MultiStreamReader\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"streamReaders\"><" + "/param>\r\n        public MultiStreamReader(IEnumerable<" + "IStreamReader<" + "T>> streamReaders)\r\n        {\r\n            _streamReaderTaskPairs = streamReaders.Select(x => (x, null as Task<" + "T?>)).ToList();\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Read the next line from any of these stream readers. Returns null if all of them are finished\r\n        /// <" + "/summary>\r\n        /// <" + "returns><" + "/returns>\r\n        public async Task<" + "T?> ReadLineAsync()\r\n        {\r\n            var awaitingTasks = new List<" + "Task<" + "T?>>();\r\n\r\n            for (var i = 0; i <" + " _streamReaderTaskPairs.Count; i++) //go through all stream readers\r\n            {\r\n                var (streamReader, task1) = _streamReaderTaskPairs[i];\r\n                if (task1 == null)\r\n                {\r\n                    //this stream reader has no yet been asked for the next line\r\n                    var task = streamReader.ReadLineAsync();\r\n\r\n                    _streamReaderTaskPairs[i] = (streamReader, task);\r\n\r\n                    awaitingTasks.Add(task);\r\n                }\r\n                else\r\n                {\r\n                    //this stream reader has been asked for the next line during a previous call to this function\r\n                    awaitingTasks.Add(task1);\r\n                }\r\n            }\r\n\r\n            while (awaitingTasks.Any()) //loop until a string is returned that is not null\r\n            {\r\n                var firstCompletedTask = await Task.WhenAny(awaitingTasks);\r\n                var firstResult = firstCompletedTask.Result;\r\n\r\n\r\n                for (var i = 0; i <" + " _streamReaderTaskPairs.Count; i++)\r\n                {\r\n                    var (streamReader, task) = _streamReaderTaskPairs[i];\r\n                    if (task != firstCompletedTask) continue;\r\n                    if (firstResult == null) _streamReaderTaskPairs.RemoveAt(i); //stream is finished - remove it\r\n                    else _streamReaderTaskPairs[i] = (streamReader, null); //we've dealt with this task - remove it\r\n                    break;\r\n                }\r\n\r\n                if (firstResult != null) return firstResult; //return this result\r\n\r\n                awaitingTasks.Remove(firstCompletedTask); //remove this task\r\n            }\r\n\r\n            return null; //all readers are finished\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "564",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "i--",
          "location": {
            "start": {
              "line": 32,
              "column": 63
            },
            "end": {
              "line": 32,
              "column": 66
            }
          },
          "status": "Killed"
        },
        {
          "id": "565",
          "mutatorName": "Equality mutation",
          "replacement": "i > _streamReaderTaskPairs.Count",
          "location": {
            "start": {
              "line": 32,
              "column": 29
            },
            "end": {
              "line": 32,
              "column": 61
            }
          },
          "status": "Killed"
        },
        {
          "id": "566",
          "mutatorName": "Equality mutation",
          "replacement": "i <" + "= _streamReaderTaskPairs.Count",
          "location": {
            "start": {
              "line": 32,
              "column": 29
            },
            "end": {
              "line": 32,
              "column": 61
            }
          },
          "status": "Killed"
        },
        {
          "id": "567",
          "mutatorName": "Equality mutation",
          "replacement": "task1 != null",
          "location": {
            "start": {
              "line": 5,
              "column": 21
            },
            "end": {
              "line": 5,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "568",
          "mutatorName": "Negate expression",
          "replacement": "!(task1 == null)",
          "location": {
            "start": {
              "line": 5,
              "column": 21
            },
            "end": {
              "line": 5,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "569",
          "mutatorName": "Negate expression",
          "replacement": "!(awaitingTasks.Any())",
          "location": {
            "start": {
              "line": 51,
              "column": 20
            },
            "end": {
              "line": 51,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "570",
          "mutatorName": "PostIncrementExpression to PostDecrementExpression mutation",
          "replacement": "i--",
          "location": {
            "start": {
              "line": 57,
              "column": 67
            },
            "end": {
              "line": 57,
              "column": 70
            }
          },
          "status": "Survived"
        },
        {
          "id": "571",
          "mutatorName": "Equality mutation",
          "replacement": "i > _streamReaderTaskPairs.Count",
          "location": {
            "start": {
              "line": 57,
              "column": 33
            },
            "end": {
              "line": 57,
              "column": 65
            }
          },
          "status": "Killed"
        },
        {
          "id": "572",
          "mutatorName": "Equality mutation",
          "replacement": "i <" + "= _streamReaderTaskPairs.Count",
          "location": {
            "start": {
              "line": 57,
              "column": 33
            },
            "end": {
              "line": 57,
              "column": 65
            }
          },
          "status": "Survived"
        },
        {
          "id": "573",
          "mutatorName": "Equality mutation",
          "replacement": "task == firstCompletedTask",
          "location": {
            "start": {
              "line": 6,
              "column": 25
            },
            "end": {
              "line": 6,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "574",
          "mutatorName": "Negate expression",
          "replacement": "!(task != firstCompletedTask)",
          "location": {
            "start": {
              "line": 6,
              "column": 25
            },
            "end": {
              "line": 6,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "575",
          "mutatorName": "Equality mutation",
          "replacement": "firstResult != null",
          "location": {
            "start": {
              "line": 7,
              "column": 25
            },
            "end": {
              "line": 7,
              "column": 44
            }
          },
          "status": "Timeout"
        },
        {
          "id": "576",
          "mutatorName": "Negate expression",
          "replacement": "!(firstResult == null)",
          "location": {
            "start": {
              "line": 7,
              "column": 25
            },
            "end": {
              "line": 7,
              "column": 44
            }
          },
          "status": "Timeout"
        },
        {
          "id": "577",
          "mutatorName": "Equality mutation",
          "replacement": "firstResult == null",
          "location": {
            "start": {
              "line": 66,
              "column": 21
            },
            "end": {
              "line": 66,
              "column": 40
            }
          },
          "status": "Timeout"
        },
        {
          "id": "578",
          "mutatorName": "Negate expression",
          "replacement": "!(firstResult != null)",
          "location": {
            "start": {
              "line": 66,
              "column": 21
            },
            "end": {
              "line": 66,
              "column": 40
            }
          },
          "status": "Timeout"
        }
      ]
    },
    "Core\\Internal\\RunError.cs": {
      "language": "cs",
      "source": "\r\nusing System.Collections.Generic;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// An error thrown by a running step.\r\n    /// <" + "/summary>\r\n    public class RunError : IRunErrors, IRunError\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new RunError.\r\n        /// <" + "/summary>\r\n        public RunError(string message, string stepName, RunError? innerError, ErrorCode errorCode)\r\n        {\r\n            Message = message;\r\n            StepName = stepName;\r\n            InnerError = innerError;\r\n            ErrorCode = errorCode;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Error Message Text.\r\n        /// <" + "/summary>\r\n        public string Message { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The name of the step that threw this error.\r\n        /// <" + "/summary>\r\n        public string StepName { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The error that caused this error.\r\n        /// <" + "/summary>\r\n        public RunError? InnerError { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The error code.\r\n        /// <" + "/summary>\r\n        public ErrorCode ErrorCode { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "IRunError> AllErrors => new[] {this};\r\n\r\n        /// <" + "inheritdoc />\r\n        public string AsString => Message;\r\n    }\r\n}\r\n",
      "mutants": []
    },
    "Core\\Internal\\RunErrorList.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A list of errors thrown by a running step.\r\n    /// <" + "/summary>\r\n    public class RunErrorList : IRunErrors\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new RunErrorList\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"allErrors\"><" + "/param>\r\n        public RunErrorList(IReadOnlyCollection<" + "IRunError> allErrors) => AllErrors = allErrors;\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "IRunError> AllErrors { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public string AsString =>\r\n            string.Join(\"; \", AllErrors.Select(x => x.AsString));\r\n\r\n        /// <" + "summary>\r\n        /// Combine multiple run errors.\r\n        /// <" + "/summary>\r\n        public static RunErrorList Combine(IEnumerable<" + "IRunErrors> source) => new RunErrorList(source.SelectMany(x=>x.AllErrors).ToList());\r\n    }\r\n}",
      "mutants": [
        {
          "id": "579",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 22,
              "column": 25
            },
            "end": {
              "line": 22,
              "column": 29
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\SimpleStepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A step factory that uses default values for most properties.\r\n    /// <" + "/summary>\r\n    public abstract class SimpleStepFactory<" + "TStep, TOutput> : StepFactory where TStep : ICompoundStep, new ()\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "ITypeReference> TryGetOutputTypeReference(FreezableStepData freezableStepData) => Result.Success(ActualTypeReference.Create(typeof(TOutput)));\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IStepNameBuilder StepNameBuilder => new DefaultStepNameBuilder(TypeName);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Type StepType => typeof(TStep);\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override IEnumerable<" + "Type> EnumTypes => ImmutableArray<" + "Type>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        protected override Result<" + "ICompoundStep> TryCreateInstance(StepContext stepContext, FreezableStepData freezableStepData) => new TStep();\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string OutputTypeExplanation => typeof(TOutput).Name;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Internal\\StepContext.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Keeps track of all variables in a Freezable context.\r\n    /// <" + "/summary>\r\n    public sealed class StepContext\r\n    {\r\n        /// <" + "summary>\r\n        /// Dictionary mapping variable names to types.\r\n        /// <" + "/summary>\r\n        public IReadOnlyDictionary<" + "VariableName, Type> VariableTypesDictionary;\r\n\r\n        private StepContext(IReadOnlyDictionary<" + "VariableName, Type> variableTypesDictionary) => VariableTypesDictionary = variableTypesDictionary;\r\n\r\n        /// <" + "summary>\r\n        /// Gets the type referred to by a reference.\r\n        /// <" + "/summary>\r\n        public Result<" + "Type> TryGetTypeFromReference(ITypeReference typeReference)\r\n        {\r\n            switch (typeReference)\r\n            {\r\n                case ActualTypeReference actualType: return actualType.Type;\r\n                case GenericTypeReference genericTypeReference:\r\n                {\r\n                    var result =\r\n                        genericTypeReference.TypeArgumentReferences.Select(TryGetTypeFromReference).Combine()\r\n                            .Map(x=>x.ToArray())\r\n                            .OnSuccessTry(x=>genericTypeReference.GenericType.MakeGenericType(x));\r\n\r\n                    return result;\r\n                }\r\n                case MultipleTypeReference multipleTypeReference:\r\n                {\r\n                    var result = multipleTypeReference.AllReferences\r\n                        .Select(TryGetTypeFromReference)\r\n                        .Combine()\r\n                        .Map(x => x.Distinct())\r\n                        .Ensure(x => x.Count() == 1, $\"Type has multiple actual types.\")\r\n                        .Map(x => x.Single());\r\n\r\n                    return result;\r\n                }\r\n                case VariableTypeReference typeReference1:\r\n                {\r\n                    return VariableTypesDictionary.TryFindOrFail(typeReference1.VariableName,\r\n                        $\"Variable '{typeReference1.VariableName}' is never set.\");\r\n                }\r\n                default:\r\n                    throw new ArgumentOutOfRangeException(nameof(typeReference));\r\n            }\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Tries to create a new StepContext.\r\n        /// <" + "/summary>\r\n        public static Result<" + "StepContext> TryCreate(params IFreezableStep[] freezableSteps)\r\n        {\r\n            var result = freezableSteps\r\n                .Select(x => x.TryGetVariablesSet)\r\n                .Combine()\r\n                .Map(l=>l.SelectMany(y=>y))\r\n                .Bind(ResolveTypes)\r\n                .Map(dictionary=> new StepContext(dictionary));\r\n\r\n            return result;\r\n\r\n            static Result<" + "IReadOnlyDictionary<" + "VariableName, Type>> ResolveTypes(IEnumerable<" + "(VariableName variableName, ITypeReference typeReference)> references)\r\n            {\r\n                var genericReferences = references.Where(x => x.typeReference is GenericTypeReference)\r\n                    .SelectMany(x =>\r\n                        ((GenericTypeReference) x.typeReference).ChildTypes.Select((t, i) =>\r\n                            (variableName: x.variableName.CreateChild(i), typeReference: t)));\r\n\r\n\r\n                var groups = references\r\n                    .Concat(genericReferences)\r\n                    .GroupBy(x => x.variableName).ToList();\r\n                var groupingDictionary = new Dictionary<" + "VariableName, ImmutableHashSet<" + "ActualTypeReference>>();\r\n\r\n\r\n                foreach (var remainingGroup in groups)\r\n                {\r\n                    var keys = remainingGroup.SelectMany(x=>x.typeReference.VariableTypeReferences).Select(x=>x.VariableName).Prepend(remainingGroup.Key).ToList();\r\n\r\n                    var newSet = keys.Select(x =>\r\n                            groupingDictionary.TryGetValue(x, out var hs) ? hs : Enumerable.Empty<" + "ActualTypeReference>())\r\n                        .Distinct()\r\n                        .SelectMany(x => x)\r\n                        .Concat(remainingGroup.SelectMany(x=>x.typeReference.ActualTypeReferences))\r\n                        .ToImmutableHashSet(); //This is not super efficient, but who cares\r\n\r\n                    //This set may have no elements - this is not a problem\r\n\r\n                    foreach (var key in keys)\r\n                        groupingDictionary[key] = newSet;\r\n                }\r\n\r\n                var r = groupingDictionary.Select(TryExtractType).Combine().Map(x => new Dictionary<" + "VariableName, Type>(x) as IReadOnlyDictionary<" + "VariableName, Type>);\r\n\r\n                return r;\r\n\r\n                static Result<" + "KeyValuePair<" + "VariableName, Type>> TryExtractType(KeyValuePair<" + "VariableName, ImmutableHashSet<" + "ActualTypeReference>> kvp)\r\n                {\r\n                    var (key, actualTypes) = kvp;\r\n                    return actualTypes.Count switch\r\n                    {\r\n                        0 => Result.Failure<" + "KeyValuePair<" + "VariableName, Type>>($\"The type '{key}' is never set.\"),\r\n                        1 => new KeyValuePair<" + "VariableName, Type>(key, actualTypes.Single().Type),\r\n                        _ => Result.Failure<" + "KeyValuePair<" + "VariableName, Type>>(\r\n                            $\"The type '{key}' is set to more than one type - ({string.Join(\", \", actualTypes.Select(x => x.Type.Name))})\")\r\n                    };\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "580",
          "mutatorName": "Equality mutation",
          "replacement": "x.Count() != 1",
          "location": {
            "start": {
              "line": 45,
              "column": 38
            },
            "end": {
              "line": 45,
              "column": 52
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "581",
          "mutatorName": "Linq method mutation (Count() to Sum())",
          "replacement": "x.Sum() ",
          "location": {
            "start": {
              "line": 45,
              "column": 38
            },
            "end": {
              "line": 45,
              "column": 47
            }
          },
          "status": "CompileError"
        },
        {
          "id": "582",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 45,
              "column": 54
            },
            "end": {
              "line": 45,
              "column": 88
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "583",
          "mutatorName": "Linq method mutation (Single() to SingleOrDefault())",
          "replacement": "x.SingleOrDefault()",
          "location": {
            "start": {
              "line": 46,
              "column": 35
            },
            "end": {
              "line": 46,
              "column": 45
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "584",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 53,
              "column": 25
            },
            "end": {
              "line": 53,
              "column": 82
            }
          },
          "status": "Survived"
        },
        {
          "id": "585",
          "mutatorName": "Negate expression",
          "replacement": "!(                            groupingDictionary.TryGetValue(x, out var hs) )",
          "location": {
            "start": {
              "line": 93,
              "column": 29
            },
            "end": {
              "line": 93,
              "column": 74
            }
          },
          "status": "Killed"
        },
        {
          "id": "586",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 114,
              "column": 79
            },
            "end": {
              "line": 114,
              "column": 112
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "587",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 117,
              "column": 29
            },
            "end": {
              "line": 117,
              "column": 139
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "588",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 117,
              "column": 93
            },
            "end": {
              "line": 117,
              "column": 97
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\StepFactory.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Attributes;\r\nusing Reductech.EDR.Core.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// A factory for creating steps.\r\n    /// <" + "/summary>\r\n    public abstract class StepFactory : IStepFactory\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public abstract Result<" + "ITypeReference> TryGetOutputTypeReference(FreezableStepData freezableStepData);\r\n\r\n        /// <" + "inheritdoc />\r\n        public string TypeName => FormatTypeName(StepType);\r\n\r\n        /// <" + "summary>\r\n        /// The type of this step.\r\n        /// <" + "/summary>\r\n        public abstract Type StepType { get; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString() => TypeName;\r\n\r\n        /// <" + "inheritdoc />\r\n        public abstract IStepNameBuilder StepNameBuilder { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Gets all enum types used by this step.\r\n        /// <" + "/summary>\r\n        public abstract IEnumerable<" + "Type> EnumTypes { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public abstract string OutputTypeExplanation { get; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public virtual Result<" + "Maybe<" + "ITypeReference>> GetTypeReferencesSet(VariableName variableName, FreezableStepData freezableStepData) =>\r\n            Maybe<" + "ITypeReference>.None;\r\n\r\n        /// <" + "inheritdoc />\r\n        public virtual IStepSerializer Serializer => new FunctionSerializer(TypeName);\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public virtual Maybe<" + "IStepCombiner> StepCombiner => Maybe<" + "IStepCombiner>.None;\r\n\r\n        /// <" + "inheritdoc />\r\n        public virtual IEnumerable<" + "Requirement> Requirements => ImmutableArray<" + "Requirement>.Empty;\r\n\r\n        /// <" + "summary>\r\n        /// Creates an instance of this type.\r\n        /// <" + "/summary>\r\n        protected abstract Result<" + "ICompoundStep> TryCreateInstance(StepContext stepContext, FreezableStepData freezableStepData);\r\n\r\n        /// <" + "summary>\r\n        /// Gets the type of this member.\r\n        /// <" + "/summary>\r\n        public MemberType GetExpectedMemberType(string name)\r\n        {\r\n            var propertyInfo = StepType.GetProperty(name, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance);\r\n\r\n            if (propertyInfo == null) return MemberType.NotAMember;\r\n\r\n            if (propertyInfo.GetCustomAttribute<" + "VariableNameAttribute>() != null) return MemberType.VariableName;\r\n            if (propertyInfo.GetCustomAttribute<" + "StepPropertyAttribute>() != null) return MemberType.Step;\r\n            if (propertyInfo.GetCustomAttribute<" + "StepListPropertyAttribute>() != null) return MemberType.StepList;\r\n\r\n            return MemberType.NotAMember;\r\n\r\n        }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "IStep> TryFreeze(StepContext stepContext, FreezableStepData freezableStepData, Configuration? configuration)\r\n        {\r\n            var instanceResult = TryCreateInstance(stepContext, freezableStepData);\r\n\r\n            if (instanceResult.IsFailure)\r\n                return instanceResult.ConvertFailure<" + "IStep>();\r\n\r\n            var step = instanceResult.Value;\r\n            step.Configuration = configuration;\r\n\r\n            var errors = new List<" + "string>();\r\n\r\n            var instanceType = step.GetType();\r\n\r\n            var variableNameProperties1 = instanceType\r\n                .GetProperties()\r\n                .Where(x => x.PropertyType == typeof(VariableName))\r\n                .Where(x => x.GetCustomAttribute<" + "VariableNameAttribute>() != null);\r\n\r\n\r\n            var simpleProperties1 = instanceType.GetProperties()\r\n                .Where(x => x.GetCustomAttribute<" + "StepPropertyAttribute>() != null);\r\n\r\n            var listProperties1 = instanceType.GetProperties()\r\n                .Where(x => x.GetCustomAttribute<" + "StepListPropertyAttribute>() != null);\r\n\r\n            var remainingProperties =\r\n                variableNameProperties1.Select(propertyInfo => (propertyInfo,memberType: MemberType.VariableName))\r\n                    .Concat(simpleProperties1.Select(propertyInfo => (propertyInfo,memberType: MemberType.Step)))\r\n                    .Concat(listProperties1.Select(propertyInfo => (propertyInfo,memberType: MemberType.StepList)))\r\n                    .ToDictionary(x=>x.propertyInfo.Name, StringComparer.OrdinalIgnoreCase);\r\n\r\n\r\n            foreach (var (propertyName, stepMember) in freezableStepData.Dictionary)\r\n            {\r\n#pragma warning disable 8714\r\n                if (remainingProperties.Remove(propertyName, out var pair))\r\n#pragma warning restore 8714\r\n                {\r\n                    var convertResult = stepMember.TryConvert(pair.memberType);\r\n                    if(convertResult.IsFailure)\r\n                        errors.Add(convertResult.Error);\r\n                    else\r\n                    {\r\n                        var result = pair.memberType switch\r\n                        {\r\n                            MemberType.VariableName => TrySetVariableName(pair.propertyInfo, step,\r\n                                convertResult.Value),\r\n                            MemberType.Step => TrySetStep(pair.propertyInfo, step, convertResult.Value,\r\n                                stepContext),\r\n                            MemberType.StepList => TrySetStepList(pair.propertyInfo, step,\r\n                                convertResult.Value, stepContext),\r\n                            _ => throw new ArgumentOutOfRangeException()\r\n                        };\r\n\r\n                        if(result.IsFailure)\r\n                            errors.Add(result.Error);\r\n                    }\r\n                }\r\n                else\r\n                    errors.Add($\"The property '{propertyName}' does not exist on type '{TypeName}'.\");\r\n\r\n\r\n\r\n                static Result TrySetVariableName(PropertyInfo propertyInfo, IStep parentStep, StepMember member)\r\n                {\r\n                    var r1 = member.AsVariableName(propertyInfo.Name);\r\n                    if (r1.IsFailure) return r1;\r\n\r\n                    propertyInfo.SetValue(parentStep, r1.Value);\r\n                    return Result.Success();\r\n                }\r\n\r\n                static Result TrySetStep(PropertyInfo propertyInfo, IStep parentStep, StepMember member, StepContext context)\r\n                {\r\n                    var argumentFreezeResult = member.AsArgument(propertyInfo.Name).Bind(x=>x.TryFreeze(context));\r\n                    if (argumentFreezeResult.IsFailure)\r\n                        return argumentFreezeResult;\r\n                    if (!propertyInfo.PropertyType.IsInstanceOfType(argumentFreezeResult.Value))\r\n                        return Result.Failure($\"'{propertyInfo.Name}' cannot take the value '{argumentFreezeResult.Value}'\");\r\n\r\n                    propertyInfo.SetValue(parentStep, argumentFreezeResult.Value); //This could throw an exception but we don't expect it.\r\n                    return Result.Success();\r\n                }\r\n\r\n                static Result TrySetStepList(PropertyInfo propertyInfo, IStep parentStep, StepMember member, StepContext context)\r\n                {\r\n                    var freezeResult =\r\n                        member\r\n                            .AsListArgument(propertyInfo.Name)\r\n                            .Bind(l => l.Select(x => x.TryFreeze(context)).Combine()\r\n                                .Map(x => x.ToImmutableArray()));\r\n                    if (freezeResult.IsFailure)\r\n                        return freezeResult;\r\n\r\n                    var genericType = propertyInfo.PropertyType.GenericTypeArguments.Single();\r\n                    var listType = typeof(List<" + ">).MakeGenericType(genericType);\r\n\r\n                    var list = Activator.CreateInstance(listType);\r\n\r\n                    foreach (var step1 in freezeResult.Value)\r\n                        if (genericType.IsInstanceOfType(step1))\r\n                        {\r\n                            var addMethod = listType.GetMethod(nameof(List<" + "object>.Add))!;\r\n                            addMethod.Invoke(list, new object?[] { step1 });\r\n                        }\r\n                        else\r\n                            return Result.Failure($\"'{step1.Name}' does not have the type '{genericType.Name}'\");\r\n\r\n\r\n                    propertyInfo.SetValue(parentStep, list);\r\n\r\n                    return Result.Success();\r\n                }\r\n            }\r\n\r\n            errors.AddRange(remainingProperties.Values\r\n                .Where(property => property.propertyInfo.GetCustomAttribute<" + "RequiredAttribute>() != null)\r\n                .Select(property => $\"The property '{property.propertyInfo.Name}' was not set on type '{GetType().Name}'.\")\r\n            );\r\n\r\n\r\n            if (errors.Any())\r\n                return Result.Failure<" + "IStep>(string.Join(\"\\r\\n\", errors));\r\n\r\n            return Result.Success<" + "IStep>(step);\r\n\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Creates a typed generic step with one type argument.\r\n        /// <" + "/summary>\r\n        protected static Result<" + "ICompoundStep> TryCreateGeneric(Type openGenericType, Type parameterType)\r\n        {\r\n            var genericType = openGenericType.MakeGenericType(parameterType);\r\n\r\n            var r = Activator.CreateInstance(genericType);\r\n\r\n            if (r is ICompoundStep rp)\r\n                return Result.Success(rp);\r\n\r\n            return Result.Failure<" + "ICompoundStep>($\"Could not create an instance of {openGenericType.Name}<" + "{parameterType.Name}>\");\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Gets the name of the type, removing the backtick if it is a generic type.\r\n        /// <" + "/summary>\r\n        protected static string FormatTypeName(Type type)\r\n        {\r\n            string friendlyName = type.Name;\r\n            if (type.IsGenericType)\r\n            {\r\n                var iBacktick = friendlyName.IndexOf('`');\r\n                if (iBacktick > 0) friendlyName = friendlyName.Remove(iBacktick);\r\n            }\r\n\r\n            return friendlyName;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "589",
          "mutatorName": "Bitwise mutation",
          "replacement": "BindingFlags.IgnoreCase | BindingFlags.Public & BindingFlags.Instance",
          "location": {
            "start": {
              "line": 69,
              "column": 59
            },
            "end": {
              "line": 69,
              "column": 128
            }
          },
          "status": "Killed"
        },
        {
          "id": "590",
          "mutatorName": "Bitwise mutation",
          "replacement": "BindingFlags.IgnoreCase & BindingFlags.Public ",
          "location": {
            "start": {
              "line": 69,
              "column": 59
            },
            "end": {
              "line": 69,
              "column": 104
            }
          },
          "status": "Killed"
        },
        {
          "id": "591",
          "mutatorName": "Equality mutation",
          "replacement": "propertyInfo != null",
          "location": {
            "start": {
              "line": 71,
              "column": 17
            },
            "end": {
              "line": 71,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "592",
          "mutatorName": "Negate expression",
          "replacement": "!(propertyInfo == null)",
          "location": {
            "start": {
              "line": 71,
              "column": 17
            },
            "end": {
              "line": 71,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "593",
          "mutatorName": "Equality mutation",
          "replacement": "propertyInfo.GetCustomAttribute<" + "VariableNameAttribute>() == null",
          "location": {
            "start": {
              "line": 73,
              "column": 17
            },
            "end": {
              "line": 73,
              "column": 81
            }
          },
          "status": "Killed"
        },
        {
          "id": "594",
          "mutatorName": "Negate expression",
          "replacement": "!(propertyInfo.GetCustomAttribute<" + "VariableNameAttribute>() != null)",
          "location": {
            "start": {
              "line": 73,
              "column": 17
            },
            "end": {
              "line": 73,
              "column": 81
            }
          },
          "status": "Killed"
        },
        {
          "id": "595",
          "mutatorName": "Equality mutation",
          "replacement": "propertyInfo.GetCustomAttribute<" + "StepPropertyAttribute>() == null",
          "location": {
            "start": {
              "line": 74,
              "column": 17
            },
            "end": {
              "line": 74,
              "column": 81
            }
          },
          "status": "Killed"
        },
        {
          "id": "596",
          "mutatorName": "Negate expression",
          "replacement": "!(propertyInfo.GetCustomAttribute<" + "StepPropertyAttribute>() != null)",
          "location": {
            "start": {
              "line": 74,
              "column": 17
            },
            "end": {
              "line": 74,
              "column": 81
            }
          },
          "status": "Killed"
        },
        {
          "id": "597",
          "mutatorName": "Equality mutation",
          "replacement": "propertyInfo.GetCustomAttribute<" + "StepListPropertyAttribute>() == null",
          "location": {
            "start": {
              "line": 75,
              "column": 17
            },
            "end": {
              "line": 75,
              "column": 85
            }
          },
          "status": "Killed"
        },
        {
          "id": "598",
          "mutatorName": "Negate expression",
          "replacement": "!(propertyInfo.GetCustomAttribute<" + "StepListPropertyAttribute>() != null)",
          "location": {
            "start": {
              "line": 75,
              "column": 17
            },
            "end": {
              "line": 75,
              "column": 85
            }
          },
          "status": "Killed"
        },
        {
          "id": "599",
          "mutatorName": "Negate expression",
          "replacement": "!(instanceResult.IsFailure)",
          "location": {
            "start": {
              "line": 87,
              "column": 17
            },
            "end": {
              "line": 87,
              "column": 41
            }
          },
          "status": "Killed"
        },
        {
          "id": "600",
          "mutatorName": "Equality mutation",
          "replacement": "x.PropertyType != typeof(VariableName)",
          "location": {
            "start": {
              "line": 99,
              "column": 29
            },
            "end": {
              "line": 99,
              "column": 67
            }
          },
          "status": "Killed"
        },
        {
          "id": "601",
          "mutatorName": "Equality mutation",
          "replacement": "x.GetCustomAttribute<" + "VariableNameAttribute>() == null",
          "location": {
            "start": {
              "line": 100,
              "column": 29
            },
            "end": {
              "line": 100,
              "column": 82
            }
          },
          "status": "Killed"
        },
        {
          "id": "602",
          "mutatorName": "Equality mutation",
          "replacement": "x.GetCustomAttribute<" + "StepPropertyAttribute>() == null",
          "location": {
            "start": {
              "line": 104,
              "column": 29
            },
            "end": {
              "line": 104,
              "column": 82
            }
          },
          "status": "Killed"
        },
        {
          "id": "603",
          "mutatorName": "Equality mutation",
          "replacement": "x.GetCustomAttribute<" + "StepListPropertyAttribute>() == null",
          "location": {
            "start": {
              "line": 107,
              "column": 29
            },
            "end": {
              "line": 107,
              "column": 86
            }
          },
          "status": "Killed"
        },
        {
          "id": "604",
          "mutatorName": "Negate expression",
          "replacement": "!(remainingProperties.Remove(propertyName, out var pair))",
          "location": {
            "start": {
              "line": 119,
              "column": 21
            },
            "end": {
              "line": 119,
              "column": 75
            }
          },
          "status": "Killed"
        },
        {
          "id": "605",
          "mutatorName": "Negate expression",
          "replacement": "!(convertResult.IsFailure)",
          "location": {
            "start": {
              "line": 123,
              "column": 24
            },
            "end": {
              "line": 123,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "606",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsFailure)",
          "location": {
            "start": {
              "line": 138,
              "column": 28
            },
            "end": {
              "line": 138,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "607",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 143,
              "column": 32
            },
            "end": {
              "line": 143,
              "column": 101
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "608",
          "mutatorName": "Negate expression",
          "replacement": "!(r1.IsFailure)",
          "location": {
            "start": {
              "line": 150,
              "column": 25
            },
            "end": {
              "line": 150,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "609",
          "mutatorName": "Negate expression",
          "replacement": "!(argumentFreezeResult.IsFailure)",
          "location": {
            "start": {
              "line": 159,
              "column": 25
            },
            "end": {
              "line": 159,
              "column": 55
            }
          },
          "status": "Killed"
        },
        {
          "id": "610",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "propertyInfo.PropertyType.IsInstanceOfType(argumentFreezeResult.Value)",
          "location": {
            "start": {
              "line": 161,
              "column": 25
            },
            "end": {
              "line": 161,
              "column": 96
            }
          },
          "status": "Killed"
        },
        {
          "id": "611",
          "mutatorName": "Negate expression",
          "replacement": "!(!propertyInfo.PropertyType.IsInstanceOfType(argumentFreezeResult.Value))",
          "location": {
            "start": {
              "line": 161,
              "column": 25
            },
            "end": {
              "line": 161,
              "column": 96
            }
          },
          "status": "Killed"
        },
        {
          "id": "612",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 162,
              "column": 47
            },
            "end": {
              "line": 162,
              "column": 124
            }
          },
          "status": "Ignored"
        },
        {
          "id": "613",
          "mutatorName": "Negate expression",
          "replacement": "!(freezeResult.IsFailure)",
          "location": {
            "start": {
              "line": 175,
              "column": 25
            },
            "end": {
              "line": 175,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "614",
          "mutatorName": "Linq method mutation (Single() to SingleOrDefault())",
          "replacement": "propertyInfo.PropertyType.GenericTypeArguments.SingleOrDefault()",
          "location": {
            "start": {
              "line": 178,
              "column": 39
            },
            "end": {
              "line": 178,
              "column": 94
            }
          },
          "status": "Survived"
        },
        {
          "id": "615",
          "mutatorName": "Negate expression",
          "replacement": "!(genericType.IsInstanceOfType(step1))",
          "location": {
            "start": {
              "line": 184,
              "column": 29
            },
            "end": {
              "line": 184,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "616",
          "mutatorName": "Array initializer mutation",
          "replacement": "new object?[] {}",
          "location": {
            "start": {
              "line": 187,
              "column": 52
            },
            "end": {
              "line": 187,
              "column": 75
            }
          },
          "status": "Killed"
        },
        {
          "id": "617",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 190,
              "column": 51
            },
            "end": {
              "line": 190,
              "column": 112
            }
          },
          "status": "Ignored"
        },
        {
          "id": "618",
          "mutatorName": "Equality mutation",
          "replacement": "property.propertyInfo.GetCustomAttribute<" + "RequiredAttribute>() == null",
          "location": {
            "start": {
              "line": 200,
              "column": 36
            },
            "end": {
              "line": 200,
              "column": 105
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "619",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 201,
              "column": 37
            },
            "end": {
              "line": 201,
              "column": 123
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "620",
          "mutatorName": "Negate expression",
          "replacement": "!(errors.Any())",
          "location": {
            "start": {
              "line": 205,
              "column": 17
            },
            "end": {
              "line": 205,
              "column": 29
            }
          },
          "status": "Killed"
        },
        {
          "id": "621",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 206,
              "column": 58
            },
            "end": {
              "line": 206,
              "column": 64
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "622",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 225,
              "column": 50
            },
            "end": {
              "line": 225,
              "column": 129
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "623",
          "mutatorName": "Negate expression",
          "replacement": "!(type.IsGenericType)",
          "location": {
            "start": {
              "line": 234,
              "column": 17
            },
            "end": {
              "line": 234,
              "column": 35
            }
          },
          "status": "Killed"
        },
        {
          "id": "624",
          "mutatorName": "Equality mutation",
          "replacement": "iBacktick <" + " 0",
          "location": {
            "start": {
              "line": 237,
              "column": 21
            },
            "end": {
              "line": 237,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "625",
          "mutatorName": "Equality mutation",
          "replacement": "iBacktick >= 0",
          "location": {
            "start": {
              "line": 237,
              "column": 21
            },
            "end": {
              "line": 237,
              "column": 34
            }
          },
          "status": "Survived"
        },
        {
          "id": "626",
          "mutatorName": "Negate expression",
          "replacement": "!(iBacktick > 0)",
          "location": {
            "start": {
              "line": 237,
              "column": 21
            },
            "end": {
              "line": 237,
              "column": 34
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Internal\\StepFactoryStore.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Reflection;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Allows you to get a step factory from a step name.\r\n    /// <" + "/summary>\r\n    public class StepFactoryStore\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new StepFactoryStore.\r\n        /// <" + "/summary>\r\n        public StepFactoryStore(IReadOnlyDictionary<" + "string, StepFactory> dictionary, IReadOnlyDictionary<" + "string, Type> enumTypesDictionary)\r\n        {\r\n            Dictionary = dictionary.ToDictionary(x=>x.Key!, x=>x.Value!, StringComparer.OrdinalIgnoreCase)!;\r\n            EnumTypesDictionary = enumTypesDictionary.ToDictionary(x=>x.Key!, x=>x.Value!, StringComparer.OrdinalIgnoreCase)!;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Create a step factory store using all StepFactories in the assembly.\r\n        /// <" + "/summary>\r\n        /// <" + "returns><" + "/returns>\r\n        public static StepFactoryStore CreateUsingReflection(params Type[] assemblyMemberTypes)\r\n        {\r\n            var factories =\r\n                assemblyMemberTypes.Select(Assembly.GetAssembly)\r\n                        .Distinct()\r\n                        .SelectMany(a=>a!.GetTypes())\r\n                        .Distinct()\r\n                .Where(x => !x.IsAbstract)\r\n                .Where(x => typeof(StepFactory).IsAssignableFrom(x))\r\n                .Select(x => x.GetProperty(\"Instance\", BindingFlags.Public | BindingFlags.Static)!.GetValue(null))\r\n                .Cast<" + "StepFactory>().ToList();\r\n\r\n            var dictionary = factories.ToDictionary(x => x.TypeName);\r\n            var enumTypesDictionary = factories.SelectMany(x => x.EnumTypes).Distinct()\r\n                .ToDictionary(x => x.Name ?? \"\", StringComparer.OrdinalIgnoreCase);\r\n\r\n            return new StepFactoryStore(dictionary, enumTypesDictionary!);\r\n\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Types of enumerations that can be used by these steps.\r\n        /// <" + "/summary>\r\n        public IReadOnlyDictionary<" + "string, Type> EnumTypesDictionary { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Dictionary mapping step names to step factories.\r\n        /// <" + "/summary>\r\n        public IReadOnlyDictionary<" + "string, StepFactory> Dictionary { get; }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "627",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "x.IsAbstract",
          "location": {
            "start": {
              "line": 33,
              "column": 29
            },
            "end": {
              "line": 33,
              "column": 42
            }
          },
          "status": "Killed"
        },
        {
          "id": "628",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 35,
              "column": 44
            },
            "end": {
              "line": 35,
              "column": 54
            }
          },
          "status": "Killed"
        },
        {
          "id": "629",
          "mutatorName": "Bitwise mutation",
          "replacement": "BindingFlags.Public & BindingFlags.Static",
          "location": {
            "start": {
              "line": 35,
              "column": 56
            },
            "end": {
              "line": 35,
              "column": 97
            }
          },
          "status": "Killed"
        },
        {
          "id": "630",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 40,
              "column": 46
            },
            "end": {
              "line": 40,
              "column": 48
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\StepMember.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.General;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Any member of a step.\r\n    /// <" + "/summary>\r\n    public sealed class StepMember : IEquatable<" + "StepMember>\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new VariableName StepMember\r\n        /// <" + "/summary>\r\n        public StepMember(VariableName variableName) => Option = new Option<" + "VariableName, IFreezableStep, IReadOnlyList<" + "IFreezableStep>>(variableName);\r\n\r\n        /// <" + "summary>\r\n        /// Create a new IFreezableStep StepMember\r\n        /// <" + "/summary>\r\n        public StepMember(IFreezableStep argument) => Option = new Option<" + "VariableName, IFreezableStep, IReadOnlyList<" + "IFreezableStep>>(argument);\r\n\r\n        /// <" + "summary>\r\n        /// Create a new ListArgument StepMember\r\n        /// <" + "/summary>\r\n        public StepMember(IReadOnlyList<" + "IFreezableStep> listArgument) => Option = new Option<" + "VariableName, IFreezableStep, IReadOnlyList<" + "IFreezableStep>>(listArgument);\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The member type of this Step Member.\r\n        /// <" + "/summary>\r\n        public MemberType MemberType\r\n        {\r\n            get\r\n            {\r\n                if (Option.Choice1.HasValue) return MemberType.VariableName;\r\n                if (Option.Choice2.HasValue) return MemberType.Step;\r\n                if (Option.Choice3.HasValue) return MemberType.StepList;\r\n\r\n                return MemberType.NotAMember;\r\n            }\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The chosen option.\r\n        /// <" + "/summary>\r\n        public Option<" + "VariableName, IFreezableStep, IReadOnlyList<" + "IFreezableStep>> Option { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Use this StepMember.\r\n        /// <" + "/summary>\r\n        public T Join<" + "T>(Func<" + "VariableName, T> handleVariableName, Func<" + "IFreezableStep, T> handleArgument,\r\n            Func<" + "IReadOnlyList<" + "IFreezableStep>, T> handleListArgument) =>\r\n            Option.Join(handleVariableName, handleArgument, handleListArgument);\r\n\r\n        /// <" + "summary>\r\n        /// Gets the stepMember if it is a VariableName.\r\n        /// <" + "/summary>\r\n        public Result<" + "VariableName> AsVariableName(string propertyName) => Option.Choice1.ToResult($\"{propertyName} was a {MemberType}, not a VariableName\");\r\n\r\n        /// <" + "summary>\r\n        /// Gets the stepMember if it is an argument.\r\n        /// <" + "/summary>\r\n        public Result<" + "IFreezableStep> AsArgument(string propertyName) => Option.Choice2.ToResult($\"{propertyName} was a {MemberType}, not an argument\");\r\n\r\n        /// <" + "summary>\r\n        /// Gets the stepMember if it is a listArgument.\r\n        /// <" + "/summary>\r\n        public Result<" + "IReadOnlyList<" + "IFreezableStep>> AsListArgument(string propertyName) => Option.Choice3.ToResult($\"{propertyName} was a {MemberType}, not an list argument\");\r\n\r\n        /// <" + "summary>\r\n        /// Tries to convert this step member to a particular type.\r\n        /// <" + "/summary>\r\n        public Result<" + "StepMember> TryConvert(MemberType convertType)\r\n        {\r\n            if (MemberType == convertType) return this;\r\n\r\n            if (MemberType == MemberType.StepList && convertType == MemberType.Step)\r\n            {\r\n                var sequence = SequenceStepFactory.CreateFreezable(Option.Choice3.Value, null);\r\n                return new StepMember(sequence);\r\n            }\r\n\r\n            if (MemberType == MemberType.VariableName && convertType == MemberType.Step)\r\n            {\r\n                var getVariableStep = GetVariableStepFactory.CreateFreezable(Option.Choice1.Value);\r\n                return new StepMember(getVariableStep);\r\n            }\r\n\r\n            return Result.Failure<" + "StepMember>(\"Could not convert\");\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// A string representation of the member.\r\n        /// <" + "/summary>\r\n        public string MemberString\r\n        {\r\n            get\r\n            {\r\n                return Join(x =>\r\n                        x.ToString()!,\r\n                    x => x.ToString()!,\r\n                    x => x.ToString()!);\r\n\r\n            }\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString() => new {MemberType, Value=MemberString}.ToString()!;\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(StepMember? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n\r\n            return Option.Equals(other.Option,\r\n                (a, b) => a.Equals(b),\r\n                (a, b) => a.Equals(b),\r\n                ListsAreEqual);\r\n\r\n            static bool ListsAreEqual(IReadOnlyList<" + "IFreezableStep> a1, IReadOnlyList<" + "IFreezableStep> a2)\r\n            {\r\n                if (a1 is null)\r\n                    return a2 is null;\r\n\r\n                if (a2 is null)\r\n                    return false;\r\n\r\n                return a1.SequenceEqual(a2);\r\n            }\r\n        }\r\n\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is StepMember other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => HashCode.Combine(Option.Choice1, Option.Choice2, Option.Choice3.Select(x=>x.Count));\r\n\r\n        /// <" + "summary>\r\n        /// Equals operator\r\n        /// <" + "/summary>\r\n        public static bool operator ==(StepMember? left, StepMember? right) => Equals(left, right);\r\n\r\n        /// <" + "summary>\r\n        /// Not Equals operator\r\n        /// <" + "/summary>\r\n        public static bool operator !=(StepMember? left, StepMember? right) => !Equals(left, right);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "631",
          "mutatorName": "Negate expression",
          "replacement": "!(Option.Choice1.HasValue)",
          "location": {
            "start": {
              "line": 38,
              "column": 21
            },
            "end": {
              "line": 38,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "632",
          "mutatorName": "Negate expression",
          "replacement": "!(Option.Choice2.HasValue)",
          "location": {
            "start": {
              "line": 39,
              "column": 21
            },
            "end": {
              "line": 39,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "633",
          "mutatorName": "Negate expression",
          "replacement": "!(Option.Choice3.HasValue)",
          "location": {
            "start": {
              "line": 40,
              "column": 21
            },
            "end": {
              "line": 40,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "634",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 61,
              "column": 100
            },
            "end": {
              "line": 61,
              "column": 156
            }
          },
          "status": "Survived"
        },
        {
          "id": "635",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 66,
              "column": 98
            },
            "end": {
              "line": 66,
              "column": 151
            }
          },
          "status": "Survived"
        },
        {
          "id": "636",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 71,
              "column": 117
            },
            "end": {
              "line": 71,
              "column": 175
            }
          },
          "status": "Survived"
        },
        {
          "id": "637",
          "mutatorName": "Equality mutation",
          "replacement": "MemberType != convertType",
          "location": {
            "start": {
              "line": 78,
              "column": 17
            },
            "end": {
              "line": 78,
              "column": 42
            }
          },
          "status": "Killed"
        },
        {
          "id": "638",
          "mutatorName": "Negate expression",
          "replacement": "!(MemberType == convertType)",
          "location": {
            "start": {
              "line": 78,
              "column": 17
            },
            "end": {
              "line": 78,
              "column": 42
            }
          },
          "status": "Killed"
        },
        {
          "id": "639",
          "mutatorName": "Logical mutation",
          "replacement": "MemberType == MemberType.StepList || convertType == MemberType.Step",
          "location": {
            "start": {
              "line": 80,
              "column": 17
            },
            "end": {
              "line": 80,
              "column": 84
            }
          },
          "status": "Killed"
        },
        {
          "id": "640",
          "mutatorName": "Negate expression",
          "replacement": "!(MemberType == MemberType.StepList && convertType == MemberType.Step)",
          "location": {
            "start": {
              "line": 80,
              "column": 17
            },
            "end": {
              "line": 80,
              "column": 84
            }
          },
          "status": "Killed"
        },
        {
          "id": "641",
          "mutatorName": "Equality mutation",
          "replacement": "MemberType != MemberType.StepList ",
          "location": {
            "start": {
              "line": 80,
              "column": 17
            },
            "end": {
              "line": 80,
              "column": 50
            }
          },
          "status": "Killed"
        },
        {
          "id": "642",
          "mutatorName": "Equality mutation",
          "replacement": "convertType != MemberType.Step",
          "location": {
            "start": {
              "line": 80,
              "column": 54
            },
            "end": {
              "line": 80,
              "column": 84
            }
          },
          "status": "Killed"
        },
        {
          "id": "643",
          "mutatorName": "Logical mutation",
          "replacement": "MemberType == MemberType.VariableName || convertType == MemberType.Step",
          "location": {
            "start": {
              "line": 86,
              "column": 17
            },
            "end": {
              "line": 86,
              "column": 88
            }
          },
          "status": "Survived"
        },
        {
          "id": "644",
          "mutatorName": "Negate expression",
          "replacement": "!(MemberType == MemberType.VariableName && convertType == MemberType.Step)",
          "location": {
            "start": {
              "line": 86,
              "column": 17
            },
            "end": {
              "line": 86,
              "column": 88
            }
          },
          "status": "Killed"
        },
        {
          "id": "645",
          "mutatorName": "Equality mutation",
          "replacement": "MemberType != MemberType.VariableName ",
          "location": {
            "start": {
              "line": 86,
              "column": 17
            },
            "end": {
              "line": 86,
              "column": 54
            }
          },
          "status": "Killed"
        },
        {
          "id": "646",
          "mutatorName": "Equality mutation",
          "replacement": "convertType != MemberType.Step",
          "location": {
            "start": {
              "line": 86,
              "column": 58
            },
            "end": {
              "line": 86,
              "column": 88
            }
          },
          "status": "Killed"
        },
        {
          "id": "647",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 92,
              "column": 47
            },
            "end": {
              "line": 92,
              "column": 66
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "648",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 116,
              "column": 39
            },
            "end": {
              "line": 116,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "649",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 117,
              "column": 17
            },
            "end": {
              "line": 117,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "650",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 117,
              "column": 54
            },
            "end": {
              "line": 117,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "651",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 130,
              "column": 28
            },
            "end": {
              "line": 130,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "652",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is StepMember other && Equals(other)",
          "location": {
            "start": {
              "line": 139,
              "column": 53
            },
            "end": {
              "line": 139,
              "column": 123
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "653",
          "mutatorName": "Logical mutation",
          "replacement": "obj is StepMember other || Equals(other)",
          "location": {
            "start": {
              "line": 139,
              "column": 83
            },
            "end": {
              "line": 139,
              "column": 123
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "654",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "Equals(left, right)",
          "location": {
            "start": {
              "line": 152,
              "column": 80
            },
            "end": {
              "line": 152,
              "column": 100
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\StepNameBuilderFromTemplate.cs": {
      "language": "cs",
      "source": "using System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Builds the name for a particular instance of a step.\r\n    /// <" + "/summary>\r\n    public class StepNameBuilderFromTemplate : IStepNameBuilder\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new step name.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"templateString\"><" + "/param>\r\n        public StepNameBuilderFromTemplate(string templateString) => TemplateString = templateString;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// The template to use for this step. Use square brackets for parameters and angle brackets for list parameters.\r\n        /// <" + "/summary>\r\n        public string TemplateString { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Optional delimiter to use for list properties.\r\n        /// <" + "/summary>\r\n        public string ListDelimiter { get; set; } = \"; \";\r\n\r\n        /// <" + "summary>\r\n        /// Gets the name of the step from the step arguments\r\n        /// <" + "/summary>\r\n        public string GetFromArguments(FreezableStepData freezableStepData)\r\n        {\r\n            var replacedString = NameVariableRegex.Replace(TemplateString, GetReplacement);\r\n\r\n            return replacedString;\r\n\r\n            string GetReplacement(Match m)\r\n            {\r\n                var variableName = m.Groups[\"ArgumentName\"].Value;\r\n\r\n                var p = freezableStepData.Dictionary.TryFindOrFail(variableName, null)\r\n                    .Map(x=>x.Join(vn=>vn.ToString(),\r\n                        fp=>fp.StepName,\r\n                        l=> string.Join(ListDelimiter, Enumerable.Select<" + "IFreezableStep, string>(l, i=>i.StepName))))\r\n                    .OnFailureCompensate(x=>Result.Success(\"Unknown\"));\r\n\r\n                return p.Value;\r\n            }\r\n\r\n        }\r\n\r\n        private static readonly Regex NameVariableRegex = new Regex(@\"\\[(?<" + "ArgumentName>[\\w_][\\w\\d_]*)\\]\", RegexOptions.Compiled);\r\n    }\r\n}",
      "mutants": [
        {
          "id": "655",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 28,
              "column": 53
            },
            "end": {
              "line": 28,
              "column": 57
            }
          },
          "status": "Killed"
        },
        {
          "id": "656",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 41,
              "column": 45
            },
            "end": {
              "line": 41,
              "column": 59
            }
          },
          "status": "Killed"
        },
        {
          "id": "657",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 47,
              "column": 60
            },
            "end": {
              "line": 47,
              "column": 69
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "658",
          "mutatorName": "Regex character class shorthand negation mutation",
          "replacement": "\"\\\\[(?<" + "ArgumentName>[\\\\W_][\\\\w\\\\d_]*)\\\\]\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived",
          "description": "Character class shorthand \"\\w\" was replaced with \"\\W\" at offset 19."
        },
        {
          "id": "659",
          "mutatorName": "Regex character class negation mutation",
          "replacement": "\"\\\\[(?<" + "ArgumentName>[^\\\\w_][\\\\w\\\\d_]*)\\\\]\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived",
          "description": "Character class \"[\\w_]\" was replaced with \"[^\\w_]\" at offset 18."
        },
        {
          "id": "660",
          "mutatorName": "Regex character class shorthand negation mutation",
          "replacement": "\"\\\\[(?<" + "ArgumentName>[\\\\w_][\\\\W\\\\d_]*)\\\\]\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived",
          "description": "Character class shorthand \"\\w\" was replaced with \"\\W\" at offset 24."
        },
        {
          "id": "661",
          "mutatorName": "Regex character class shorthand negation mutation",
          "replacement": "\"\\\\[(?<" + "ArgumentName>[\\\\w_][\\\\w\\\\D_]*)\\\\]\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived",
          "description": "Character class shorthand \"\\d\" was replaced with \"\\D\" at offset 26."
        },
        {
          "id": "662",
          "mutatorName": "Regex character class negation mutation",
          "replacement": "\"\\\\[(?<" + "ArgumentName>[\\\\w_][^\\\\w\\\\d_]*)\\\\]\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived",
          "description": "Character class \"[\\w\\d_]\" was replaced with \"[^\\w\\d_]\" at offset 23."
        },
        {
          "id": "663",
          "mutatorName": "Regex quantifier removal mutation",
          "replacement": "\"\\\\[(?<" + "ArgumentName>[\\\\w_][\\\\w\\\\d_])\\\\]\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived",
          "description": "Quantifier \"*\" was removed at offset 30."
        },
        {
          "id": "664",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 54,
              "column": 69
            },
            "end": {
              "line": 54,
              "column": 106
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Internal\\StreamReaderWithSource.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.IO;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    internal class StreamReaderWithSource<" + "TEnum> : IStreamReader<" + "(string line, TEnum source)>\r\n        where TEnum : Enum\r\n    {\r\n        private readonly StreamReader _underlying;\r\n        private readonly TEnum _source;\r\n\r\n        public StreamReaderWithSource(StreamReader underlying, TEnum source)\r\n        {\r\n            _underlying = underlying;\r\n            _source = source;\r\n        }\r\n\r\n        public async Task<" + "(string line, TEnum source)?> ReadLineAsync()\r\n        {\r\n            var line = await _underlying.ReadLineAsync();\r\n\r\n            if (line == null)\r\n                return null;\r\n\r\n            return (line, _source);\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "665",
          "mutatorName": "Equality mutation",
          "replacement": "line != null",
          "location": {
            "start": {
              "line": 23,
              "column": 17
            },
            "end": {
              "line": 23,
              "column": 29
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "666",
          "mutatorName": "Negate expression",
          "replacement": "!(line == null)",
          "location": {
            "start": {
              "line": 23,
              "column": 17
            },
            "end": {
              "line": 23,
              "column": 29
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Internal\\VariableName.cs": {
      "language": "cs",
      "source": "using System;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// The name of a variable that can be written and read from the step state.\r\n    /// <" + "/summary>\r\n    public readonly struct VariableName : IEquatable<" + "VariableName>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new VariableName.\r\n        /// <" + "/summary>\r\n        public VariableName(string name) => Name = name;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the variable.\r\n        /// <" + "/summary>\r\n        public string Name { get;  }\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(VariableName other) => Name == other.Name;\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => obj is VariableName other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => Name.GetHashCode();\r\n\r\n        /// <" + "summary>\r\n        /// Equals operator\r\n        /// <" + "/summary>\r\n        public static bool operator ==(VariableName left, VariableName right) => left.Equals(right);\r\n\r\n        /// <" + "summary>\r\n        /// Not Equals Operator\r\n        /// <" + "/summary>\r\n        public static bool operator !=(VariableName left, VariableName right) => !left.Equals(right);\r\n\r\n        /// <" + "summary>\r\n        /// Creates the name of a generic type argument.\r\n        /// <" + "/summary>\r\n        public VariableName CreateChild(int argNumber) => new VariableName(Name + \"ARG\" + argNumber);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string ToString() => $\"<" + "{Name}>\";\r\n    }\r\n}",
      "mutants": [
        {
          "id": "667",
          "mutatorName": "Equality mutation",
          "replacement": "Name != other.Name",
          "location": {
            "start": {
              "line": 21,
              "column": 51
            },
            "end": {
              "line": 21,
              "column": 69
            }
          },
          "status": "Killed"
        },
        {
          "id": "668",
          "mutatorName": "Logical mutation",
          "replacement": "obj is VariableName other || Equals(other)",
          "location": {
            "start": {
              "line": 24,
              "column": 53
            },
            "end": {
              "line": 24,
              "column": 95
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "669",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "left.Equals(right)",
          "location": {
            "start": {
              "line": 37,
              "column": 82
            },
            "end": {
              "line": 37,
              "column": 101
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "670",
          "mutatorName": "Arithmetic mutation",
          "replacement": "Name + \"ARG\" - argNumber",
          "location": {
            "start": {
              "line": 42,
              "column": 76
            },
            "end": {
              "line": 42,
              "column": 100
            }
          },
          "status": "CompileError"
        },
        {
          "id": "671",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 42,
              "column": 83
            },
            "end": {
              "line": 42,
              "column": 88
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "672",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 45,
              "column": 46
            },
            "end": {
              "line": 45,
              "column": 57
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Internal\\VariableTypeReference.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Immutable;\r\n\r\nnamespace Reductech.EDR.Core.Internal\r\n{\r\n    /// <" + "summary>\r\n    /// Indicates that this type is the same as that of the variable with the given name.\r\n    /// <" + "/summary>\r\n    public sealed class VariableTypeReference : ITypeReference, IEquatable<" + "ITypeReference>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new VariableTypeReference.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"variableName\"><" + "/param>\r\n        public VariableTypeReference(VariableName variableName) => VariableName = variableName;\r\n\r\n        /// <" + "summary>\r\n        /// The name of a variable with the same type as this type.\r\n        /// <" + "/summary>\r\n        public VariableName VariableName { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Equals(ITypeReference? other)\r\n        {\r\n            if (other is null) return false;\r\n            if (ReferenceEquals(this, other)) return true;\r\n\r\n            return other switch\r\n            {\r\n                ActualTypeReference _ => false,\r\n                MultipleTypeReference multipleTypeReference => multipleTypeReference.AllReferences.Count == 1 &&\r\n                                                               multipleTypeReference.AllReferences.Contains(this),\r\n                VariableTypeReference typeReference => VariableName == typeReference.VariableName,\r\n                GenericTypeReference _ => false,\r\n                _ => throw new ArgumentOutOfRangeException(nameof(other))\r\n            };\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override bool Equals(object? obj) => ReferenceEquals(this, obj) || obj is ITypeReference other && Equals(other);\r\n\r\n        /// <" + "inheritdoc />\r\n        public override int GetHashCode() => VariableName.GetHashCode();\r\n\r\n        /// <" + "inheritdoc />\r\n        IEnumerable<" + "VariableTypeReference> ITypeReference.VariableTypeReferences => new[] {this};\r\n\r\n        /// <" + "inheritdoc />\r\n        IEnumerable<" + "ActualTypeReference> ITypeReference.ActualTypeReferences => ImmutableArray<" + "ActualTypeReference>.Empty;\r\n\r\n        /// <" + "inheritdoc />\r\n        public IEnumerable<" + "ITypeReference> TypeArgumentReferences => ImmutableList<" + "ITypeReference>.Empty;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "673",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 26,
              "column": 39
            },
            "end": {
              "line": 26,
              "column": 44
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "674",
          "mutatorName": "Negate expression",
          "replacement": "!(ReferenceEquals(this, other))",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 45
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "675",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 27,
              "column": 54
            },
            "end": {
              "line": 27,
              "column": 58
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "676",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 31,
              "column": 42
            },
            "end": {
              "line": 31,
              "column": 47
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "677",
          "mutatorName": "Logical mutation",
          "replacement": "multipleTypeReference.AllReferences.Count == 1 ||\r\n                                                               multipleTypeReference.AllReferences.Contains(this)",
          "location": {
            "start": {
              "line": 32,
              "column": 64
            },
            "end": {
              "line": 33,
              "column": 114
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "678",
          "mutatorName": "Equality mutation",
          "replacement": "multipleTypeReference.AllReferences.Count != 1 ",
          "location": {
            "start": {
              "line": 32,
              "column": 64
            },
            "end": {
              "line": 32,
              "column": 110
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "679",
          "mutatorName": "Equality mutation",
          "replacement": "VariableName != typeReference.VariableName",
          "location": {
            "start": {
              "line": 34,
              "column": 56
            },
            "end": {
              "line": 34,
              "column": 98
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "680",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 35,
              "column": 43
            },
            "end": {
              "line": 35,
              "column": 48
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "681",
          "mutatorName": "Logical mutation",
          "replacement": "ReferenceEquals(this, obj) && obj is ITypeReference other && Equals(other)",
          "location": {
            "start": {
              "line": 41,
              "column": 53
            },
            "end": {
              "line": 41,
              "column": 127
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "682",
          "mutatorName": "Logical mutation",
          "replacement": "obj is ITypeReference other || Equals(other)",
          "location": {
            "start": {
              "line": 41,
              "column": 83
            },
            "end": {
              "line": 41,
              "column": 127
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\AnyPrimitiveComponent.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Deserializes a regex group into a constant of any type.\r\n    /// <" + "/summary>\r\n    public class AnyPrimitiveComponent :  ISerializerBlock,  IStepSerializerComponent\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new AnyPrimitiveComponent\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"propertyName\"><" + "/param>\r\n        public AnyPrimitiveComponent(string propertyName) => PropertyName = propertyName;\r\n\r\n        ///// <" + "inheritdoc />\r\n        //public string GetGroupName(int index) => \"Value\" + index;\r\n\r\n        /// <" + "summary>\r\n        /// The property name\r\n        /// <" + "/summary>\r\n        public string PropertyName { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) =>\r\n            data.Dictionary\r\n                .TryFindOrFail(PropertyName, null)\r\n                .Bind(x => x.Join(VariableNameComponent.Serialize,\r\n                    TrySerialize,\r\n                    _ => Result.Failure<" + "string>(\"Cannot serialize list\")\r\n\r\n                ));\r\n\r\n        private static Result<" + "string> TrySerialize(IFreezableStep step)\r\n        {\r\n            if (step is ConstantFreezableStep constantFreezableProcess)\r\n                return SerializationMethods.SerializeConstant(constantFreezableProcess, true);\r\n            if (step is CompoundFreezableStep compound && compound.StepConfiguration == null)\r\n                return compound.StepFactory.Serializer.TrySerialize(compound.FreezableStepData);\r\n\r\n            return Result.Failure<" + "string>(\"Cannot serialize compound with a step configuration\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "683",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 33,
              "column": 49
            },
            "end": {
              "line": 33,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "684",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 40,
              "column": 89
            },
            "end": {
              "line": 40,
              "column": 93
            }
          },
          "status": "Killed"
        },
        {
          "id": "685",
          "mutatorName": "Logical mutation",
          "replacement": "step is CompoundFreezableStep compound || compound.StepConfiguration == null",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "686",
          "mutatorName": "Negate expression",
          "replacement": "!(step is CompoundFreezableStep compound && compound.StepConfiguration == null)",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "687",
          "mutatorName": "Equality mutation",
          "replacement": "compound.StepConfiguration != null",
          "location": {
            "start": {
              "line": 41,
              "column": 59
            },
            "end": {
              "line": 41,
              "column": 93
            }
          },
          "status": "Killed"
        },
        {
          "id": "688",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 44,
              "column": 43
            },
            "end": {
              "line": 44,
              "column": 96
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\BooleanComponent.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Deserializes a regex group into a bool.\r\n    /// <" + "/summary>\r\n    public class BooleanComponent : ISerializerBlock, IStepSerializerComponent\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new BooleanComponent\r\n        /// <" + "/summary>\r\n        public BooleanComponent(string propertyName) => PropertyName = propertyName;\r\n\r\n        /// <" + "summary>\r\n        /// The property name\r\n        /// <" + "/summary>\r\n        public string PropertyName { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) =>\r\n            data.Dictionary\r\n                .TryFindOrFail(PropertyName, null)\r\n                .Bind(x => x.Join(VariableNameComponent.Serialize,\r\n                    TrySerialize,\r\n                    _ => Result.Failure<" + "string>(\"Cannot serialize list\")\r\n\r\n                ));\r\n\r\n        private static Result<" + "string> TrySerialize(IFreezableStep step)\r\n        {\r\n            if (step is ConstantFreezableStep constantFreezableProcess && constantFreezableProcess.Value is bool b)\r\n                return b.ToString();\r\n            if (step is CompoundFreezableStep compound && compound.StepConfiguration == null)\r\n                return compound.StepFactory.Serializer.TrySerialize(compound.FreezableStepData);\r\n\r\n            return Result.Failure<" + "string>(\"Cannot serialize compound as a primitive\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "689",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 28,
              "column": 49
            },
            "end": {
              "line": 28,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "690",
          "mutatorName": "Logical mutation",
          "replacement": "step is ConstantFreezableStep constantFreezableProcess || constantFreezableProcess.Value is bool b",
          "location": {
            "start": {
              "line": 34,
              "column": 17
            },
            "end": {
              "line": 34,
              "column": 115
            }
          },
          "status": "CompileError"
        },
        {
          "id": "691",
          "mutatorName": "Negate expression",
          "replacement": "!(step is ConstantFreezableStep constantFreezableProcess && constantFreezableProcess.Value is bool b)",
          "location": {
            "start": {
              "line": 34,
              "column": 17
            },
            "end": {
              "line": 34,
              "column": 115
            }
          },
          "status": "CompileError"
        },
        {
          "id": "692",
          "mutatorName": "Logical mutation",
          "replacement": "step is CompoundFreezableStep compound || compound.StepConfiguration == null",
          "location": {
            "start": {
              "line": 36,
              "column": 17
            },
            "end": {
              "line": 36,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "693",
          "mutatorName": "Negate expression",
          "replacement": "!(step is CompoundFreezableStep compound && compound.StepConfiguration == null)",
          "location": {
            "start": {
              "line": 36,
              "column": 17
            },
            "end": {
              "line": 36,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "694",
          "mutatorName": "Equality mutation",
          "replacement": "compound.StepConfiguration != null",
          "location": {
            "start": {
              "line": 36,
              "column": 59
            },
            "end": {
              "line": 36,
              "column": 93
            }
          },
          "status": "Killed"
        },
        {
          "id": "695",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 39,
              "column": 43
            },
            "end": {
              "line": 39,
              "column": 85
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\EnumDisplayComponent.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n\r\n    /// <" + "summary>\r\n    /// Deserializes a regex group into an enum.\r\n    /// <" + "/summary>\r\n    public class EnumDisplayComponent<" + "T>\r\n        : ISerializerBlock,  IStepSerializerComponent\r\n        where T : Enum\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new EnumDisplayComponent\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"propertyName\"><" + "/param>\r\n        public EnumDisplayComponent(string propertyName) => PropertyName = propertyName;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the property\r\n        /// <" + "/summary>\r\n        public string PropertyName { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) =>\r\n            data.Dictionary\r\n                .TryFindOrFail(PropertyName, null)\r\n                .Bind(x => x.Join(VariableNameComponent.Serialize,\r\n                    TrySerialize,\r\n                    _ => Result.Failure<" + "string>(\"Cannot serialize list\")));\r\n\r\n        private static Result<" + "string> TrySerialize(IFreezableStep step)\r\n        {\r\n\r\n            if (step is ConstantFreezableStep constant && constant.Value is T t)\r\n                return t.GetDisplayName();\r\n\r\n            if (step is CompoundFreezableStep compound && compound.StepConfiguration == null)\r\n            {\r\n                var cSerializeResult = compound.StepFactory.Serializer.TrySerialize(compound.FreezableStepData);\r\n\r\n                return cSerializeResult;\r\n            }\r\n\r\n            return Result.Failure<" + "string>(\"Cannot serialize a step with a Configuration\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "696",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 33,
              "column": 49
            },
            "end": {
              "line": 33,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "697",
          "mutatorName": "Logical mutation",
          "replacement": "step is ConstantFreezableStep constant || constant.Value is T t",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 80
            }
          },
          "status": "CompileError"
        },
        {
          "id": "698",
          "mutatorName": "Negate expression",
          "replacement": "!(step is ConstantFreezableStep constant && constant.Value is T t)",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 80
            }
          },
          "status": "CompileError"
        },
        {
          "id": "699",
          "mutatorName": "Logical mutation",
          "replacement": "step is CompoundFreezableStep compound || compound.StepConfiguration == null",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "700",
          "mutatorName": "Negate expression",
          "replacement": "!(step is CompoundFreezableStep compound && compound.StepConfiguration == null)",
          "location": {
            "start": {
              "line": 41,
              "column": 17
            },
            "end": {
              "line": 41,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "701",
          "mutatorName": "Equality mutation",
          "replacement": "compound.StepConfiguration != null",
          "location": {
            "start": {
              "line": 41,
              "column": 59
            },
            "end": {
              "line": 41,
              "column": 93
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "702",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 48,
              "column": 43
            },
            "end": {
              "line": 48,
              "column": 89
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\FixedStringComponent.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Include a fixed string in serialization.\r\n    /// <" + "/summary>\r\n    public class FixedStringComponent : IStepSerializerComponent, ISerializerBlock//, IDeserializerBlock\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new FixedStringComponent\r\n        /// <" + "/summary>\r\n        public FixedStringComponent(string value) => Value = value;\r\n\r\n        /// <" + "summary>\r\n        /// The fixed value to insert.\r\n        /// <" + "/summary>\r\n        public string Value { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) => Value;\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Serialization\\FreezableStepDeserializer.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\nusing YamlDotNet.Core;\r\nusing YamlDotNet.Core.Events;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    internal class FreezableStepDeserializer : TypedYamlDeserializer<" + "IFreezableStep>\r\n    {\r\n        /// <" + "inheritdoc />\r\n        public FreezableStepDeserializer(StepMemberParser stepMemberParser) => StepMemberParser = stepMemberParser;\r\n\r\n        /// <" + "summary>\r\n        /// The step member parser\r\n        /// <" + "/summary>\r\n        public StepMemberParser StepMemberParser { get; }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "IFreezableStep, YamlException> TryDeserialize(IParser parser, Func<" + "IParser, Type, object?> nestedObjectDeserializer)\r\n        {\r\n            if (parser.Current == null)\r\n                return new YamlException(\"Reader is empty\");\r\n\r\n            var markStart = parser.Current.Start;\r\n            var markEnd = parser.Current.End;\r\n\r\n            var dictionary = new Dictionary<" + "string, StepMember>();\r\n\r\n            IStepFactory? factory = null;\r\n            Configuration? configuration = null;\r\n\r\n            parser.Consume<" + "MappingStart>();\r\n            while (!parser.TryConsume<" + "MappingEnd>(out _))\r\n            {\r\n                //TODO handle promises\r\n\r\n                var keyResult = TryDeserializeNested<" + "string>(nestedObjectDeserializer, parser);\r\n\r\n                if (keyResult.IsFailure)\r\n                    return keyResult.ConvertFailure<" + "IFreezableStep>();\r\n\r\n                if (keyResult.Value.Equals(YamlMethods.TypeString, StringComparison.OrdinalIgnoreCase))\r\n                {\r\n                    if (factory != null)\r\n                        return new YamlException(markStart, markEnd, $\"Duplicate property '{keyResult.Value}'\");\r\n\r\n                    var typeNameResult = TryDeserializeNested<" + "string>(nestedObjectDeserializer, parser)\r\n                        .Bind(x => StepMemberParser\r\n                            .StepFactoryStore.Dictionary.TryFindOrFail(x, $\"'{x}' is not the name of a Step\")\r\n                            .MapFailure(e => new YamlException(markStart, markEnd, e))\r\n                        );\r\n\r\n                    if (typeNameResult.IsFailure)\r\n                        return typeNameResult.ConvertFailure<" + "IFreezableStep>();\r\n\r\n                    factory = typeNameResult.Value;\r\n                }\r\n                else if (keyResult.Value.Equals(YamlMethods.ConfigString, StringComparison.OrdinalIgnoreCase))\r\n                {\r\n                    if (configuration != null)\r\n                        return new YamlException(markStart, markEnd, $\"Duplicate property '{keyResult.Value}'\");\r\n\r\n                    var configResult = TryDeserializeNested<" + "Configuration>(nestedObjectDeserializer, parser);\r\n\r\n                    if (configResult.IsFailure)\r\n                        return configResult.ConvertFailure<" + "IFreezableStep>();\r\n\r\n                    configuration = configResult.Value;\r\n                }\r\n                else\r\n                {\r\n                    if (dictionary.ContainsKey(keyResult.Value))\r\n                        return new YamlException(markStart, markEnd, $\"Duplicate property '{keyResult.Value}'\");\r\n\r\n\r\n                    var memberResult = TryDeserializeNested<" + "StepMember>(nestedObjectDeserializer, parser);\r\n\r\n                    if (memberResult.IsFailure)\r\n                        return memberResult.ConvertFailure<" + "IFreezableStep>();\r\n\r\n                    dictionary.Add(keyResult.Value, memberResult.Value);\r\n                }\r\n            }\r\n\r\n\r\n            if (factory == null)\r\n                return new YamlException(markStart, markEnd, $\"The '{YamlMethods.TypeString}' property must be set.\");\r\n\r\n            return new CompoundFreezableStep(factory, new FreezableStepData(dictionary), configuration);\r\n\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "703",
          "mutatorName": "Equality mutation",
          "replacement": "parser.Current != null",
          "location": {
            "start": {
              "line": 25,
              "column": 17
            },
            "end": {
              "line": 25,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "704",
          "mutatorName": "Negate expression",
          "replacement": "!(parser.Current == null)",
          "location": {
            "start": {
              "line": 25,
              "column": 17
            },
            "end": {
              "line": 25,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "705",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 26,
              "column": 42
            },
            "end": {
              "line": 26,
              "column": 59
            }
          },
          "status": "Ignored"
        },
        {
          "id": "706",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "parser.TryConsume<" + "MappingEnd>(out _)",
          "location": {
            "start": {
              "line": 37,
              "column": 20
            },
            "end": {
              "line": 37,
              "column": 57
            }
          },
          "status": "Killed"
        },
        {
          "id": "707",
          "mutatorName": "Negate expression",
          "replacement": "!(!parser.TryConsume<" + "MappingEnd>(out _))",
          "location": {
            "start": {
              "line": 37,
              "column": 20
            },
            "end": {
              "line": 37,
              "column": 57
            }
          },
          "status": "Killed"
        },
        {
          "id": "708",
          "mutatorName": "Negate expression",
          "replacement": "!(keyResult.IsFailure)",
          "location": {
            "start": {
              "line": 43,
              "column": 21
            },
            "end": {
              "line": 43,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "709",
          "mutatorName": "Negate expression",
          "replacement": "!(keyResult.Value.Equals(YamlMethods.TypeString, StringComparison.OrdinalIgnoreCase))",
          "location": {
            "start": {
              "line": 46,
              "column": 21
            },
            "end": {
              "line": 46,
              "column": 103
            }
          },
          "status": "Killed"
        },
        {
          "id": "710",
          "mutatorName": "Equality mutation",
          "replacement": "factory == null",
          "location": {
            "start": {
              "line": 48,
              "column": 25
            },
            "end": {
              "line": 48,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "711",
          "mutatorName": "Negate expression",
          "replacement": "!(factory != null)",
          "location": {
            "start": {
              "line": 48,
              "column": 25
            },
            "end": {
              "line": 48,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "712",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 49,
              "column": 70
            },
            "end": {
              "line": 49,
              "column": 111
            }
          },
          "status": "Ignored"
        },
        {
          "id": "713",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 53,
              "column": 75
            },
            "end": {
              "line": 53,
              "column": 109
            }
          },
          "status": "Survived"
        },
        {
          "id": "714",
          "mutatorName": "Negate expression",
          "replacement": "!(typeNameResult.IsFailure)",
          "location": {
            "start": {
              "line": 57,
              "column": 25
            },
            "end": {
              "line": 57,
              "column": 49
            }
          },
          "status": "Killed"
        },
        {
          "id": "715",
          "mutatorName": "Negate expression",
          "replacement": "!(keyResult.Value.Equals(YamlMethods.ConfigString, StringComparison.OrdinalIgnoreCase))",
          "location": {
            "start": {
              "line": 62,
              "column": 26
            },
            "end": {
              "line": 62,
              "column": 110
            }
          },
          "status": "Killed"
        },
        {
          "id": "716",
          "mutatorName": "Equality mutation",
          "replacement": "configuration == null",
          "location": {
            "start": {
              "line": 64,
              "column": 25
            },
            "end": {
              "line": 64,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "717",
          "mutatorName": "Negate expression",
          "replacement": "!(configuration != null)",
          "location": {
            "start": {
              "line": 64,
              "column": 25
            },
            "end": {
              "line": 64,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "718",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 65,
              "column": 70
            },
            "end": {
              "line": 65,
              "column": 111
            }
          },
          "status": "Ignored"
        },
        {
          "id": "719",
          "mutatorName": "Negate expression",
          "replacement": "!(configResult.IsFailure)",
          "location": {
            "start": {
              "line": 69,
              "column": 25
            },
            "end": {
              "line": 69,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "720",
          "mutatorName": "Negate expression",
          "replacement": "!(dictionary.ContainsKey(keyResult.Value))",
          "location": {
            "start": {
              "line": 76,
              "column": 25
            },
            "end": {
              "line": 76,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "721",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 77,
              "column": 70
            },
            "end": {
              "line": 77,
              "column": 111
            }
          },
          "status": "Ignored"
        },
        {
          "id": "722",
          "mutatorName": "Negate expression",
          "replacement": "!(memberResult.IsFailure)",
          "location": {
            "start": {
              "line": 82,
              "column": 25
            },
            "end": {
              "line": 82,
              "column": 47
            }
          },
          "status": "Killed"
        },
        {
          "id": "723",
          "mutatorName": "Equality mutation",
          "replacement": "factory != null",
          "location": {
            "start": {
              "line": 90,
              "column": 17
            },
            "end": {
              "line": 90,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "724",
          "mutatorName": "Negate expression",
          "replacement": "!(factory == null)",
          "location": {
            "start": {
              "line": 90,
              "column": 17
            },
            "end": {
              "line": 90,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "725",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 91,
              "column": 62
            },
            "end": {
              "line": 91,
              "column": 117
            }
          },
          "status": "Ignored"
        }
      ]
    },
    "Core\\Serialization\\FunctionSerializer.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// The default step serializer for functions.\r\n    /// Produces results like: Print(Value: 'Hello World')\r\n    /// <" + "/summary>\r\n    public sealed class FunctionSerializer : IStepSerializer\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new FunctionSerializer\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"name\"><" + "/param>\r\n        public FunctionSerializer(string name) { Name = name; }\r\n\r\n        /// <" + "summary>\r\n        /// The name of the function.\r\n        /// <" + "/summary>\r\n        public string Name { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TrySerialize(FreezableStepData data)\r\n        {\r\n            var sb = new StringBuilder();\r\n            sb.Append(Name);\r\n            sb.Append(\"(\");\r\n\r\n            var first = true;\r\n\r\n\r\n            foreach (var (propertyName, value) in\r\n                data.Dictionary.OrderBy(x=>x.Key))\r\n            {\r\n                if (first)\r\n                    first = false;\r\n                else\r\n                    sb.Append(\", \");\r\n\r\n                sb.Append(propertyName);\r\n                sb.Append(\" = \");\r\n\r\n\r\n                var valueSerializeResult =\r\n                    value.Join(\r\n                        VariableNameComponent.Serialize,\r\n                        SerializeProcess,\r\n                        SerializeList);\r\n\r\n                if (valueSerializeResult.IsFailure)\r\n                    return valueSerializeResult;\r\n\r\n                sb.Append(valueSerializeResult.Value);\r\n            }\r\n            sb.Append(\")\");\r\n\r\n            return sb.ToString();\r\n\r\n\r\n            static Result<" + "string> SerializeProcess(IFreezableStep freezableProcess)\r\n            {\r\n                return freezableProcess switch\r\n                {\r\n                    ConstantFreezableStep constant => SerializationMethods.SerializeConstant(constant, true),\r\n                    CompoundFreezableStep compoundFreezableProcess => compoundFreezableProcess.StepFactory\r\n                        .Serializer.TrySerialize(compoundFreezableProcess.FreezableStepData),\r\n                    _ => Result.Failure<" + "string>(\"Cannot serialize\")\r\n                };\r\n            }\r\n\r\n            static Result<" + "string> SerializeList(IReadOnlyList<" + "IFreezableStep> list)\r\n            {\r\n                var elementResult = list.Select(SerializeProcess).Combine();\r\n                if (elementResult.IsFailure)\r\n                    return elementResult.ConvertFailure<" + "string>();\r\n\r\n                var sb2 = new StringBuilder();\r\n\r\n                sb2.Append(\"[\");\r\n                sb2.AppendJoin(\", \", elementResult.Value);\r\n                sb2.Append(\"]\");\r\n\r\n                return sb2.ToString();\r\n            }\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "726",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 31,
              "column": 23
            },
            "end": {
              "line": 31,
              "column": 26
            }
          },
          "status": "Killed"
        },
        {
          "id": "727",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 33,
              "column": 25
            },
            "end": {
              "line": 33,
              "column": 29
            }
          },
          "status": "Killed"
        },
        {
          "id": "728",
          "mutatorName": "Linq method mutation (OrderBy() to OrderByDescending())",
          "replacement": "                data.Dictionary.OrderByDescending(x=>x.Key)",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 50
            }
          },
          "status": "Survived"
        },
        {
          "id": "729",
          "mutatorName": "Negate expression",
          "replacement": "!(first)",
          "location": {
            "start": {
              "line": 39,
              "column": 21
            },
            "end": {
              "line": 39,
              "column": 26
            }
          },
          "status": "Killed"
        },
        {
          "id": "730",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 40,
              "column": 29
            },
            "end": {
              "line": 40,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "731",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 42,
              "column": 31
            },
            "end": {
              "line": 42,
              "column": 35
            }
          },
          "status": "Killed"
        },
        {
          "id": "732",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 45,
              "column": 27
            },
            "end": {
              "line": 45,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "733",
          "mutatorName": "Negate expression",
          "replacement": "!(valueSerializeResult.IsFailure)",
          "location": {
            "start": {
              "line": 54,
              "column": 21
            },
            "end": {
              "line": 54,
              "column": 51
            }
          },
          "status": "Killed"
        },
        {
          "id": "734",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 59,
              "column": 23
            },
            "end": {
              "line": 59,
              "column": 26
            }
          },
          "status": "Killed"
        },
        {
          "id": "735",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 68,
              "column": 104
            },
            "end": {
              "line": 68,
              "column": 108
            }
          },
          "status": "Killed"
        },
        {
          "id": "736",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 71,
              "column": 49
            },
            "end": {
              "line": 71,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "737",
          "mutatorName": "Negate expression",
          "replacement": "!(elementResult.IsFailure)",
          "location": {
            "start": {
              "line": 78,
              "column": 21
            },
            "end": {
              "line": 78,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "738",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 83,
              "column": 28
            },
            "end": {
              "line": 83,
              "column": 31
            }
          },
          "status": "Killed"
        },
        {
          "id": "739",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 84,
              "column": 32
            },
            "end": {
              "line": 84,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "740",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 85,
              "column": 28
            },
            "end": {
              "line": 85,
              "column": 31
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Serialization\\GeneralDeserializer.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing CSharpFunctionalExtensions;\r\nusing YamlDotNet.Core;\r\nusing YamlDotNet.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    internal sealed class GeneralDeserializer : INodeDeserializer\r\n    {\r\n        public GeneralDeserializer(IReadOnlyList<" + "ITypedYamlDeserializer> deserializers) => Deserializers = deserializers;\r\n\r\n        public IReadOnlyList<" + "ITypedYamlDeserializer> Deserializers { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Deserialize(IParser reader, Type expectedType, Func<" + "IParser, Type, object?> nestedObjectDeserializer, out object? value)\r\n        {\r\n            foreach (var typedYamlDeserializer in Deserializers)\r\n            {\r\n                if (!expectedType.IsAssignableFrom(typedYamlDeserializer.Type)) continue;\r\n\r\n                var (isSuccess, _, o, yamlException) = typedYamlDeserializer.TryDeserializeObject(reader, nestedObjectDeserializer);\r\n\r\n                if (isSuccess)\r\n                {\r\n                    value = o;\r\n                    return true;\r\n                }\r\n\r\n                throw yamlException;\r\n            }\r\n\r\n            value = null;\r\n            return false;\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "741",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "expectedType.IsAssignableFrom(typedYamlDeserializer.Type)",
          "location": {
            "start": {
              "line": 20,
              "column": 21
            },
            "end": {
              "line": 20,
              "column": 79
            }
          },
          "status": "Killed"
        },
        {
          "id": "742",
          "mutatorName": "Negate expression",
          "replacement": "!(!expectedType.IsAssignableFrom(typedYamlDeserializer.Type))",
          "location": {
            "start": {
              "line": 20,
              "column": 21
            },
            "end": {
              "line": 20,
              "column": 79
            }
          },
          "status": "Killed"
        },
        {
          "id": "743",
          "mutatorName": "Negate expression",
          "replacement": "!(isSuccess)",
          "location": {
            "start": {
              "line": 24,
              "column": 21
            },
            "end": {
              "line": 24,
              "column": 30
            }
          },
          "status": "Killed"
        },
        {
          "id": "744",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 27,
              "column": 28
            },
            "end": {
              "line": 27,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "745",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 34,
              "column": 20
            },
            "end": {
              "line": 34,
              "column": 25
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Serialization\\IntegerComponent.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Deserializes a regex group into an integer.\r\n    /// <" + "/summary>\r\n    public class IntegerComponent :  ISerializerBlock,  IStepSerializerComponent\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new IntegerComponent\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"propertyName\"><" + "/param>\r\n        public IntegerComponent(string propertyName) => PropertyName = propertyName;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the property.\r\n        /// <" + "/summary>\r\n        public string PropertyName { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) =>\r\n            data.Dictionary\r\n                .TryFindOrFail(PropertyName, null)\r\n                .Bind(x => x.Join(VariableNameComponent.Serialize,\r\n                    TrySerialize,\r\n                    _ => Result.Failure<" + "string>(\"Cannot serialize list\")\r\n\r\n                ));\r\n\r\n        private static Result<" + "string> TrySerialize(IFreezableStep step)\r\n        {\r\n            if (step is ConstantFreezableStep constantFreezableProcess && constantFreezableProcess.Value is int i)\r\n                return i.ToString();\r\n            if (step is CompoundFreezableStep compound && compound.StepConfiguration == null)\r\n                return compound.StepFactory.Serializer.TrySerialize(compound.FreezableStepData);\r\n\r\n            return Result.Failure<" + "string>(\"Cannot a step with configuration\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "746",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 29,
              "column": 49
            },
            "end": {
              "line": 29,
              "column": 72
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "747",
          "mutatorName": "Logical mutation",
          "replacement": "step is ConstantFreezableStep constantFreezableProcess || constantFreezableProcess.Value is int i",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 114
            }
          },
          "status": "CompileError"
        },
        {
          "id": "748",
          "mutatorName": "Negate expression",
          "replacement": "!(step is ConstantFreezableStep constantFreezableProcess && constantFreezableProcess.Value is int i)",
          "location": {
            "start": {
              "line": 35,
              "column": 17
            },
            "end": {
              "line": 35,
              "column": 114
            }
          },
          "status": "CompileError"
        },
        {
          "id": "749",
          "mutatorName": "Logical mutation",
          "replacement": "step is CompoundFreezableStep compound || compound.StepConfiguration == null",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "750",
          "mutatorName": "Negate expression",
          "replacement": "!(step is CompoundFreezableStep compound && compound.StepConfiguration == null)",
          "location": {
            "start": {
              "line": 37,
              "column": 17
            },
            "end": {
              "line": 37,
              "column": 93
            }
          },
          "status": "CompileError"
        },
        {
          "id": "751",
          "mutatorName": "Equality mutation",
          "replacement": "compound.StepConfiguration != null",
          "location": {
            "start": {
              "line": 37,
              "column": 59
            },
            "end": {
              "line": 37,
              "column": 93
            }
          },
          "status": "Killed"
        },
        {
          "id": "752",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 40,
              "column": 43
            },
            "end": {
              "line": 40,
              "column": 77
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\ISerializerBlock.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Contributes to the serialized string\r\n    /// <" + "/summary>\r\n    public interface ISerializerBlock\r\n    {\r\n        /// <" + "summary>\r\n        /// Gets the segment of serialized text.\r\n        /// <" + "/summary>\r\n        public Result<" + "string> TryGetText(FreezableStepData data);\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Serialization\\IStepSerializer.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// A custom step serializer.\r\n    /// <" + "/summary>\r\n    public interface IStepSerializer\r\n    {\r\n        /// <" + "summary>\r\n        /// Serialize this data as a step of this type.\r\n        /// <" + "/summary>\r\n        Result<" + "string> TrySerialize(FreezableStepData data);\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Serialization\\IStepSerializerComponent.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// A component of a process serializer\r\n    /// <" + "/summary>\r\n    public interface IStepSerializerComponent\r\n    {\r\n        /// <" + "summary>\r\n        /// Contributes to the serialized string\r\n        /// <" + "/summary>\r\n        public ISerializerBlock? SerializerBlock { get; }\r\n\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Serialization\\ITypedYamlDeserializer.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing YamlDotNet.Core;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    internal interface ITypedYamlDeserializer\r\n    {\r\n        Type Type { get; }\r\n\r\n        public Result<" + "object, YamlException> TryDeserializeObject(IParser reader,\r\n            Func<" + "IParser, Type, object?> nestedObjectDeserializer);\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Serialization\\NoSpecialSerializer.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Serializer for processes that should not use short form serialization.\r\n    /// <" + "/summary>\r\n    public sealed class NoSpecialSerializer : IStepSerializer\r\n    {\r\n        private NoSpecialSerializer() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static IStepSerializer Instance { get; } = new NoSpecialSerializer();\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TrySerialize(FreezableStepData data) => Result.Failure<" + "string>(\"This step does not support special serialization\");\r\n    }\r\n}",
      "mutants": [
        {
          "id": "753",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 19,
              "column": 94
            },
            "end": {
              "line": 19,
              "column": 144
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Serialization\\SerializationMethods.cs": {
      "language": "cs",
      "source": "using Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Deserializes text to primitive types.\r\n    /// <" + "/summary>\r\n    public static class SerializationMethods\r\n    {\r\n        /// <" + "summary>\r\n        /// Serialize a constant freezable step.\r\n        /// <" + "/summary>\r\n        public static string SerializeConstant(ConstantFreezableStep cfp, bool quoteString)\r\n        {\r\n            if (cfp.Value.GetType().IsEnum)\r\n                return cfp.Value.GetType().Name + \".\" + cfp.Value;\r\n            if (cfp.Value is string s)\r\n                return quoteString? $\"'{s}'\" : s;\r\n            return cfp.Value.ToString() ?? \"\";\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "754",
          "mutatorName": "Negate expression",
          "replacement": "!(cfp.Value.GetType().IsEnum)",
          "location": {
            "start": {
              "line": 15,
              "column": 17
            },
            "end": {
              "line": 15,
              "column": 43
            }
          },
          "status": "Killed"
        },
        {
          "id": "755",
          "mutatorName": "Arithmetic mutation",
          "replacement": "cfp.Value.GetType().Name + \".\" - cfp.Value",
          "location": {
            "start": {
              "line": 16,
              "column": 24
            },
            "end": {
              "line": 16,
              "column": 66
            }
          },
          "status": "CompileError"
        },
        {
          "id": "756",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 16,
              "column": 51
            },
            "end": {
              "line": 16,
              "column": 54
            }
          },
          "status": "Killed"
        },
        {
          "id": "757",
          "mutatorName": "Negate expression",
          "replacement": "!(quoteString)",
          "location": {
            "start": {
              "line": 18,
              "column": 24
            },
            "end": {
              "line": 18,
              "column": 35
            }
          },
          "status": "Killed"
        },
        {
          "id": "758",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 18,
              "column": 37
            },
            "end": {
              "line": 18,
              "column": 45
            }
          },
          "status": "Killed"
        },
        {
          "id": "759",
          "mutatorName": "String mutation",
          "replacement": "\"Stryker was here!\"",
          "location": {
            "start": {
              "line": 19,
              "column": 44
            },
            "end": {
              "line": 19,
              "column": 46
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\SpaceComponent.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Include a required space in serialization.\r\n    /// <" + "/summary>\r\n    public class SpaceComponent : IStepSerializerComponent, ISerializerBlock//, IDeserializerBlock\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new Space Component.\r\n        /// <" + "/summary>\r\n        public SpaceComponent()\r\n        {\r\n\r\n        }\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) => \" \";\r\n    }\r\n}",
      "mutants": [
        {
          "id": "760",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 24,
              "column": 69
            },
            "end": {
              "line": 24,
              "column": 72
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Serialization\\StepMemberDeserializer.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\nusing YamlDotNet.Core;\r\nusing YamlDotNet.Core.Events;\r\nusing Version = System.Version;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n\r\n    internal class StepMemberDeserializer : TypedYamlDeserializer<" + "StepMember>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new StepMemberDeserializer\r\n        /// <" + "/summary>\r\n        public StepMemberDeserializer(StepMemberParser stepMemberParser) => StepMemberParser = stepMemberParser;\r\n\r\n        /// <" + "summary>\r\n        /// The step member parser\r\n        /// <" + "/summary>\r\n        public StepMemberParser StepMemberParser { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override Result<" + "StepMember, YamlException> TryDeserialize(IParser reader, Func<" + "IParser, Type, object?> nestedObjectDeserializer)\r\n        {\r\n            if(reader.Current == null)\r\n                return new YamlException(\"Reader is empty\");\r\n\r\n            var startMark = reader.Current.Start;\r\n            var endMark = reader.Current.End;\r\n\r\n\r\n            switch (reader.Current)\r\n            {\r\n                case MappingStart _:\r\n                {\r\n                    var r =\r\n                        TryDeserializeNested<" + "IFreezableStep>(nestedObjectDeserializer, reader)\r\n                            .Map(x=> new StepMember(x));\r\n\r\n                    return r;\r\n\r\n                }\r\n                case SequenceStart _:\r\n                {\r\n                    var r =\r\n                        TryDeserializeNested<" + "List<" + "StepMember>>(nestedObjectDeserializer, reader)\r\n                            .Bind(x=>\r\n                                x.Select(m=>ResultExtensions.Bind<" + "StepMember, IFreezableStep>(m.TryConvert(MemberType.Step), n=>n.AsArgument(\"Step\")))\r\n                                    .Combine()\r\n                                    .MapFailure(e=> new YamlException(startMark, endMark, e)))\r\n                            .Map(x=> new StepMember(x.ToList()));\r\n\r\n                    return r;\r\n                }\r\n                case Scalar scalar:\r\n                {\r\n\r\n                    if (scalar.IsQuotedImplicit)\r\n                    {\r\n                        var member = new StepMember(new ConstantFreezableStep(scalar.Value));\r\n                        reader.MoveNext();\r\n                        return member;\r\n                    }\r\n                    //otherwise try to deserialize this a as step member\r\n\r\n                    var r = StepMemberParser.TryParse(scalar.Value)\r\n                        .MapFailure(e=> new YamlException(reader.Current.Start, reader.Current.End, e));\r\n\r\n                    if (r.IsSuccess)\r\n                    {\r\n                        reader.MoveNext();\r\n                        return r;\r\n                    }\r\n\r\n                    //TODO remove this bit\r\n                    var member2 = new StepMember(new ConstantFreezableStep(scalar.Value));\r\n                    reader.MoveNext();\r\n                    return member2;\r\n                }\r\n                default: return new YamlException(reader.Current.Start, reader.Current.End, $\"Cannot deserialize {reader.Current}\");\r\n            }\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "761",
          "mutatorName": "Equality mutation",
          "replacement": "reader.Current != null",
          "location": {
            "start": {
              "line": 29,
              "column": 16
            },
            "end": {
              "line": 29,
              "column": 38
            }
          },
          "status": "Killed"
        },
        {
          "id": "762",
          "mutatorName": "Negate expression",
          "replacement": "!(reader.Current == null)",
          "location": {
            "start": {
              "line": 29,
              "column": 16
            },
            "end": {
              "line": 29,
              "column": 38
            }
          },
          "status": "Killed"
        },
        {
          "id": "763",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 30,
              "column": 42
            },
            "end": {
              "line": 30,
              "column": 59
            }
          },
          "status": "Ignored"
        },
        {
          "id": "764",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 52,
              "column": 142
            },
            "end": {
              "line": 52,
              "column": 148
            }
          },
          "status": "Survived"
        },
        {
          "id": "765",
          "mutatorName": "Negate expression",
          "replacement": "!(scalar.IsQuotedImplicit)",
          "location": {
            "start": {
              "line": 62,
              "column": 25
            },
            "end": {
              "line": 62,
              "column": 48
            }
          },
          "status": "Killed"
        },
        {
          "id": "766",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsSuccess)",
          "location": {
            "start": {
              "line": 73,
              "column": 25
            },
            "end": {
              "line": 73,
              "column": 36
            }
          },
          "status": "Killed"
        },
        {
          "id": "767",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 84,
              "column": 93
            },
            "end": {
              "line": 84,
              "column": 131
            }
          },
          "status": "Ignored"
        }
      ]
    },
    "Core\\Serialization\\StepMemberParser.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing Reductech.EDR.Core.General;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\nusing Superpower;\r\nusing Superpower.Display;\r\nusing Superpower.Model;\r\nusing Superpower.Parsers;\r\nusing Superpower.Tokenizers;\r\nusing Result = CSharpFunctionalExtensions.Result;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Parses strings as step members\r\n    /// <" + "/summary>\r\n    public class StepMemberParser\r\n    {\r\n        private enum ProcessToken\r\n        {\r\n            /// <" + "summary>\r\n            /// Sentinel Value.\r\n            /// <" + "/summary>\r\n            // ReSharper disable once UnusedMember.Local\r\n            None,\r\n            [Token(Example = \"<" + "Path>\")]\r\n            VariableName,\r\n            [Token(Example = \"(\")]\r\n            OpenBracket,\r\n            [Token(Example = \")\")]\r\n            CloseBracket,\r\n            [Token(Example = \"[\")]\r\n            OpenArray,\r\n            [Token(Example = \"]\")]\r\n            CloseArray,\r\n            [Token(Example = \",\", Description = \"Delimiter for arrays and function calls\")]\r\n            Delimiter,\r\n            //[Token(Example = \":\", Description = \"Separates an argument name and an argument value\")]\r\n            //ArgumentSeparator,\r\n            [Token(Example = \"=\")]\r\n            Assignment,\r\n            [Token(Example = \"+\")]\r\n            MathOperator,\r\n            [Token(Example = \"&&\")]\r\n            BooleanOperator,\r\n            [Token(Example = \"==\")]\r\n            Comparator,\r\n            [Token(Example = \"'Hello World'\")]\r\n            StringLiteral,\r\n            [Token(Example = \"123\")]\r\n            Number,\r\n            [Token(Example = \"true\")]\r\n            Boolean,\r\n            [Token(Example = \"MathOperator.And\")]\r\n            Enum,\r\n            [Token(Example = \"WriteFile\")]\r\n            FuncOrArgumentName,\r\n            [Token(Example = \"Not\")]\r\n            NotOperator\r\n        }\r\n\r\n\r\n        private static readonly Tokenizer<" + "ProcessToken> Tokenizer = new TokenizerBuilder<" + "ProcessToken>()\r\n            .Ignore(Span.WhiteSpace)\r\n\r\n\r\n            .Match(Character.EqualTo('('), ProcessToken.OpenBracket)\r\n            .Match(Character.EqualTo(')'), ProcessToken.CloseBracket)\r\n            .Match(Character.EqualTo('['), ProcessToken.OpenArray)\r\n            .Match(Character.EqualTo(']'), ProcessToken.CloseArray)\r\n            .Match(Character.EqualTo(','), ProcessToken.Delimiter)\r\n\r\n            //VariableName must be before comparator\r\n            .Match(Span.Regex(\"<" + "[a-z0-9-_]+>\", RegexOptions.Compiled | RegexOptions.IgnoreCase), ProcessToken.VariableName)\r\n\r\n            .Match(GetSpan(MathOperator.None), ProcessToken.MathOperator, true)\r\n            .Match(GetSpan(BooleanOperator.None), ProcessToken.BooleanOperator, true)\r\n            .Match(GetSpan(CompareOperator.None), ProcessToken.Comparator, true)\r\n\r\n\r\n            .Match(Character.EqualTo('='), ProcessToken.Assignment)\r\n            .Match(QuotedString.SqlStyle, ProcessToken.StringLiteral)\r\n            .Match(QuotedString.CStyle, ProcessToken.StringLiteral)\r\n\r\n            .Match(Span.EqualToIgnoreCase(\"true\").Or(Span.EqualToIgnoreCase(\"false\")), ProcessToken.Boolean, true)\r\n            .Match(Span.EqualToIgnoreCase(\"not\"), ProcessToken.NotOperator, true)\r\n            .Match(Span.Regex(@\"[0-9]+\", RegexOptions.Compiled), ProcessToken.Number)\r\n            .Match(Span.Regex(@\"[a-z0-9-_]+\\.[a-z0-9-_]+\", RegexOptions.Compiled | RegexOptions.IgnoreCase), ProcessToken.Enum, true)\r\n\r\n            .Match(Span.Regex(\"[a-z0-9-_]+\", RegexOptions.Compiled | RegexOptions.IgnoreCase), ProcessToken.FuncOrArgumentName, true)\r\n            .Build(); //TODO add wildcard\r\n\r\n\r\n\r\n        private TokenListParser<" + "ProcessToken, StepMember> Parser { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Tries to parse a string as a step member.\r\n        /// <" + "/summary>\r\n        public CSharpFunctionalExtensions. Result<" + "StepMember> TryParse(string s)\r\n        {\r\n            var tokensResult = Tokenizer.TryTokenize(s);\r\n\r\n            if (!tokensResult.HasValue)\r\n                return Result.Failure<" + "StepMember>(tokensResult.FormatErrorMessageFragment());\r\n\r\n            if (!tokensResult.Remainder.IsAtEnd)\r\n                return Result.Failure<" + "StepMember>(tokensResult.FormatErrorMessageFragment());\r\n\r\n            var parseResult = Parser.TryParse(tokensResult.Value);\r\n\r\n            if(!parseResult.HasValue)\r\n                return Result.Failure<" + "StepMember>(parseResult.FormatErrorMessageFragment());\r\n\r\n            if(!parseResult.Remainder.IsAtEnd)\r\n                return Result.Failure<" + "StepMember>(parseResult.FormatErrorMessageFragment());\r\n\r\n            return parseResult.Value;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The step factory store\r\n        /// <" + "/summary>\r\n        public StepFactoryStore StepFactoryStore { get; }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Create a new StepMemberParser\r\n        /// <" + "/summary>\r\n        [SuppressMessage(\"ReSharper\", \"AccessToModifiedClosure\")]\r\n        public StepMemberParser(StepFactoryStore stepFactoryStore)\r\n        {\r\n            StepFactoryStore = stepFactoryStore;\r\n\r\n            Lazy<" + "TokenListParser<" + "ProcessToken, StepMember>> stepMember = null!;\r\n            Lazy<" + "TokenListParser<" + "ProcessToken, IFreezableStep>> freezableProcess = null!;\r\n\r\n            TokenListParser<" + "ProcessToken, IFreezableStep> enumConstant = CreateEnumParser(StepFactoryStore);\r\n\r\n            Lazy<" + "TokenListParser<" + "ProcessToken, IFreezableStep>> singleTerm = null!;\r\n\r\n            TokenListParser<" + "ProcessToken, IFreezableStep> setVariable =\r\n                (from vnToken in Token.EqualTo(ProcessToken.VariableName)\r\n                 from _ in Token.EqualTo(ProcessToken.Assignment)\r\n                 from value in Parse.Ref(() => freezableProcess.Value)\r\n                 select SetVariableStepFactory.CreateFreezable(\r\n                         new VariableName(vnToken.ToStringValue().TrimStart('<" + "').TrimEnd('>')),\r\n                         value)).Try();\r\n\r\n            TokenListParser<" + "ProcessToken, StepMember> array =\r\n\r\n                (from _1 in Token.EqualTo(ProcessToken.OpenArray)\r\n                    from _2 in Token.EqualTo(ProcessToken.CloseArray)\r\n                    select new StepMember(new List<" + "IFreezableStep>())\r\n                    ).Try()\r\n                .Or\r\n                (from _1 in Token.EqualTo(ProcessToken.OpenArray)\r\n                from elements in Parse.Chain(Token.EqualTo(ProcessToken.Delimiter),\r\n                    Parse.Ref(() => freezableProcess.Value).Select(x => new[]{x} as IEnumerable<" + "IFreezableStep>),\r\n                    (_2,a,b)=> a.Concat(b))\r\n                from _3 in Token.EqualTo(ProcessToken.CloseArray)\r\n                select new StepMember(elements.ToList()));\r\n\r\n\r\n            TokenListParser<" + "ProcessToken, IFreezableStep> notOperation =\r\n\r\n                (from o in Token.EqualTo(ProcessToken.NotOperator)\r\n                    from _1 in Token.EqualTo(ProcessToken.OpenBracket)\r\n                    from f1 in Parse.Ref(()=> singleTerm.Value)\r\n                    from _2 in Token.EqualTo(ProcessToken.CloseBracket)\r\n                    select new CompoundFreezableStep(NotStepFactory.Instance,\r\n                        new FreezableStepData(new Dictionary<" + "string, StepMember>\r\n                        {\r\n                            {nameof(Not.Boolean), new StepMember(f1)}\r\n                        }), null) as IFreezableStep).Try();\r\n\r\n            TokenListParser<" + "ProcessToken, IFreezableStep> mathOperation =\r\n\r\n                (from f1 in Parse.Ref(()=> singleTerm.Value)\r\n                 from o in Token.EqualTo(ProcessToken.MathOperator)\r\n                 from f2 in Parse.Ref(()=> singleTerm.Value)\r\n                 select new CompoundFreezableStep(ApplyMathOperatorStepFactory.Instance,\r\n                     new FreezableStepData(new Dictionary<" + "string, StepMember>()\r\n                     {\r\n                        {nameof(ApplyMathOperator.Left), new StepMember(f1)},\r\n                        {nameof(ApplyMathOperator.Operator),\r\n                            new StepMember(new ConstantFreezableStep(Extensions.TryParseValue<" + "MathOperator>(o.ToStringValue()).Value))}\r\n                        ,\r\n                        {nameof(ApplyMathOperator.Right), new StepMember(f2)}\r\n                     }), null) as IFreezableStep).Try();\r\n\r\n\r\n            TokenListParser<" + "ProcessToken, IFreezableStep> booleanOperation =\r\n                (from f1 in Parse.Ref(()=> singleTerm.Value)\r\n                 from o in Token.EqualTo(ProcessToken.BooleanOperator)\r\n                 from f2 in Parse.Ref(()=> singleTerm.Value)\r\n                 select new CompoundFreezableStep(ApplyBooleanStepFactory.Instance,\r\n                     new FreezableStepData(new Dictionary<" + "string, StepMember>\r\n                     {\r\n                        {nameof(ApplyBooleanOperator.Left), new StepMember(f1)},\r\n                        {nameof(ApplyBooleanOperator.Operator),\r\n                            new StepMember(new ConstantFreezableStep(Extensions.TryParseValue<" + "BooleanOperator>(o.ToStringValue()).Value))}\r\n                        ,\r\n                        {nameof(ApplyBooleanOperator.Right), new StepMember(f2)}\r\n                     }), null) as IFreezableStep).Try();\r\n\r\n            TokenListParser<" + "ProcessToken, IFreezableStep> compareOperation =\r\n                (from f1 in Parse.Ref(()=> singleTerm.Value)\r\n                 from o in Token.EqualTo(ProcessToken.Comparator)\r\n                 from f2 in Parse.Ref(()=> singleTerm.Value)\r\n                 select new CompoundFreezableStep(CompareStepFactory.Instance,\r\n                     new FreezableStepData(new Dictionary<" + "string, StepMember>()\r\n                     {\r\n                        {nameof(Compare<" + "int>.Left), new StepMember(f1)},\r\n                        {nameof(Compare<" + "int>.Operator),\r\n                            new StepMember(new ConstantFreezableStep(Extensions.TryParseValue<" + "CompareOperator>(o.ToStringValue()).Value))}\r\n                        ,\r\n                        {nameof(Compare<" + "int>.Right), new StepMember(f2)}\r\n                     }), null) as IFreezableStep).Try();\r\n\r\n            TokenListParser<" + "ProcessToken, (string argumentName, StepMember stepMember)> functionMember =\r\n                (from a in Token.EqualTo(ProcessToken.FuncOrArgumentName)\r\n                 from _ in Token.EqualTo(ProcessToken.Assignment)\r\n                 from pm in Parse.Ref(() => stepMember.Value)\r\n                 select (a.ToStringValue(), pm)).Try();\r\n\r\n            Lazy<" + "TokenListParser<" + "ProcessToken, IFreezableStep>> function =\r\n                new Lazy<" + "TokenListParser<" + "ProcessToken, IFreezableStep>>(()=>\r\n                    (from x in\r\n                    (from fName in Token.EqualTo(ProcessToken.FuncOrArgumentName)\r\n                     from _1 in Token.EqualTo(ProcessToken.OpenBracket)\r\n                     from args in functionMember\r\n                         .ManyDelimitedBy(Token.EqualTo(ProcessToken.Delimiter),\r\n                      Token.EqualTo(ProcessToken.CloseBracket))\r\n\r\n                     select TryCreateProcess(fName.ToStringValue(), StepFactoryStore, args))\r\n                     where x.IsSuccess\r\n                     select x.Value).Try()\r\n                    );\r\n\r\n            var operation = mathOperation.Or(booleanOperation).Or(compareOperation);\r\n\r\n            var bracketedOperation =\r\n                from _1 in Token.EqualTo(ProcessToken.OpenBracket)\r\n                from o in operation\r\n                from _2 in Token.EqualTo(ProcessToken.CloseBracket)\r\n                select o;\r\n\r\n\r\n            singleTerm = new Lazy<" + "TokenListParser<" + "ProcessToken, IFreezableStep>>(()=>\r\n                NumberParser\r\n                .Or(BoolParser)\r\n                .Or(enumConstant)\r\n                .Or(StringConstantParser)\r\n                .Or(GetVariableParser)\r\n                .Or(notOperation)\r\n                .Or(function.Value)\r\n                .Or(bracketedOperation)\r\n                );\r\n\r\n\r\n            freezableProcess = new Lazy<" + "TokenListParser<" + "ProcessToken, IFreezableStep>>(()=>\r\n                    operation\r\n                    .Or(setVariable)\r\n                    .Or(singleTerm.Value) //Must come after setVariable\r\n                    );\r\n\r\n            stepMember = new Lazy<" + "TokenListParser<" + "ProcessToken, StepMember>>(()=>\r\n\r\n                     operation\r\n                    .Or(bracketedOperation)\r\n                    .Or(notOperation)\r\n                    .Or(NumberParser)\r\n                    .Or(BoolParser)\r\n                    .Or(enumConstant)\r\n                    .Or(StringConstantParser)\r\n                    .Or(setVariable)\r\n                    //note: no getVariable here\r\n                    .Or(Parse.Ref(() => function.Value))\r\n                    .Select(x=> new StepMember(x))\r\n                    .Or(VariableNameParser.Select(x=> new StepMember(x)))\r\n                    .Or(array)\r\n                );\r\n\r\n\r\n            Parser = stepMember.Value;\r\n        }\r\n\r\n\r\n        private static CSharpFunctionalExtensions.Result<" + "IFreezableStep> TryCreateProcess(string funcName, StepFactoryStore factoryStore, (string argumentName, StepMember stepMember)[] functionArguments)\r\n        {\r\n            if (!factoryStore.Dictionary.TryGetValue(funcName, out var runnableStepFactory))\r\n                return Result.Failure<" + "IFreezableStep>($\"Could not find step '{funcName}'\");\r\n\r\n\r\n            var dictionary = new Dictionary<" + "string, StepMember>();\r\n\r\n            foreach (var (argumentName, stepMember) in functionArguments)\r\n            {\r\n                var memberType = runnableStepFactory.GetExpectedMemberType(argumentName);\r\n\r\n                var convertResult = stepMember.TryConvert(memberType);\r\n\r\n                if (convertResult.IsFailure)\r\n                    return convertResult.ConvertFailure<" + "IFreezableStep>();\r\n\r\n                dictionary.Add(argumentName, convertResult.Value);\r\n            }\r\n\r\n            var process = new CompoundFreezableStep(runnableStepFactory,\r\n                new FreezableStepData(dictionary), null);\r\n\r\n\r\n            return process;\r\n        }\r\n\r\n\r\n        private static readonly TokenListParser<" + "ProcessToken, VariableName> VariableNameParser =\r\n            from token in Token.EqualTo(ProcessToken.VariableName)\r\n            select new VariableName(token.ToStringValue().TrimStart('<" + "').TrimEnd('>'));\r\n\r\n        private static readonly TokenListParser<" + "ProcessToken, IFreezableStep> GetVariableParser =\r\n            from variableName in VariableNameParser\r\n            select GetVariableStepFactory.CreateFreezable(variableName);\r\n\r\n        private static readonly TokenListParser<" + "ProcessToken, IFreezableStep> StringConstantParser =\r\n            from token in Token.EqualTo(ProcessToken.StringLiteral)\r\n            select new ConstantFreezableStep(token.ToStringValue()[1..^1] ) as IFreezableStep;\r\n\r\n        private static readonly TokenListParser<" + "ProcessToken, IFreezableStep> NumberParser =\r\n            from token in Token.EqualTo(ProcessToken.Number)\r\n            select new ConstantFreezableStep(int.Parse(token.ToStringValue())) as IFreezableStep;\r\n\r\n        private static readonly TokenListParser<" + "ProcessToken, IFreezableStep> BoolParser =\r\n            from token in Token.EqualTo(ProcessToken.Boolean)\r\n            select new ConstantFreezableStep(bool.Parse(token.ToStringValue())) as IFreezableStep;\r\n\r\n\r\n        private static readonly Regex EnumRegex =\r\n            new Regex(@\"\\A(?<" + "enum>[a-z0-9-_]+)\\.(?<" + "value>[a-z0-9-_]+)\\Z\",\r\n                RegexOptions.IgnoreCase | RegexOptions.Compiled);\r\n\r\n\r\n        private static TokenListParser<" + "ProcessToken, IFreezableStep> CreateEnumParser(StepFactoryStore stepFactoryStore)\r\n        {\r\n            return\r\n                Token.EqualTo(ProcessToken.Enum)\r\n                    .Select(token => EnumRegex.Match(token.ToStringValue()))\r\n                    .Where(x => x.Success)\r\n                    .Select(x => TryGetEnumValue(x.Groups[\"enum\"].Value, x.Groups[\"value\"].Value, stepFactoryStore))\r\n                    .Where(x => x.IsSuccess)\r\n                    .Select(x => x.Value);\r\n        }\r\n\r\n\r\n        private static CSharpFunctionalExtensions.Result<" + "IFreezableStep> TryGetEnumValue(string enumName, string value,\r\n            StepFactoryStore stepFactoryStore)\r\n        {\r\n            if (stepFactoryStore.EnumTypesDictionary.TryGetValue(enumName, out var type))\r\n                if (Enum.TryParse(type, value, true, out var enumValue))\r\n                    return new ConstantFreezableStep(enumValue!);\r\n            return Result.Failure<" + "IFreezableStep>(\"Could not parse enum\");\r\n        }\r\n\r\n        private static TextParser<" + "TextSpan> GetSpan<" + "T>(params T[] excludedValues) where T : Enum =>\r\n            Extensions.GetEnumValues<" + "T>()\r\n                .Except(excludedValues)\r\n                .SelectMany(x => new []{x.ToString(), x.GetDisplayName()})\r\n                .OrderByDescending(x=>x.Length)\r\n                .Select(x=> Span.EqualToIgnoreCase(x).Try())\r\n                .Aggregate((a, b) => a.Or(b));\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "768",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 78,
              "column": 31
            },
            "end": {
              "line": 78,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "769",
          "mutatorName": "Bitwise mutation",
          "replacement": "RegexOptions.Compiled & RegexOptions.IgnoreCase",
          "location": {
            "start": {
              "line": 78,
              "column": 48
            },
            "end": {
              "line": 78,
              "column": 95
            }
          },
          "status": "Killed"
        },
        {
          "id": "770",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 80,
              "column": 75
            },
            "end": {
              "line": 80,
              "column": 79
            }
          },
          "status": "Survived"
        },
        {
          "id": "771",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 81,
              "column": 81
            },
            "end": {
              "line": 81,
              "column": 85
            }
          },
          "status": "Killed"
        },
        {
          "id": "772",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 82,
              "column": 76
            },
            "end": {
              "line": 82,
              "column": 80
            }
          },
          "status": "Survived"
        },
        {
          "id": "773",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 89,
              "column": 43
            },
            "end": {
              "line": 89,
              "column": 49
            }
          },
          "status": "Killed"
        },
        {
          "id": "774",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 89,
              "column": 77
            },
            "end": {
              "line": 89,
              "column": 84
            }
          },
          "status": "Killed"
        },
        {
          "id": "775",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 89,
              "column": 110
            },
            "end": {
              "line": 89,
              "column": 114
            }
          },
          "status": "Survived"
        },
        {
          "id": "776",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 90,
              "column": 43
            },
            "end": {
              "line": 90,
              "column": 48
            }
          },
          "status": "Killed"
        },
        {
          "id": "777",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 90,
              "column": 77
            },
            "end": {
              "line": 90,
              "column": 81
            }
          },
          "status": "Survived"
        },
        {
          "id": "778",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 91,
              "column": 31
            },
            "end": {
              "line": 91,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "779",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 92,
              "column": 31
            },
            "end": {
              "line": 92,
              "column": 58
            }
          },
          "status": "Killed"
        },
        {
          "id": "780",
          "mutatorName": "Bitwise mutation",
          "replacement": "RegexOptions.Compiled & RegexOptions.IgnoreCase",
          "location": {
            "start": {
              "line": 92,
              "column": 60
            },
            "end": {
              "line": 92,
              "column": 107
            }
          },
          "status": "Killed"
        },
        {
          "id": "781",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 92,
              "column": 129
            },
            "end": {
              "line": 92,
              "column": 133
            }
          },
          "status": "Survived"
        },
        {
          "id": "782",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 94,
              "column": 31
            },
            "end": {
              "line": 94,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "783",
          "mutatorName": "Bitwise mutation",
          "replacement": "RegexOptions.Compiled & RegexOptions.IgnoreCase",
          "location": {
            "start": {
              "line": 94,
              "column": 46
            },
            "end": {
              "line": 94,
              "column": 93
            }
          },
          "status": "Killed"
        },
        {
          "id": "784",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 94,
              "column": 129
            },
            "end": {
              "line": 94,
              "column": 133
            }
          },
          "status": "Killed"
        },
        {
          "id": "785",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "tokensResult.HasValue",
          "location": {
            "start": {
              "line": 108,
              "column": 17
            },
            "end": {
              "line": 108,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "786",
          "mutatorName": "Negate expression",
          "replacement": "!(!tokensResult.HasValue)",
          "location": {
            "start": {
              "line": 108,
              "column": 17
            },
            "end": {
              "line": 108,
              "column": 39
            }
          },
          "status": "Killed"
        },
        {
          "id": "787",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "tokensResult.Remainder.IsAtEnd",
          "location": {
            "start": {
              "line": 111,
              "column": 17
            },
            "end": {
              "line": 111,
              "column": 48
            }
          },
          "status": "Killed"
        },
        {
          "id": "788",
          "mutatorName": "Negate expression",
          "replacement": "!(!tokensResult.Remainder.IsAtEnd)",
          "location": {
            "start": {
              "line": 111,
              "column": 17
            },
            "end": {
              "line": 111,
              "column": 48
            }
          },
          "status": "Killed"
        },
        {
          "id": "789",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "parseResult.HasValue",
          "location": {
            "start": {
              "line": 116,
              "column": 16
            },
            "end": {
              "line": 116,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "790",
          "mutatorName": "Negate expression",
          "replacement": "!(!parseResult.HasValue)",
          "location": {
            "start": {
              "line": 116,
              "column": 16
            },
            "end": {
              "line": 116,
              "column": 37
            }
          },
          "status": "Killed"
        },
        {
          "id": "791",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "parseResult.Remainder.IsAtEnd",
          "location": {
            "start": {
              "line": 119,
              "column": 16
            },
            "end": {
              "line": 119,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "792",
          "mutatorName": "Negate expression",
          "replacement": "!(!parseResult.Remainder.IsAtEnd)",
          "location": {
            "start": {
              "line": 119,
              "column": 16
            },
            "end": {
              "line": 119,
              "column": 46
            }
          },
          "status": "Killed"
        },
        {
          "id": "793",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>\r\n{}",
          "location": {
            "start": {
              "line": 176,
              "column": 47
            },
            "end": {
              "line": 179,
              "column": 26
            }
          },
          "status": "Killed"
        },
        {
          "id": "794",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>()\r\n{}",
          "location": {
            "start": {
              "line": 187,
              "column": 44
            },
            "end": {
              "line": 194,
              "column": 23
            }
          },
          "status": "Killed"
        },
        {
          "id": "795",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>\r\n{}",
          "location": {
            "start": {
              "line": 202,
              "column": 44
            },
            "end": {
              "line": 209,
              "column": 23
            }
          },
          "status": "Killed"
        },
        {
          "id": "796",
          "mutatorName": "Collection initializer mutation",
          "replacement": "new Dictionary<" + "string, StepMember>()\r\n{}",
          "location": {
            "start": {
              "line": 216,
              "column": 44
            },
            "end": {
              "line": 223,
              "column": 23
            }
          },
          "status": "Killed"
        },
        {
          "id": "797",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "factoryStore.Dictionary.TryGetValue(funcName, out var runnableStepFactory)",
          "location": {
            "start": {
              "line": 296,
              "column": 17
            },
            "end": {
              "line": 296,
              "column": 92
            }
          },
          "status": "Killed"
        },
        {
          "id": "798",
          "mutatorName": "Negate expression",
          "replacement": "!(!factoryStore.Dictionary.TryGetValue(funcName, out var runnableStepFactory))",
          "location": {
            "start": {
              "line": 296,
              "column": 17
            },
            "end": {
              "line": 296,
              "column": 92
            }
          },
          "status": "Killed"
        },
        {
          "id": "799",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 297,
              "column": 55
            },
            "end": {
              "line": 297,
              "column": 90
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "800",
          "mutatorName": "Negate expression",
          "replacement": "!(convertResult.IsFailure)",
          "location": {
            "start": {
              "line": 308,
              "column": 21
            },
            "end": {
              "line": 308,
              "column": 44
            }
          },
          "status": "Killed"
        },
        {
          "id": "801",
          "mutatorName": "Regex anchor removal mutation",
          "replacement": "\"(?<" + "enum>[a-z0-9-_]+)\\\\.(?<" + "value>[a-z0-9-_]+)\\\\Z\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Survived",
          "description": "Anchor \"\\A\" was removed at offset 0."
        },
        {
          "id": "802",
          "mutatorName": "Regex character class negation mutation",
          "replacement": "\"\\\\A(?<" + "enum>[^a-z0-9-_]+)\\\\.(?<" + "value>[a-z0-9-_]+)\\\\Z\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Killed",
          "description": "Character class \"[a-z0-9-_]\" was replaced with \"[^a-z0-9-_]\" at offset 10."
        },
        {
          "id": "803",
          "mutatorName": "Regex quantifier removal mutation",
          "replacement": "\"\\\\A(?<" + "enum>[a-z0-9-_])\\\\.(?<" + "value>[a-z0-9-_]+)\\\\Z\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Killed",
          "description": "Quantifier \"+\" was removed at offset 20."
        },
        {
          "id": "804",
          "mutatorName": "Regex character class negation mutation",
          "replacement": "\"\\\\A(?<" + "enum>[a-z0-9-_]+)\\\\.(?<" + "value>[^a-z0-9-_]+)\\\\Z\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Killed",
          "description": "Character class \"[a-z0-9-_]\" was replaced with \"[^a-z0-9-_]\" at offset 33."
        },
        {
          "id": "805",
          "mutatorName": "Regex quantifier removal mutation",
          "replacement": "\"\\\\A(?<" + "enum>[a-z0-9-_]+)\\\\.(?<" + "value>[a-z0-9-_])\\\\Z\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Killed",
          "description": "Quantifier \"+\" was removed at offset 43."
        },
        {
          "id": "806",
          "mutatorName": "Regex anchor removal mutation",
          "replacement": "\"\\\\A(?<" + "enum>[a-z0-9-_]+)\\\\.(?<" + "value>[a-z0-9-_]+)\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Survived",
          "description": "Anchor \"\\Z\" was removed at offset 45."
        },
        {
          "id": "807",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 344,
              "column": 23
            },
            "end": {
              "line": 344,
              "column": 73
            }
          },
          "status": "Killed"
        },
        {
          "id": "808",
          "mutatorName": "Bitwise mutation",
          "replacement": "                RegexOptions.IgnoreCase & RegexOptions.Compiled",
          "location": {
            "start": {
              "line": 345,
              "column": 17
            },
            "end": {
              "line": 345,
              "column": 64
            }
          },
          "status": "Killed"
        },
        {
          "id": "809",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 354,
              "column": 59
            },
            "end": {
              "line": 354,
              "column": 65
            }
          },
          "status": "Killed"
        },
        {
          "id": "810",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 354,
              "column": 83
            },
            "end": {
              "line": 354,
              "column": 90
            }
          },
          "status": "Killed"
        },
        {
          "id": "811",
          "mutatorName": "Negate expression",
          "replacement": "!(stepFactoryStore.EnumTypesDictionary.TryGetValue(enumName, out var type))",
          "location": {
            "start": {
              "line": 363,
              "column": 17
            },
            "end": {
              "line": 363,
              "column": 89
            }
          },
          "status": "Killed"
        },
        {
          "id": "812",
          "mutatorName": "Negate expression",
          "replacement": "!(Enum.TryParse(type, value, true, out var enumValue))",
          "location": {
            "start": {
              "line": 364,
              "column": 21
            },
            "end": {
              "line": 364,
              "column": 72
            }
          },
          "status": "Killed"
        },
        {
          "id": "813",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 364,
              "column": 48
            },
            "end": {
              "line": 364,
              "column": 52
            }
          },
          "status": "Survived"
        },
        {
          "id": "814",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 366,
              "column": 51
            },
            "end": {
              "line": 366,
              "column": 73
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "815",
          "mutatorName": "Linq method mutation (OrderByDescending() to OrderBy())",
          "replacement": "            Extensions.GetEnumValues<" + "T>()\r\n                .Except(excludedValues)\r\n                .SelectMany(x => new []{x.ToString(), x.GetDisplayName()})\r\n                .OrderBy(x=>x.Length)\r\n                .Select(x=> Span.EqualToIgnoreCase(x).Try())\r\n                .Aggregate((a, b) => a.Or(b))",
          "location": {
            "start": {
              "line": 370,
              "column": 13
            },
            "end": {
              "line": 375,
              "column": 46
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Serialization\\StepSerializer.cs": {
      "language": "cs",
      "source": "using System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// A custom step serializer.\r\n    /// <" + "/summary>\r\n    public class StepSerializer : IStepSerializer\r\n    {\r\n        /// <" + "summary>\r\n        /// Create a new StepSerializer\r\n        /// <" + "/summary>\r\n        public StepSerializer(params IStepSerializerComponent[] components) => Components = components;\r\n\r\n        /// <" + "summary>\r\n        /// The component to use.\r\n        /// <" + "/summary>\r\n        public IReadOnlyCollection<" + "IStepSerializerComponent> Components { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TrySerialize(FreezableStepData data)\r\n        {\r\n            StringBuilder sb = new StringBuilder();\r\n\r\n            foreach (var serializerBlock in Components.Select(x => x.SerializerBlock).WhereNotNull())\r\n            {\r\n                var r = serializerBlock.TryGetText(data);\r\n                if (r.IsFailure)\r\n                    return r;\r\n                sb.Append(r.Value);\r\n            }\r\n\r\n            if (sb.Length == 0)\r\n                return Result.Failure<" + "string>(\"Serialized string was empty\");\r\n\r\n            return sb.ToString();\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "816",
          "mutatorName": "Negate expression",
          "replacement": "!(r.IsFailure)",
          "location": {
            "start": {
              "line": 33,
              "column": 21
            },
            "end": {
              "line": 33,
              "column": 32
            }
          },
          "status": "Killed"
        },
        {
          "id": "817",
          "mutatorName": "Equality mutation",
          "replacement": "sb.Length != 0",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 31
            }
          },
          "status": "Killed"
        },
        {
          "id": "818",
          "mutatorName": "Negate expression",
          "replacement": "!(sb.Length == 0)",
          "location": {
            "start": {
              "line": 38,
              "column": 17
            },
            "end": {
              "line": 38,
              "column": 31
            }
          },
          "status": "Killed"
        },
        {
          "id": "819",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 39,
              "column": 47
            },
            "end": {
              "line": 39,
              "column": 76
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Serialization\\TypedYamlDeserializer.cs": {
      "language": "cs",
      "source": "using System;\r\nusing CSharpFunctionalExtensions;\r\nusing YamlDotNet.Core;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    internal abstract class TypedYamlDeserializer<" + "T> : ITypedYamlDeserializer\r\n    {\r\n        public abstract Result<" + "T, YamlException> TryDeserialize(IParser reader,\r\n            Func<" + "IParser, Type, object?> nestedObjectDeserializer);\r\n\r\n        /// <" + "inheritdoc />\r\n        public Type Type => typeof(T);\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "object, YamlException> TryDeserializeObject(IParser reader, Func<" + "IParser, Type, object?> nestedObjectDeserializer) =>\r\n            TryDeserialize(reader, nestedObjectDeserializer).Map(x=> (x as object)!);\r\n\r\n        protected static Result<" + "T2, YamlException> TryDeserializeNested<" + "T2>(Func<" + "IParser, Type, object?> nestedObjectDeserializer, IParser reader)\r\n        {\r\n            object? r;\r\n\r\n            try\r\n            {\r\n                r = nestedObjectDeserializer.Invoke(reader, typeof(T2));\r\n            }\r\n            catch (YamlException e)\r\n            {\r\n                return e;\r\n            }\r\n\r\n            var r2 = (T2) r!;\r\n\r\n            return r2;\r\n        }\r\n    }\r\n}",
      "mutants": []
    },
    "Core\\Serialization\\VariableNameComponent.cs": {
      "language": "cs",
      "source": "using CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.Internal;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Include a variable name in a serialization.\r\n    /// <" + "/summary>\r\n    public class VariableNameComponent : ISerializerBlock, IStepSerializerComponent\r\n    {\r\n        /// <" + "summary>\r\n        /// Deserializes a regex group into a Variable Name.\r\n        /// <" + "/summary>\r\n        public VariableNameComponent(string propertyName) => PropertyName = propertyName;\r\n\r\n        /// <" + "summary>\r\n        /// The name of the property.\r\n        /// <" + "/summary>\r\n        public string PropertyName { get; }\r\n\r\n        /// <" + "inheritdoc />\r\n        public Result<" + "string> TryGetText(FreezableStepData data) =>\r\n            data.GetVariableName(PropertyName)\r\n                .Bind(Serialize);\r\n\r\n        /// <" + "summary>\r\n        /// Serialize a variable name.\r\n        /// <" + "/summary>\r\n        public static Result<" + "string> Serialize(VariableName vn) => $\"<" + "{vn.Name}>\";\r\n\r\n\r\n        /// <" + "inheritdoc />\r\n        public ISerializerBlock? SerializerBlock => this;\r\n    }\r\n}",
      "mutants": [
        {
          "id": "820",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 29,
              "column": 68
            },
            "end": {
              "line": 29,
              "column": 82
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Serialization\\VersionTypeConverter.cs": {
      "language": "cs",
      "source": "using System;\r\nusing YamlDotNet.Core;\r\nusing YamlDotNet.Core.Events;\r\nusing YamlDotNet.Serialization;\r\nusing Version = System.Version;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Allows custom serialization of versions\r\n    /// <" + "/summary>\r\n    public class VersionTypeConverter : IYamlTypeConverter\r\n    {\r\n        private VersionTypeConverter() { }\r\n\r\n        /// <" + "summary>\r\n        /// The instance.\r\n        /// <" + "/summary>\r\n        public static IYamlTypeConverter Instance { get; } = new VersionTypeConverter();\r\n\r\n        /// <" + "inheritdoc />\r\n        public bool Accepts(Type type) => type == typeof(Version);\r\n\r\n        /// <" + "inheritdoc />\r\n        public object? ReadYaml(IParser parser, Type type)\r\n        {\r\n            if (type != typeof(Version) || !parser.TryConsume<" + "Scalar>(out var scalar)) return null;\r\n\r\n            var version = new Version(scalar.Value);\r\n            return version;\r\n\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public void WriteYaml(IEmitter emitter, object? value, Type type)\r\n        {\r\n            if (value is Version version) emitter.Emit(new Scalar(version.ToString()));\r\n        }\r\n    }\r\n}",
      "mutants": [
        {
          "id": "821",
          "mutatorName": "Equality mutation",
          "replacement": "type != typeof(Version)",
          "location": {
            "start": {
              "line": 22,
              "column": 43
            },
            "end": {
              "line": 22,
              "column": 66
            }
          },
          "status": "Killed"
        },
        {
          "id": "822",
          "mutatorName": "Logical mutation",
          "replacement": "type != typeof(Version) && !parser.TryConsume<" + "Scalar>(out var scalar)",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 86
            }
          },
          "status": "CompileError"
        },
        {
          "id": "823",
          "mutatorName": "Negate expression",
          "replacement": "!(type != typeof(Version) || !parser.TryConsume<" + "Scalar>(out var scalar))",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 86
            }
          },
          "status": "CompileError"
        },
        {
          "id": "824",
          "mutatorName": "Equality mutation",
          "replacement": "type == typeof(Version) ",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "825",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "parser.TryConsume<" + "Scalar>(out var scalar)",
          "location": {
            "start": {
              "line": 27,
              "column": 44
            },
            "end": {
              "line": 27,
              "column": 86
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Serialization\\YamlMethods.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Dynamic;\r\nusing System.Linq;\r\nusing CSharpFunctionalExtensions;\r\nusing Reductech.EDR.Core.General;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\nusing YamlDotNet.Core;\r\nusing YamlDotNet.Serialization;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Contains methods for converting Processes to and from Yaml.\r\n    /// <" + "/summary>\r\n    public static class YamlMethods\r\n    {\r\n        /// <" + "summary>\r\n        /// Serialize this step to yaml.\r\n        /// <" + "/summary>\r\n        public static string SerializeToYaml(this IFreezableStep step)\r\n        {\r\n            var obj = SimplifyProcess(step, true);\r\n\r\n            var builder = new SerializerBuilder().WithTypeConverter(VersionTypeConverter.Instance);\r\n\r\n            var serializer = builder.Build();\r\n\r\n            var r = serializer.Serialize(obj).Trim();\r\n\r\n            return r;\r\n        }\r\n\r\n\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Deserialize this yaml into a step.\r\n        /// <" + "/summary>\r\n        public static Result<" + "IFreezableStep> DeserializeFromYaml(string yaml, StepFactoryStore stepFactoryStore)\r\n        {\r\n            var parser = new StepMemberParser(stepFactoryStore);\r\n\r\n            var nodeDeserializer = new GeneralDeserializer(new ITypedYamlDeserializer []\r\n            {\r\n                new StepMemberDeserializer(parser),\r\n                new FreezableStepDeserializer(parser)\r\n            });\r\n\r\n            var builder =\r\n            new DeserializerBuilder()\r\n                .WithNodeDeserializer(nodeDeserializer)\r\n                .WithTypeConverter(VersionTypeConverter.Instance);\r\n\r\n\r\n            var deserializer = builder.Build();\r\n\r\n            StepMember stepMember;\r\n\r\n            try\r\n            {\r\n                stepMember = deserializer.Deserialize<" + "StepMember>(yaml);\r\n            }\r\n            catch (YamlException e)\r\n            {\r\n                return Result.Failure<" + "IFreezableStep>(e.GetFullMessage());\r\n            }\r\n\r\n\r\n            return Result.Success(stepMember)\r\n                .Bind(x=>x.TryConvert(MemberType.Step)\r\n                    .Bind(y=>y.AsArgument(\"Step\")));\r\n\r\n        }\r\n\r\n        internal const string TypeString = \"Do\";\r\n        internal const string ConfigString = \"Config\";\r\n\r\n        private static object SimplifyProcess(IFreezableStep step, bool isTopLevel)\r\n        {\r\n            switch (step)\r\n            {\r\n                case ConstantFreezableStep cfp:\r\n                    return SerializationMethods.SerializeConstant(cfp, false);\r\n                case CompoundFreezableStep compoundFreezableProcess:\r\n                {\r\n                    if (isTopLevel && compoundFreezableProcess.StepFactory == SequenceStepFactory.Instance &&\r\n                        compoundFreezableProcess.FreezableStepData.Dictionary.TryGetValue(nameof(Sequence.Steps), out var stepMember))\r\n                        return ToSimpleObject(stepMember);\r\n\r\n                    if (compoundFreezableProcess.StepConfiguration == null)//Don't use custom serialization if you have configuration\r\n                    {\r\n                            var sr = compoundFreezableProcess.StepFactory.Serializer\r\n                                    .TrySerialize(compoundFreezableProcess.FreezableStepData);\r\n                            if (sr.IsSuccess) //Serialization will not always succeed.\r\n                                return sr.Value;\r\n\r\n                    }\r\n\r\n                    IDictionary<" + "string, object> expandoObject = new ExpandoObject();\r\n                    expandoObject[TypeString] = compoundFreezableProcess.StepFactory.TypeName;\r\n\r\n                    if (compoundFreezableProcess.StepConfiguration != null)\r\n                        expandoObject[ConfigString] = compoundFreezableProcess.StepConfiguration;\r\n\r\n                    foreach (var (name, m) in compoundFreezableProcess.FreezableStepData.Dictionary)\r\n                        expandoObject[name] = ToSimpleObject(m);\r\n\r\n                    return expandoObject;\r\n\r\n                    }\r\n                default:\r\n                    throw new ArgumentOutOfRangeException(nameof(step));\r\n            }\r\n        }\r\n\r\n\r\n        private static object ToSimpleObject(StepMember member) =>\r\n            member.Join(x=> VariableNameComponent.Serialize(x).Value,\r\n                x=> SimplifyProcess(x, false),\r\n                l=>l.Select(x=>SimplifyProcess(x, false)).ToList());\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "826",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 24,
              "column": 45
            },
            "end": {
              "line": 24,
              "column": 49
            }
          },
          "status": "Killed"
        },
        {
          "id": "827",
          "mutatorName": "Array initializer mutation",
          "replacement": "new ITypedYamlDeserializer []\r\n{}",
          "location": {
            "start": {
              "line": 45,
              "column": 60
            },
            "end": {
              "line": 49,
              "column": 14
            }
          },
          "status": "Killed"
        },
        {
          "id": "828",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 73,
              "column": 43
            },
            "end": {
              "line": 73,
              "column": 49
            }
          },
          "status": "Survived"
        },
        {
          "id": "829",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 85,
              "column": 72
            },
            "end": {
              "line": 85,
              "column": 77
            }
          },
          "status": "Killed"
        },
        {
          "id": "830",
          "mutatorName": "Logical mutation",
          "replacement": "isTopLevel && compoundFreezableProcess.StepFactory == SequenceStepFactory.Instance ||\r\n                        compoundFreezableProcess.FreezableStepData.Dictionary.TryGetValue(nameof(Sequence.Steps), out var stepMember)",
          "location": {
            "start": {
              "line": 88,
              "column": 25
            },
            "end": {
              "line": 89,
              "column": 134
            }
          },
          "status": "CompileError"
        },
        {
          "id": "831",
          "mutatorName": "Negate expression",
          "replacement": "!(isTopLevel && compoundFreezableProcess.StepFactory == SequenceStepFactory.Instance &&\r\n                        compoundFreezableProcess.FreezableStepData.Dictionary.TryGetValue(nameof(Sequence.Steps), out var stepMember))",
          "location": {
            "start": {
              "line": 88,
              "column": 25
            },
            "end": {
              "line": 89,
              "column": 134
            }
          },
          "status": "CompileError"
        },
        {
          "id": "832",
          "mutatorName": "Logical mutation",
          "replacement": "isTopLevel || compoundFreezableProcess.StepFactory == SequenceStepFactory.Instance ",
          "location": {
            "start": {
              "line": 88,
              "column": 25
            },
            "end": {
              "line": 88,
              "column": 107
            }
          },
          "status": "Survived"
        },
        {
          "id": "833",
          "mutatorName": "Equality mutation",
          "replacement": "compoundFreezableProcess.StepFactory != SequenceStepFactory.Instance ",
          "location": {
            "start": {
              "line": 88,
              "column": 39
            },
            "end": {
              "line": 88,
              "column": 107
            }
          },
          "status": "Killed"
        },
        {
          "id": "834",
          "mutatorName": "Equality mutation",
          "replacement": "compoundFreezableProcess.StepConfiguration != null",
          "location": {
            "start": {
              "line": 92,
              "column": 25
            },
            "end": {
              "line": 92,
              "column": 75
            }
          },
          "status": "Killed"
        },
        {
          "id": "835",
          "mutatorName": "Negate expression",
          "replacement": "!(compoundFreezableProcess.StepConfiguration == null)",
          "location": {
            "start": {
              "line": 92,
              "column": 25
            },
            "end": {
              "line": 92,
              "column": 75
            }
          },
          "status": "Killed"
        },
        {
          "id": "836",
          "mutatorName": "Negate expression",
          "replacement": "!(sr.IsSuccess)",
          "location": {
            "start": {
              "line": 96,
              "column": 33
            },
            "end": {
              "line": 96,
              "column": 45
            }
          },
          "status": "Killed"
        },
        {
          "id": "837",
          "mutatorName": "Equality mutation",
          "replacement": "compoundFreezableProcess.StepConfiguration == null",
          "location": {
            "start": {
              "line": 104,
              "column": 25
            },
            "end": {
              "line": 104,
              "column": 75
            }
          },
          "status": "Killed"
        },
        {
          "id": "838",
          "mutatorName": "Negate expression",
          "replacement": "!(compoundFreezableProcess.StepConfiguration != null)",
          "location": {
            "start": {
              "line": 104,
              "column": 25
            },
            "end": {
              "line": 104,
              "column": 75
            }
          },
          "status": "Killed"
        },
        {
          "id": "839",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 121,
              "column": 40
            },
            "end": {
              "line": 121,
              "column": 45
            }
          },
          "status": "Survived"
        },
        {
          "id": "840",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 122,
              "column": 51
            },
            "end": {
              "line": 122,
              "column": 56
            }
          },
          "status": "Survived"
        }
      ]
    },
    "Core\\Serialization\\YamlRunner.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.IO;\r\nusing System.Threading.Tasks;\r\nusing CSharpFunctionalExtensions;\r\nusing JetBrains.Annotations;\r\nusing Microsoft.Extensions.Logging;\r\nusing Reductech.EDR.Core.Internal;\r\nusing Reductech.EDR.Core.Util;\r\n\r\nnamespace Reductech.EDR.Core.Serialization\r\n{\r\n    /// <" + "summary>\r\n    /// Runs processes from Yaml\r\n    /// <" + "/summary>\r\n    public class YamlRunner\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new Yaml Runner\r\n        /// <" + "/summary>\r\n        public YamlRunner(ISettings settings, ILogger logger,  StepFactoryStore stepFactoryStore)\r\n        {\r\n            _settings = settings;\r\n            _logger = logger;\r\n            _stepFactoryStore = stepFactoryStore;\r\n        }\r\n\r\n        private readonly ISettings _settings;\r\n        private readonly ILogger _logger;\r\n        private readonly StepFactoryStore _stepFactoryStore;\r\n\r\n        /// <" + "summary>\r\n        /// Run step defined in a yaml string.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"yamlString\">Yaml representing the step.<" + "/param>\r\n        /// <" + "returns><" + "/returns>\r\n        [UsedImplicitly]\r\n        public Result RunSequenceFromYamlString(string yamlString)\r\n        {\r\n            var result = YamlMethods.DeserializeFromYaml(yamlString, _stepFactoryStore)\r\n                    .Bind(x=>x.TryFreeze())\r\n                    .BindCast<" + "IStep, IStep<" + "Unit>>()\r\n                    .Bind(x=> x.Run(new StateMonad(_logger, _settings, ExternalProcessRunner.Instance))\r\n                        .MapFailure(y=>y.AsString));\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Run step defined in a yaml file.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"yamlPath\">Path to the yaml file.<" + "/param>\r\n        /// <" + "returns><" + "/returns>\r\n        [UsedImplicitly]\r\n        public async Task<" + "Result> RunSequenceFromYaml(string yamlPath)\r\n        {\r\n            string? text;\r\n            string? errorMessage;\r\n            try\r\n            {\r\n                text = await File.ReadAllTextAsync(yamlPath);\r\n                errorMessage = null;\r\n            }\r\n#pragma warning disable CA1031 // Do not catch general exception types\r\n            catch (Exception e)\r\n            {\r\n                errorMessage = e.Message;\r\n                text = null;\r\n            }\r\n#pragma warning restore CA1031 // Do not catch general exception types\r\n\r\n            if (errorMessage != null)\r\n                return Result.Failure<" + "string>(errorMessage);\r\n            else if (!string.IsNullOrWhiteSpace(text))\r\n                return RunSequenceFromYamlString(text);\r\n            else\r\n                return Result.Failure<" + "string>(\"File is empty\");\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "841",
          "mutatorName": "Equality mutation",
          "replacement": "errorMessage == null",
          "location": {
            "start": {
              "line": 72,
              "column": 17
            },
            "end": {
              "line": 72,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "842",
          "mutatorName": "Negate expression",
          "replacement": "!(errorMessage != null)",
          "location": {
            "start": {
              "line": 72,
              "column": 17
            },
            "end": {
              "line": 72,
              "column": 37
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "843",
          "mutatorName": "LogicalNotExpression to un-LogicalNotExpression mutation",
          "replacement": "string.IsNullOrWhiteSpace(text)",
          "location": {
            "start": {
              "line": 74,
              "column": 22
            },
            "end": {
              "line": 74,
              "column": 54
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "844",
          "mutatorName": "Negate expression",
          "replacement": "!(!string.IsNullOrWhiteSpace(text))",
          "location": {
            "start": {
              "line": 74,
              "column": 22
            },
            "end": {
              "line": 74,
              "column": 54
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "845",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 77,
              "column": 47
            },
            "end": {
              "line": 77,
              "column": 62
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Util\\Extensions.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Util\r\n{\r\n    /// <" + "summary>\r\n    /// SerializationMethods methods.\r\n    /// <" + "/summary>\r\n    public static class Extensions\r\n    {\r\n        /// <" + "summary>\r\n        /// Gets the description of an enum value from the Description Attribute.\r\n        /// <" + "/summary>\r\n        /// <" + "param name=\"value\"><" + "/param>\r\n        /// <" + "returns><" + "/returns>\r\n        public static string GetDescription(this Enum value)\r\n        {\r\n            var type = value.GetType();\r\n            var name = Enum.GetName(type, value);\r\n            if (name == null) return value.ToString();\r\n            var field = type.GetField(name);\r\n            if (field == null) return value.ToString();\r\n            var attr =\r\n                Attribute.GetCustomAttribute(field, typeof(DescriptionAttribute));\r\n            if (attr is DescriptionAttribute da)\r\n            {\r\n                return da.Description;\r\n            }\r\n            return value.ToString();\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Gets a full message from an exception.\r\n        /// <" + "/summary>\r\n        public static string GetFullMessage(this Exception exception)\r\n        {\r\n            if (exception.InnerException == null)\r\n                return exception.Message;\r\n\r\n            var innerMessage = exception.InnerException.GetFullMessage();\r\n\r\n            var message = $\"{exception.Message}\\r\\n{innerMessage}\";\r\n\r\n            return message;\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Gets the name of an enum value from the display attribute if it is present.\r\n        /// <" + "/summary>\r\n        public static string GetDisplayName(this Enum enumValue)\r\n        {\r\n            return enumValue.GetType()\r\n                            .GetMember(enumValue.ToString())?\r\n                            .First(x=>x.MemberType == MemberTypes.Field)?\r\n                            .GetCustomAttribute<" + "DisplayAttribute>()?\r\n                            .GetName()?? enumValue.ToString();\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Tries to parse the enum value. Uses both the name of the enum and the display name.\r\n        /// <" + "/summary>\r\n        public static Maybe<" + "T> TryParseValue<" + "T>(string s) where T : Enum\r\n        {\r\n            if (Enum.TryParse(typeof(T), s, true, out var r) && r is T t)\r\n                return CSharpFunctionalExtensions.Maybe<" + "T>.From(t);\r\n\r\n            foreach (var value in Enum.GetValues(typeof(T)).Cast<" + "T>())\r\n            {\r\n                if(value.ToString().Equals(s, StringComparison.OrdinalIgnoreCase))\r\n                    return CSharpFunctionalExtensions.Maybe<" + "T>.From(value);\r\n\r\n                var displayName = value.GetDisplayName();\r\n\r\n                if(displayName.Equals(s, StringComparison.OrdinalIgnoreCase))\r\n                    return CSharpFunctionalExtensions.Maybe<" + "T>.From(value);\r\n            }\r\n\r\n            return CSharpFunctionalExtensions.Maybe<" + "T>.None;\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Gets all possible values of this enum.\r\n        /// <" + "/summary>\r\n        public static IEnumerable<" + "T> GetEnumValues<" + "T>() where T: Enum => Enum.GetValues(typeof(T)).Cast<" + "T>();\r\n\r\n        /// <" + "summary>\r\n        /// Tries to get the element. Returns a failure if it is not present.\r\n        /// <" + "/summary>\r\n#pragma warning disable 8714\r\n        public static Result<" + "TValue> TryFindOrFail<" + "TKey, TValue>(this IReadOnlyDictionary<" + "TKey, TValue> dictionary, TKey key, string? error)\r\n            =>  dictionary.TryFind(key).ToResult(error??$\"The element '{key}' was not present.\");\r\n\r\n        /// <" + "summary>\r\n        /// Returns this nullable value as a maybe.\r\n        /// <" + "/summary>\r\n        public static Maybe<" + "T> Maybe<" + "T>(this T? str) where T : struct => str.HasValue ? CSharpFunctionalExtensions.Maybe<" + "T>.From(str.Value) : CSharpFunctionalExtensions.Maybe<" + "T>.None;\r\n\r\n        /// <" + "summary>\r\n        /// Gets each element paired with it's index.\r\n        /// <" + "/summary>\r\n        public static IEnumerable<" + "(T item, int index)> WithIndex<" + "T>(this IEnumerable<" + "T> self) => self.Select((item, index) => (item, index));\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Returns the values of elements of the sequence.\r\n        /// <" + "/summary>\r\n        public static IEnumerable<" + "T> WhereNotNull<" + "T>(this IEnumerable<" + "T?> source) where T : struct => from val in source where val.HasValue select val.Value;\r\n\r\n        /// <" + "summary>\r\n        /// Returns the elements of the sequence which are not null.\r\n        /// <" + "/summary>\r\n        public static IEnumerable<" + "T> WhereNotNull<" + "T>(this IEnumerable<" + "T?> source) where T : class => (from val in source where val != null select val)!;\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Tries to get this value of an enum type. Returns a failure if it is not present.\r\n        /// <" + "/summary>\r\n        public static Result<" + "object> TryGetEnumValue(Type enumType, string value)\r\n        {\r\n            if (Enum.TryParse(enumType, value, true, out var r))\r\n                return r!;\r\n\r\n            return Result.Failure<" + "object>($\"{enumType.Name} does not have a value '{value}'\");\r\n        }\r\n#pragma warning restore 8714\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "846",
          "mutatorName": "Equality mutation",
          "replacement": "name != null",
          "location": {
            "start": {
              "line": 25,
              "column": 17
            },
            "end": {
              "line": 25,
              "column": 29
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "847",
          "mutatorName": "Negate expression",
          "replacement": "!(name == null)",
          "location": {
            "start": {
              "line": 25,
              "column": 17
            },
            "end": {
              "line": 25,
              "column": 29
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "848",
          "mutatorName": "Equality mutation",
          "replacement": "field != null",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "849",
          "mutatorName": "Negate expression",
          "replacement": "!(field == null)",
          "location": {
            "start": {
              "line": 27,
              "column": 17
            },
            "end": {
              "line": 27,
              "column": 30
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "850",
          "mutatorName": "Equality mutation",
          "replacement": "exception.InnerException != null",
          "location": {
            "start": {
              "line": 42,
              "column": 17
            },
            "end": {
              "line": 42,
              "column": 49
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "851",
          "mutatorName": "Negate expression",
          "replacement": "!(exception.InnerException == null)",
          "location": {
            "start": {
              "line": 42,
              "column": 17
            },
            "end": {
              "line": 42,
              "column": 49
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "852",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 47,
              "column": 27
            },
            "end": {
              "line": 47,
              "column": 67
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "853",
          "mutatorName": "Linq method mutation (First() to FirstOrDefault())",
          "replacement": "enumValue.GetType()\r\n                            .GetMember(enumValue.ToString())?\r\n                            .FirstOrDefault(x=>x.MemberType == MemberTypes.Field)?\r\n                            .GetCustomAttribute<" + "DisplayAttribute>()?\r\n                            .GetName()",
          "location": {
            "start": {
              "line": 58,
              "column": 20
            },
            "end": {
              "line": 62,
              "column": 39
            }
          },
          "status": "Survived"
        },
        {
          "id": "854",
          "mutatorName": "Equality mutation",
          "replacement": "x.MemberType != MemberTypes.Field",
          "location": {
            "start": {
              "line": 60,
              "column": 39
            },
            "end": {
              "line": 60,
              "column": 72
            }
          },
          "status": "Killed"
        },
        {
          "id": "855",
          "mutatorName": "Logical mutation",
          "replacement": "Enum.TryParse(typeof(T), s, true, out var r) || r is T t",
          "location": {
            "start": {
              "line": 70,
              "column": 17
            },
            "end": {
              "line": 70,
              "column": 73
            }
          },
          "status": "CompileError"
        },
        {
          "id": "856",
          "mutatorName": "Negate expression",
          "replacement": "!(Enum.TryParse(typeof(T), s, true, out var r) && r is T t)",
          "location": {
            "start": {
              "line": 70,
              "column": 17
            },
            "end": {
              "line": 70,
              "column": 73
            }
          },
          "status": "CompileError"
        },
        {
          "id": "857",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 70,
              "column": 45
            },
            "end": {
              "line": 70,
              "column": 49
            }
          },
          "status": "Survived"
        },
        {
          "id": "858",
          "mutatorName": "Negate expression",
          "replacement": "!(value.ToString().Equals(s, StringComparison.OrdinalIgnoreCase))",
          "location": {
            "start": {
              "line": 75,
              "column": 20
            },
            "end": {
              "line": 75,
              "column": 82
            }
          },
          "status": "Killed"
        },
        {
          "id": "859",
          "mutatorName": "Negate expression",
          "replacement": "!(displayName.Equals(s, StringComparison.OrdinalIgnoreCase))",
          "location": {
            "start": {
              "line": 80,
              "column": 20
            },
            "end": {
              "line": 80,
              "column": 77
            }
          },
          "status": "Killed"
        },
        {
          "id": "860",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 98,
              "column": 57
            },
            "end": {
              "line": 98,
              "column": 96
            }
          },
          "status": "Survived"
        },
        {
          "id": "861",
          "mutatorName": "Negate expression",
          "replacement": "!(str.HasValue )",
          "location": {
            "start": {
              "line": 103,
              "column": 74
            },
            "end": {
              "line": 103,
              "column": 86
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "862",
          "mutatorName": "Equality mutation",
          "replacement": "val == null ",
          "location": {
            "start": {
              "line": 119,
              "column": 128
            },
            "end": {
              "line": 119,
              "column": 139
            }
          },
          "status": "Killed"
        },
        {
          "id": "863",
          "mutatorName": "Negate expression",
          "replacement": "!(Enum.TryParse(enumType, value, true, out var r))",
          "location": {
            "start": {
              "line": 127,
              "column": 17
            },
            "end": {
              "line": 127,
              "column": 64
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "864",
          "mutatorName": "Boolean mutation",
          "replacement": "false",
          "location": {
            "start": {
              "line": 127,
              "column": 48
            },
            "end": {
              "line": 127,
              "column": 52
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "865",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 130,
              "column": 43
            },
            "end": {
              "line": 130,
              "column": 93
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Util\\FunctionalExtensions.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Util\r\n{\r\n    /// <" + "summary>\r\n    /// Functional methods\r\n    /// <" + "/summary>\r\n    public static class FunctionalExtensions\r\n    {\r\n        /// <" + "summary>\r\n        /// Tries to match this regex.\r\n        /// <" + "/summary>\r\n        public static bool TryMatch(this Regex regex, string s, out Match m)\r\n        {\r\n            m = regex.Match(s);\r\n            return m.Success;\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Casts this object to type T. Returns failure if the cast fails.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T> TryCast<" + "T>(this object obj)\r\n        {\r\n            if (obj is T type)\r\n                return type;\r\n\r\n            return Result.Failure<" + "T>($\"Could not cast '{obj}' to {typeof(T).Name}\");\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Converts this object to type T. Returns failure if the cast fails.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T> TryConvert<" + "T>(this object obj)\r\n        {\r\n            if (obj is T objAsT)\r\n                return objAsT;\r\n\r\n            var converted = Convert.ChangeType(obj, typeof(T));\r\n\r\n            if (converted is T objConverted)\r\n                return objConverted;\r\n\r\n            return Result.Failure<" + "T>($\"Could not cast '{obj}' to {typeof(T).Name}\");\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Casts the elements of the sequence to type T. Returns failure if the cast fails.\r\n        /// <" + "/summary>\r\n        public static Result<" + "IReadOnlyCollection<" + "T2>> TryCastElements<" + "T1, T2>(this IReadOnlyCollection<" + "T1> collection) where T2 : T1 =>\r\n            collection.Select(x =>\r\n                x!.TryCast<" + "T2>()).Combine().Map(x => x.ToList() as IReadOnlyCollection<" + "T2>);\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Converts the elements of the sequence to type T2. Returns failure if the cast fails.\r\n        /// <" + "/summary>\r\n        public static Result<" + "IReadOnlyCollection<" + "T2>> TryConvertElements<" + "T1, T2>(this IReadOnlyCollection<" + "T1> collection) where T2 : T1 =>\r\n            collection.Select(x => x!.TryConvert<" + "T2>()).Combine().Map(x => x.ToList() as IReadOnlyCollection<" + "T2>);\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Casts the elements of the sequence to type T2. Returns failure if the cast fails.\r\n        /// <" + "/summary>\r\n        public static Result<" + "IReadOnlyCollection<" + "T2>> TryConvertElements<" + "T1, T2>(this IReadOnlyCollection<" + "T1> collection, Func<" + "T1, Result<" + "T2>> tryConvert) where T2 : T1 =>\r\n            collection.Select(tryConvert).Combine().Map(x => x.ToList() as IReadOnlyCollection<" + "T2>);\r\n\r\n\r\n        /// <" + "summary>\r\n        /// If the result is a failure, convert the error to a string.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T> MapFailure<" + "T, TE>(this Result<" + "T, TE> result, Func<" + "TE, string> convertError)\r\n        {\r\n            if (result.IsSuccess) return result.Value!;\r\n\r\n            var errorString = convertError(result.Error);\r\n\r\n            return Result.Failure<" + "T>(errorString);\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// If the result is a failure, convert the error to another type.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T, TE> MapFailure<" + "T, TE>(this Result<" + "T> result, Func<" + "string, TE> convertError)\r\n        {\r\n            if (result.IsSuccess) return result.Value!;\r\n\r\n            var error2 = convertError(result.Error);\r\n\r\n            return error2!;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// If the result is a failure, convert the error to another type.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T,TE2> MapFailure<" + "T, TE1, TE2>(this Result<" + "T, TE1> result, Func<" + "TE1, TE2> convertError)\r\n        {\r\n            if (result.IsSuccess) return result.Value!;\r\n\r\n            var error2 = convertError(result.Error);\r\n\r\n            return error2!;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Casts the result to type T2.\r\n        /// Returns failure if this cast is not possible.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T2> BindCast<" + "T1, T2>(this Result<" + "T1> result) where T2 : T1\r\n        {\r\n            if (result.IsFailure) return result.ConvertFailure<" + "T2>();\r\n\r\n            if (result.Value is T2 t2) return t2;\r\n\r\n            return Result.Failure<" + "T2>($\"{result.Value} is not of type '{typeof(T2).Name}'\");\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Casts the result to type T2.\r\n        /// Returns failure if this cast is not possible.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T2, TE> BindCast<" + "T1, T2, TE>(this Result<" + "T1, TE> result, TE error)// where T2 : T1\r\n        {\r\n            if (result.IsFailure) return result.ConvertFailure<" + "T2>();\r\n\r\n            if (result.Value is T2 t2) return t2;\r\n\r\n            return Result.Failure<" + "T2, TE>(error);\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Casts the maybe to type T2.\r\n        /// Returns failure if this cast is not possible.\r\n        /// <" + "/summary>\r\n        public static Maybe<" + "T2> BindCast<" + "T1, T2>(this Maybe<" + "T1> result)  where T2 : T1\r\n        {\r\n            if (result.HasNoValue) return Maybe<" + "T2>.None;\r\n\r\n            if (result.Value is T2 t2) return t2;\r\n\r\n            return Maybe<" + "T2>.None;\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Returns a single value from the sequence or a failure.\r\n        /// <" + "/summary>\r\n        public static Result<" + "T> BindSingle<" + "T>(this Result<" + "IReadOnlyList<" + "T>> result)\r\n        {\r\n            if (result.IsFailure) return result.ConvertFailure<" + "T>();\r\n\r\n            if (result.Value.Count == 0) return Result.Failure<" + "T>(\"Sequence has no elements\");\r\n            else if(result.Value.Count > 1) return Result.Failure<" + "T>(\"Sequence has more than one element\");\r\n\r\n            return result.Value.Single()!;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Create a tuple with 2 results.\r\n        /// Func2 will not be evaluated unless result1 is success.\r\n        /// <" + "/summary>\r\n        public static Result<" + "(T1, T2)> Compose<" + "T1, T2>(this Result<" + "T1> result1, Func<" + "Result<" + "T2>> func2)\r\n        {\r\n            if (result1.IsFailure) return result1.ConvertFailure<" + "(T1, T2)>();\r\n\r\n            var result2 = func2();\r\n\r\n            if (result2.IsFailure) return result2.ConvertFailure<" + "(T1, T2)>();\r\n\r\n            return (result1.Value, result2.Value);\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Create a tuple with 3 results.\r\n        /// Func2 will not be evaluated unless result1 is success.\r\n        /// Func3 will not be evaluated unless the result of Func2 is success.\r\n        /// <" + "/summary>\r\n        public static Result<" + "(T1, T2, T3)> Compose<" + "T1, T2, T3>(this Result<" + "T1> result1, Func<" + "Result<" + "T2>> func2, Func<" + "Result<" + "T3>> func3)\r\n        {\r\n            if (result1.IsFailure) return result1.ConvertFailure<" + "(T1, T2, T3)>();\r\n\r\n            var result2 = func2();\r\n\r\n            if (result2.IsFailure) return result2.ConvertFailure<" + "(T1, T2, T3)>();\r\n\r\n            var result3 = func3();\r\n\r\n            if (result3.IsFailure) return result3.ConvertFailure<" + "(T1, T2, T3)>();\r\n\r\n            return (result1.Value, result2.Value, result3.Value);\r\n\r\n        }\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Create a tuple with 2 results.\r\n        /// Func2 will not be evaluated unless result1 is success.\r\n        /// <" + "/summary>\r\n        public static Result<" + "(T1, T2), TE> Compose<" + "T1, T2, TE>(this Result<" + "T1, TE> result1, Func<" + "Result<" + "T2, TE>> func2)\r\n        {\r\n            if (result1.IsFailure) return result1.ConvertFailure<" + "(T1, T2)>();\r\n\r\n            var result2 = func2();\r\n\r\n            if (result2.IsFailure) return result2.ConvertFailure<" + "(T1, T2)>();\r\n\r\n            return (result1.Value, result2.Value);\r\n\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Create a tuple with 3 results.\r\n        /// Func2 will not be evaluated unless result1 is success.\r\n        /// Func3 will not be evaluated unless the result of Func2 is success.\r\n        /// <" + "/summary>\r\n        public static Result<" + "(T1, T2, T3), TE> Compose<" + "T1, T2, T3, TE>(this Result<" + "T1, TE> result1, Func<" + "Result<" + "T2, TE>> func2, Func<" + "Result<" + "T3, TE>> func3)\r\n        {\r\n            if (result1.IsFailure) return result1.ConvertFailure<" + "(T1, T2, T3)>();\r\n\r\n            var result2 = func2();\r\n\r\n            if (result2.IsFailure) return result2.ConvertFailure<" + "(T1, T2, T3)>();\r\n\r\n            var result3 = func3();\r\n\r\n            if (result3.IsFailure) return result3.ConvertFailure<" + "(T1, T2, T3)>();\r\n\r\n            return (result1.Value, result2.Value, result3.Value);\r\n\r\n        }\r\n\r\n\r\n    }\r\n}",
      "mutants": [
        {
          "id": "866",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 32,
              "column": 38
            },
            "end": {
              "line": 32,
              "column": 83
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "867",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 48,
              "column": 38
            },
            "end": {
              "line": 48,
              "column": 83
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "868",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsSuccess)",
          "location": {
            "start": {
              "line": 78,
              "column": 17
            },
            "end": {
              "line": 78,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "869",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsSuccess)",
          "location": {
            "start": {
              "line": 91,
              "column": 17
            },
            "end": {
              "line": 91,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "870",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsSuccess)",
          "location": {
            "start": {
              "line": 103,
              "column": 17
            },
            "end": {
              "line": 103,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "871",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsFailure)",
          "location": {
            "start": {
              "line": 116,
              "column": 17
            },
            "end": {
              "line": 116,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "872",
          "mutatorName": "String mutation",
          "replacement": "$\"\"",
          "location": {
            "start": {
              "line": 120,
              "column": 39
            },
            "end": {
              "line": 120,
              "column": 91
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "873",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsFailure)",
          "location": {
            "start": {
              "line": 130,
              "column": 17
            },
            "end": {
              "line": 130,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "874",
          "mutatorName": "Negate expression",
          "replacement": "!(result.HasNoValue)",
          "location": {
            "start": {
              "line": 144,
              "column": 17
            },
            "end": {
              "line": 144,
              "column": 34
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "875",
          "mutatorName": "Negate expression",
          "replacement": "!(result.IsFailure)",
          "location": {
            "start": {
              "line": 157,
              "column": 17
            },
            "end": {
              "line": 157,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "876",
          "mutatorName": "Equality mutation",
          "replacement": "result.Value.Count != 0",
          "location": {
            "start": {
              "line": 159,
              "column": 17
            },
            "end": {
              "line": 159,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "877",
          "mutatorName": "Negate expression",
          "replacement": "!(result.Value.Count == 0)",
          "location": {
            "start": {
              "line": 159,
              "column": 17
            },
            "end": {
              "line": 159,
              "column": 40
            }
          },
          "status": "Killed"
        },
        {
          "id": "878",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 159,
              "column": 67
            },
            "end": {
              "line": 159,
              "column": 93
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "879",
          "mutatorName": "Equality mutation",
          "replacement": "result.Value.Count <" + " 1",
          "location": {
            "start": {
              "line": 160,
              "column": 21
            },
            "end": {
              "line": 160,
              "column": 43
            }
          },
          "status": "Survived"
        },
        {
          "id": "880",
          "mutatorName": "Equality mutation",
          "replacement": "result.Value.Count >= 1",
          "location": {
            "start": {
              "line": 160,
              "column": 21
            },
            "end": {
              "line": 160,
              "column": 43
            }
          },
          "status": "Killed"
        },
        {
          "id": "881",
          "mutatorName": "Negate expression",
          "replacement": "!(result.Value.Count > 1)",
          "location": {
            "start": {
              "line": 160,
              "column": 21
            },
            "end": {
              "line": 160,
              "column": 43
            }
          },
          "status": "Killed"
        },
        {
          "id": "882",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 160,
              "column": 70
            },
            "end": {
              "line": 160,
              "column": 106
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "883",
          "mutatorName": "Linq method mutation (Single() to SingleOrDefault())",
          "replacement": "result.Value.SingleOrDefault()",
          "location": {
            "start": {
              "line": 162,
              "column": 20
            },
            "end": {
              "line": 162,
              "column": 41
            }
          },
          "status": "Survived"
        },
        {
          "id": "884",
          "mutatorName": "Negate expression",
          "replacement": "!(result1.IsFailure)",
          "location": {
            "start": {
              "line": 171,
              "column": 17
            },
            "end": {
              "line": 171,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "885",
          "mutatorName": "Negate expression",
          "replacement": "!(result2.IsFailure)",
          "location": {
            "start": {
              "line": 175,
              "column": 17
            },
            "end": {
              "line": 175,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "886",
          "mutatorName": "Negate expression",
          "replacement": "!(result1.IsFailure)",
          "location": {
            "start": {
              "line": 188,
              "column": 17
            },
            "end": {
              "line": 188,
              "column": 34
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "887",
          "mutatorName": "Negate expression",
          "replacement": "!(result2.IsFailure)",
          "location": {
            "start": {
              "line": 192,
              "column": 17
            },
            "end": {
              "line": 192,
              "column": 34
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "888",
          "mutatorName": "Negate expression",
          "replacement": "!(result3.IsFailure)",
          "location": {
            "start": {
              "line": 196,
              "column": 17
            },
            "end": {
              "line": 196,
              "column": 34
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "889",
          "mutatorName": "Negate expression",
          "replacement": "!(result1.IsFailure)",
          "location": {
            "start": {
              "line": 209,
              "column": 17
            },
            "end": {
              "line": 209,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "890",
          "mutatorName": "Negate expression",
          "replacement": "!(result2.IsFailure)",
          "location": {
            "start": {
              "line": 213,
              "column": 17
            },
            "end": {
              "line": 213,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "891",
          "mutatorName": "Negate expression",
          "replacement": "!(result1.IsFailure)",
          "location": {
            "start": {
              "line": 226,
              "column": 17
            },
            "end": {
              "line": 226,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "892",
          "mutatorName": "Negate expression",
          "replacement": "!(result2.IsFailure)",
          "location": {
            "start": {
              "line": 230,
              "column": 17
            },
            "end": {
              "line": 230,
              "column": 34
            }
          },
          "status": "Killed"
        },
        {
          "id": "893",
          "mutatorName": "Negate expression",
          "replacement": "!(result3.IsFailure)",
          "location": {
            "start": {
              "line": 234,
              "column": 17
            },
            "end": {
              "line": 234,
              "column": 34
            }
          },
          "status": "Killed"
        }
      ]
    },
    "Core\\Util\\Option.cs": {
      "language": "cs",
      "source": "using System;\r\nusing System.Data;\r\nusing CSharpFunctionalExtensions;\r\n\r\nnamespace Reductech.EDR.Core.Util\r\n{\r\n    /// <" + "summary>\r\n    /// One of two possible objects.\r\n    /// <" + "/summary>\r\n    public sealed class Option<" + "T1, T2>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new option\r\n        /// <" + "/summary>\r\n        public Option(T1 t1)\r\n        {\r\n            Choice1 = Maybe<" + "T1>.From(t1);\r\n            Choice2 = Maybe<" + "T2>.None;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Creates a new option\r\n        /// <" + "/summary>\r\n        public Option(T2 t2)\r\n        {\r\n            Choice1 = Maybe<" + "T1>.None;\r\n            Choice2 = Maybe<" + "T2>.From(t2);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The first choice if it is set.\r\n        /// <" + "/summary>\r\n        public Maybe<" + "T1> Choice1 { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The second choice if it is set.\r\n        /// <" + "/summary>\r\n        public Maybe<" + "T2> Choice2 { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Use this option\r\n        /// <" + "/summary>\r\n        public TResult Join<" + "TResult>(Func<" + "T1, TResult> f1, Func<" + "T2, TResult> f2)\r\n        {\r\n            if (Choice1.HasValue)\r\n                return f1(Choice1.Value);\r\n            if (Choice2.HasValue)\r\n                return f2(Choice2.Value);\r\n\r\n            throw new StrongTypingException(\"No options are set.\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string? ToString() => Join(x => x?.ToString(), x => x?.ToString());\r\n\r\n\r\n        /// <" + "summary>\r\n        /// Determines if this is equal to another object.\r\n        /// <" + "/summary>\r\n        public bool Equals(Option<" + "T1, T2> other, Func<" + "T1, T1, bool> equals1, Func<" + "T2, T2, bool> equals2)\r\n        {\r\n            if (Choice1.HasValue && other.Choice1.HasValue)\r\n                return equals1(Choice1.Value, other.Choice1.Value);\r\n\r\n            if (Choice2.HasValue && other.Choice2.HasValue)\r\n                return equals2(Choice2.Value, other.Choice2.Value);\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /// <" + "summary>\r\n    /// One of three possible objects.\r\n    /// <" + "/summary>\r\n    public sealed class Option<" + "T1, T2, T3>\r\n    {\r\n        /// <" + "summary>\r\n        /// Creates a new option\r\n        /// <" + "/summary>\r\n        public Option(T1 t1)\r\n        {\r\n            Choice1 = Maybe<" + "T1>.From(t1);\r\n            Choice2 = Maybe<" + "T2>.None;\r\n            Choice3 = Maybe<" + "T3>.None;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Creates a new option\r\n        /// <" + "/summary>\r\n        public Option(T2 t2)\r\n        {\r\n            Choice1 = Maybe<" + "T1>.None;\r\n            Choice2 = Maybe<" + "T2>.From(t2);\r\n            Choice3 = Maybe<" + "T3>.None;\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// Creates a new option\r\n        /// <" + "/summary>\r\n        public Option(T3 t3)\r\n        {\r\n            Choice1 = Maybe<" + "T1>.None;\r\n            Choice2 = Maybe<" + "T2>.None;\r\n            Choice3 = Maybe<" + "T3>.From(t3);\r\n        }\r\n\r\n        /// <" + "summary>\r\n        /// The first choice if it is set.\r\n        /// <" + "/summary>\r\n        public Maybe<" + "T1> Choice1 { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The second choice if it is set.\r\n        /// <" + "/summary>\r\n        public Maybe<" + "T2> Choice2 { get; }\r\n\r\n        /// <" + "summary>\r\n        /// The third choice if it is set.\r\n        /// <" + "/summary>\r\n        public Maybe<" + "T3> Choice3 { get; }\r\n\r\n        /// <" + "summary>\r\n        /// Use this option\r\n        /// <" + "/summary>\r\n        public TResult Join<" + "TResult>(Func<" + "T1, TResult> f1, Func<" + "T2, TResult> f2, Func<" + "T3, TResult> f3)\r\n        {\r\n            if (Choice1.HasValue)\r\n                return f1(Choice1.Value);\r\n            if (Choice2.HasValue)\r\n                return f2(Choice2.Value);\r\n            if (Choice3.HasValue)\r\n                return f3(Choice3.Value);\r\n\r\n\r\n            throw new StrongTypingException(\"No options are set.\");\r\n        }\r\n\r\n        /// <" + "inheritdoc />\r\n        public override string? ToString() => Join(x => x?.ToString(), x => x?.ToString(), x=>x?.ToString());\r\n\r\n        /// <" + "summary>\r\n        /// Determines if this is equal to another object.\r\n        /// <" + "/summary>\r\n        public bool Equals(Option<" + "T1, T2, T3> other, Func<" + "T1, T1, bool> equals1, Func<" + "T2, T2, bool> equals2, Func<" + "T3, T3, bool> equals3)\r\n        {\r\n            if (Choice1.HasValue && other.Choice1.HasValue)\r\n                return equals1(Choice1.Value, other.Choice1.Value);\r\n\r\n            if (Choice2.HasValue && other.Choice2.HasValue)\r\n                return equals2(Choice2.Value, other.Choice2.Value);\r\n\r\n            if (Choice3.HasValue && other.Choice3.HasValue)\r\n                return equals3(Choice3.Value, other.Choice3.Value);\r\n\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
      "mutants": [
        {
          "id": "894",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice1.HasValue)",
          "location": {
            "start": {
              "line": 45,
              "column": 17
            },
            "end": {
              "line": 45,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "895",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice2.HasValue)",
          "location": {
            "start": {
              "line": 47,
              "column": 17
            },
            "end": {
              "line": 47,
              "column": 33
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "896",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 50,
              "column": 45
            },
            "end": {
              "line": 50,
              "column": 66
            }
          },
          "status": "Ignored"
        },
        {
          "id": "897",
          "mutatorName": "Logical mutation",
          "replacement": "Choice1.HasValue || other.Choice1.HasValue",
          "location": {
            "start": {
              "line": 62,
              "column": 17
            },
            "end": {
              "line": 62,
              "column": 59
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "898",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice1.HasValue && other.Choice1.HasValue)",
          "location": {
            "start": {
              "line": 62,
              "column": 17
            },
            "end": {
              "line": 62,
              "column": 59
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "899",
          "mutatorName": "Logical mutation",
          "replacement": "Choice2.HasValue || other.Choice2.HasValue",
          "location": {
            "start": {
              "line": 65,
              "column": 17
            },
            "end": {
              "line": 65,
              "column": 59
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "900",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice2.HasValue && other.Choice2.HasValue)",
          "location": {
            "start": {
              "line": 65,
              "column": 17
            },
            "end": {
              "line": 65,
              "column": 59
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "901",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 68,
              "column": 20
            },
            "end": {
              "line": 68,
              "column": 25
            }
          },
          "status": "NoCoverage"
        },
        {
          "id": "902",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice1.HasValue)",
          "location": {
            "start": {
              "line": 129,
              "column": 17
            },
            "end": {
              "line": 129,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "903",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice2.HasValue)",
          "location": {
            "start": {
              "line": 131,
              "column": 17
            },
            "end": {
              "line": 131,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "904",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice3.HasValue)",
          "location": {
            "start": {
              "line": 133,
              "column": 17
            },
            "end": {
              "line": 133,
              "column": 33
            }
          },
          "status": "Killed"
        },
        {
          "id": "905",
          "mutatorName": "String mutation",
          "replacement": "\"\"",
          "location": {
            "start": {
              "line": 137,
              "column": 45
            },
            "end": {
              "line": 137,
              "column": 66
            }
          },
          "status": "Ignored"
        },
        {
          "id": "906",
          "mutatorName": "Logical mutation",
          "replacement": "Choice1.HasValue || other.Choice1.HasValue",
          "location": {
            "start": {
              "line": 148,
              "column": 17
            },
            "end": {
              "line": 148,
              "column": 59
            }
          },
          "status": "Survived"
        },
        {
          "id": "907",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice1.HasValue && other.Choice1.HasValue)",
          "location": {
            "start": {
              "line": 148,
              "column": 17
            },
            "end": {
              "line": 148,
              "column": 59
            }
          },
          "status": "Killed"
        },
        {
          "id": "908",
          "mutatorName": "Logical mutation",
          "replacement": "Choice2.HasValue || other.Choice2.HasValue",
          "location": {
            "start": {
              "line": 151,
              "column": 17
            },
            "end": {
              "line": 151,
              "column": 59
            }
          },
          "status": "Survived"
        },
        {
          "id": "909",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice2.HasValue && other.Choice2.HasValue)",
          "location": {
            "start": {
              "line": 151,
              "column": 17
            },
            "end": {
              "line": 151,
              "column": 59
            }
          },
          "status": "Killed"
        },
        {
          "id": "910",
          "mutatorName": "Logical mutation",
          "replacement": "Choice3.HasValue || other.Choice3.HasValue",
          "location": {
            "start": {
              "line": 154,
              "column": 17
            },
            "end": {
              "line": 154,
              "column": 59
            }
          },
          "status": "Survived"
        },
        {
          "id": "911",
          "mutatorName": "Negate expression",
          "replacement": "!(Choice3.HasValue && other.Choice3.HasValue)",
          "location": {
            "start": {
              "line": 154,
              "column": 17
            },
            "end": {
              "line": 154,
              "column": 59
            }
          },
          "status": "Killed"
        },
        {
          "id": "912",
          "mutatorName": "Boolean mutation",
          "replacement": "true",
          "location": {
            "start": {
              "line": 157,
              "column": 20
            },
            "end": {
              "line": 157,
              "column": 25
            }
          },
          "status": "NoCoverage"
        }
      ]
    },
    "Core\\Util\\Unit.cs": {
      "language": "cs",
      "source": "namespace Reductech.EDR.Core.Util\r\n{\r\n    /// <" + "summary>\r\n    /// The result of a step with not return value.\r\n    /// <" + "/summary>\r\n    public sealed class Unit\r\n    {\r\n        /// <" + "summary>\r\n        /// The Unit.\r\n        /// <" + "/summary>\r\n        public static readonly Unit Default = new Unit();\r\n\r\n        private Unit() {}\r\n    }\r\n}",
      "mutants": []
    }
  }
};
        </script>
    </body>
</html>
